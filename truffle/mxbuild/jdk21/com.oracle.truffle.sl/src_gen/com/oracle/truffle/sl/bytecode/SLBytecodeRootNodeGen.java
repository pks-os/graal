// CheckStyle: start generated
package com.oracle.truffle.sl.bytecode;

import com.oracle.truffle.api.Assumption;
import com.oracle.truffle.api.CompilerAsserts;
import com.oracle.truffle.api.CompilerDirectives;
import com.oracle.truffle.api.RootCallTarget;
import com.oracle.truffle.api.TruffleStackTraceElement;
import com.oracle.truffle.api.CompilerDirectives.CompilationFinal;
import com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;
import com.oracle.truffle.api.HostCompilerDirectives.BytecodeInterpreterSwitch;
import com.oracle.truffle.api.HostCompilerDirectives.InliningCutoff;
import com.oracle.truffle.api.bytecode.BytecodeBuilder;
import com.oracle.truffle.api.bytecode.BytecodeConfig;
import com.oracle.truffle.api.bytecode.BytecodeConfigEncoder;
import com.oracle.truffle.api.bytecode.BytecodeDSLAccess;
import com.oracle.truffle.api.bytecode.BytecodeEncodingException;
import com.oracle.truffle.api.bytecode.BytecodeLabel;
import com.oracle.truffle.api.bytecode.BytecodeLocal;
import com.oracle.truffle.api.bytecode.BytecodeLocation;
import com.oracle.truffle.api.bytecode.BytecodeNode;
import com.oracle.truffle.api.bytecode.BytecodeParser;
import com.oracle.truffle.api.bytecode.BytecodeRootNode;
import com.oracle.truffle.api.bytecode.BytecodeRootNodes;
import com.oracle.truffle.api.bytecode.BytecodeTier;
import com.oracle.truffle.api.bytecode.ExceptionHandler;
import com.oracle.truffle.api.bytecode.Instruction;
import com.oracle.truffle.api.bytecode.LocalVariable;
import com.oracle.truffle.api.bytecode.SourceInformation;
import com.oracle.truffle.api.bytecode.SourceInformationTree;
import com.oracle.truffle.api.bytecode.TagTree;
import com.oracle.truffle.api.bytecode.TagTreeNode;
import com.oracle.truffle.api.bytecode.BytecodeSupport.CloneReferenceList;
import com.oracle.truffle.api.bytecode.serialization.BytecodeDeserializer;
import com.oracle.truffle.api.bytecode.serialization.BytecodeSerializer;
import com.oracle.truffle.api.bytecode.serialization.SerializationUtils;
import com.oracle.truffle.api.bytecode.serialization.BytecodeDeserializer.DeserializerContext;
import com.oracle.truffle.api.bytecode.serialization.BytecodeSerializer.SerializerContext;
import com.oracle.truffle.api.debug.DebuggerTags.AlwaysHalt;
import com.oracle.truffle.api.dsl.GeneratedBy;
import com.oracle.truffle.api.dsl.UnsupportedSpecializationException;
import com.oracle.truffle.api.dsl.DSLSupport.SpecializationDataNode;
import com.oracle.truffle.api.dsl.InlineSupport.InlineTarget;
import com.oracle.truffle.api.dsl.InlineSupport.ReferenceField;
import com.oracle.truffle.api.dsl.InlineSupport.StateField;
import com.oracle.truffle.api.dsl.InlineSupport.UnsafeAccessedField;
import com.oracle.truffle.api.exception.AbstractTruffleException;
import com.oracle.truffle.api.frame.Frame;
import com.oracle.truffle.api.frame.FrameDescriptor;
import com.oracle.truffle.api.frame.FrameExtensions;
import com.oracle.truffle.api.frame.FrameInstance;
import com.oracle.truffle.api.frame.FrameSlotKind;
import com.oracle.truffle.api.frame.VirtualFrame;
import com.oracle.truffle.api.frame.FrameInstance.FrameAccess;
import com.oracle.truffle.api.instrumentation.InstrumentableNode;
import com.oracle.truffle.api.instrumentation.ProbeNode;
import com.oracle.truffle.api.instrumentation.Tag;
import com.oracle.truffle.api.instrumentation.StandardTags.CallTag;
import com.oracle.truffle.api.instrumentation.StandardTags.ExpressionTag;
import com.oracle.truffle.api.instrumentation.StandardTags.ReadVariableTag;
import com.oracle.truffle.api.instrumentation.StandardTags.RootBodyTag;
import com.oracle.truffle.api.instrumentation.StandardTags.RootTag;
import com.oracle.truffle.api.instrumentation.StandardTags.StatementTag;
import com.oracle.truffle.api.instrumentation.StandardTags.WriteVariableTag;
import com.oracle.truffle.api.interop.InteropLibrary;
import com.oracle.truffle.api.library.LibraryFactory;
import com.oracle.truffle.api.memory.ByteArraySupport;
import com.oracle.truffle.api.nodes.BytecodeOSRNode;
import com.oracle.truffle.api.nodes.ControlFlowException;
import com.oracle.truffle.api.nodes.DenyReplace;
import com.oracle.truffle.api.nodes.DirectCallNode;
import com.oracle.truffle.api.nodes.EncapsulatingNodeReference;
import com.oracle.truffle.api.nodes.ExplodeLoop;
import com.oracle.truffle.api.nodes.IndirectCallNode;
import com.oracle.truffle.api.nodes.LoopNode;
import com.oracle.truffle.api.nodes.Node;
import com.oracle.truffle.api.nodes.RootNode;
import com.oracle.truffle.api.nodes.UnadoptableNode;
import com.oracle.truffle.api.nodes.UnexpectedResultException;
import com.oracle.truffle.api.nodes.ExplodeLoop.LoopExplosionKind;
import com.oracle.truffle.api.object.DynamicObjectLibrary;
import com.oracle.truffle.api.source.Source;
import com.oracle.truffle.api.source.SourceSection;
import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.ConcatNode;
import com.oracle.truffle.api.strings.TruffleString.EqualNode;
import com.oracle.truffle.api.strings.TruffleString.FromJavaStringNode;
import com.oracle.truffle.sl.SLLanguage;
import com.oracle.truffle.sl.builtins.SLBuiltinNode;
import com.oracle.truffle.sl.nodes.SLTypes;
import com.oracle.truffle.sl.nodes.SLTypesGen;
import com.oracle.truffle.sl.nodes.expression.SLAddNode;
import com.oracle.truffle.sl.nodes.expression.SLDivNode;
import com.oracle.truffle.sl.nodes.expression.SLEqualNode;
import com.oracle.truffle.sl.nodes.expression.SLFunctionLiteralNode;
import com.oracle.truffle.sl.nodes.expression.SLLessOrEqualNode;
import com.oracle.truffle.sl.nodes.expression.SLLessThanNode;
import com.oracle.truffle.sl.nodes.expression.SLLogicalNotNode;
import com.oracle.truffle.sl.nodes.expression.SLMulNode;
import com.oracle.truffle.sl.nodes.expression.SLReadPropertyNode;
import com.oracle.truffle.sl.nodes.expression.SLSubNode;
import com.oracle.truffle.sl.nodes.expression.SLWritePropertyNode;
import com.oracle.truffle.sl.nodes.util.SLToBooleanNode;
import com.oracle.truffle.sl.nodes.util.SLToMemberNode;
import com.oracle.truffle.sl.nodes.util.SLToMemberNodeGen;
import com.oracle.truffle.sl.nodes.util.SLToTruffleStringNode;
import com.oracle.truffle.sl.nodes.util.SLToTruffleStringNodeGen;
import com.oracle.truffle.sl.nodes.util.SLUnboxNode;
import com.oracle.truffle.sl.runtime.SLBigInteger;
import com.oracle.truffle.sl.runtime.SLFunction;
import com.oracle.truffle.sl.runtime.SLNull;
import com.oracle.truffle.sl.runtime.SLObject;
import java.io.ByteArrayOutputStream;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOError;
import java.io.IOException;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.VarHandle;
import java.lang.invoke.MethodHandles.Lookup;
import java.nio.ByteBuffer;
import java.util.AbstractList;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
import java.util.function.Supplier;

/*
 * operations:
 *   - Operation Block
 *     kind: BLOCK
 *   - Operation Root
 *     kind: ROOT
 *   - Operation IfThen
 *     kind: IF_THEN
 *   - Operation IfThenElse
 *     kind: IF_THEN_ELSE
 *   - Operation Conditional
 *     kind: CONDITIONAL
 *   - Operation While
 *     kind: WHILE
 *   - Operation TryCatch
 *     kind: TRY_CATCH
 *   - Operation FinallyTry
 *     kind: FINALLY_TRY
 *   - Operation FinallyTryCatch
 *     kind: FINALLY_TRY_CATCH
 *   - Operation FinallyHandler
 *     kind: FINALLY_HANDLER
 *   - Operation Label
 *     kind: LABEL
 *   - Operation Branch
 *     kind: BRANCH
 *   - Operation LoadConstant
 *     kind: LOAD_CONSTANT
 *   - Operation LoadNull
 *     kind: LOAD_NULL
 *   - Operation LoadArgument
 *     kind: LOAD_ARGUMENT
 *   - Operation LoadException
 *     kind: LOAD_EXCEPTION
 *   - Operation LoadLocal
 *     kind: LOAD_LOCAL
 *   - Operation LoadLocalMaterialized
 *     kind: LOAD_LOCAL_MATERIALIZED
 *   - Operation StoreLocal
 *     kind: STORE_LOCAL
 *   - Operation StoreLocalMaterialized
 *     kind: STORE_LOCAL_MATERIALIZED
 *   - Operation Return
 *     kind: RETURN
 *   - Operation Source
 *     kind: SOURCE
 *   - Operation SourceSection
 *     kind: SOURCE_SECTION
 *   - Operation Tag
 *     kind: TAG
 *   - Operation SLAlwaysHalt
 *     kind: CUSTOM
 *   - Operation SLLoadArgument
 *     kind: CUSTOM
 *   - Operation Builtin
 *     kind: CUSTOM
 *   - Operation SLInvoke
 *     kind: CUSTOM
 *   - Operation SLAdd
 *     kind: CUSTOM
 *   - Operation SLDiv
 *     kind: CUSTOM
 *   - Operation SLEqual
 *     kind: CUSTOM
 *   - Operation SLLessOrEqual
 *     kind: CUSTOM
 *   - Operation SLLessThan
 *     kind: CUSTOM
 *   - Operation SLLogicalNot
 *     kind: CUSTOM
 *   - Operation SLMul
 *     kind: CUSTOM
 *   - Operation SLReadProperty
 *     kind: CUSTOM
 *   - Operation SLSub
 *     kind: CUSTOM
 *   - Operation SLWriteProperty
 *     kind: CUSTOM
 *   - Operation SLUnbox
 *     kind: CUSTOM
 *   - Operation SLFunctionLiteral
 *     kind: CUSTOM
 *   - Operation SLToBoolean
 *     kind: CUSTOM
 *   - Operation SLAnd
 *     kind: CUSTOM_SHORT_CIRCUIT
 *   - Operation SLOr
 *     kind: CUSTOM_SHORT_CIRCUIT
 * instructions:
 *   - Instruction pop
 *     kind: POP
 *     encoding: [1 : short, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction pop$Long
 *     kind: POP
 *     encoding: [2 : short, child0 (bci) : int]
 *     signature: void (long)
 *   - Instruction pop$Boolean
 *     kind: POP
 *     encoding: [3 : short, child0 (bci) : int]
 *     signature: void (boolean)
 *   - Instruction pop$generic
 *     kind: POP
 *     encoding: [4 : short, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction dup
 *     kind: DUP
 *     encoding: [5 : short]
 *     signature: void ()
 *   - Instruction return
 *     kind: RETURN
 *     encoding: [6 : short]
 *     signature: void (Object)
 *   - Instruction branch
 *     kind: BRANCH
 *     encoding: [7 : short, branch_target (bci) : int]
 *     signature: void ()
 *   - Instruction branch.backward
 *     kind: BRANCH_BACKWARD
 *     encoding: [8 : short, branch_target (bci) : int, loop_header_branch_profile (branch_profile) : int]
 *     signature: void ()
 *   - Instruction branch.false
 *     kind: BRANCH_FALSE
 *     encoding: [9 : short, branch_target (bci) : int, branch_profile : int, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction branch.false$Generic
 *     kind: BRANCH_FALSE
 *     encoding: [10 : short, branch_target (bci) : int, branch_profile : int, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction branch.false$Boolean
 *     kind: BRANCH_FALSE
 *     encoding: [11 : short, branch_target (bci) : int, branch_profile : int, child0 (bci) : int]
 *     signature: void (boolean)
 *   - Instruction store.local
 *     kind: STORE_LOCAL
 *     encoding: [12 : short, localOffset : short, localIndex : short, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction store.local$Long
 *     kind: STORE_LOCAL
 *     encoding: [13 : short, localOffset : short, localIndex : short, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction store.local$Long$Long
 *     kind: STORE_LOCAL
 *     encoding: [14 : short, localOffset : short, localIndex : short, child0 (bci) : int]
 *     signature: void (long)
 *   - Instruction store.local$Boolean
 *     kind: STORE_LOCAL
 *     encoding: [15 : short, localOffset : short, localIndex : short, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction store.local$Boolean$Boolean
 *     kind: STORE_LOCAL
 *     encoding: [16 : short, localOffset : short, localIndex : short, child0 (bci) : int]
 *     signature: void (boolean)
 *   - Instruction store.local$generic
 *     kind: STORE_LOCAL
 *     encoding: [17 : short, localOffset : short, localIndex : short, child0 (bci) : int]
 *     signature: void (Object)
 *   - Instruction throw
 *     kind: THROW
 *     encoding: [18 : short]
 *     signature: void (Object)
 *   - Instruction load.constant
 *     kind: LOAD_CONSTANT
 *     encoding: [19 : short, constant (const) : int]
 *     signature: Object ()
 *   - Instruction load.constant$Long
 *     kind: LOAD_CONSTANT
 *     encoding: [20 : short, constant (const) : int]
 *     signature: long ()
 *   - Instruction load.constant$Boolean
 *     kind: LOAD_CONSTANT
 *     encoding: [21 : short, constant (const) : int]
 *     signature: boolean ()
 *   - Instruction load.null
 *     kind: LOAD_NULL
 *     encoding: [22 : short]
 *     signature: Object ()
 *   - Instruction load.argument
 *     kind: LOAD_ARGUMENT
 *     encoding: [23 : short, index (short) : short]
 *     signature: Object ()
 *   - Instruction load.argument$Long
 *     kind: LOAD_ARGUMENT
 *     encoding: [24 : short, index (short) : short]
 *     signature: long ()
 *   - Instruction load.argument$Boolean
 *     kind: LOAD_ARGUMENT
 *     encoding: [25 : short, index (short) : short]
 *     signature: boolean ()
 *   - Instruction load.exception
 *     kind: LOAD_EXCEPTION
 *     encoding: [26 : short, exceptionSp (sp) : short]
 *     signature: Object ()
 *   - Instruction load.local
 *     kind: LOAD_LOCAL
 *     encoding: [27 : short, localOffset : short, localIndex : short]
 *     signature: Object ()
 *   - Instruction load.local$Long
 *     kind: LOAD_LOCAL
 *     encoding: [28 : short, localOffset : short, localIndex : short]
 *     signature: Object ()
 *   - Instruction load.local$Long$unboxed
 *     kind: LOAD_LOCAL
 *     encoding: [29 : short, localOffset : short, localIndex : short]
 *     signature: long ()
 *   - Instruction load.local$Boolean
 *     kind: LOAD_LOCAL
 *     encoding: [30 : short, localOffset : short, localIndex : short]
 *     signature: Object ()
 *   - Instruction load.local$Boolean$unboxed
 *     kind: LOAD_LOCAL
 *     encoding: [31 : short, localOffset : short, localIndex : short]
 *     signature: boolean ()
 *   - Instruction load.local$generic
 *     kind: LOAD_LOCAL
 *     encoding: [32 : short, localOffset : short, localIndex : short]
 *     signature: Object ()
 *   - Instruction load.local.mat
 *     kind: LOAD_LOCAL_MATERIALIZED
 *     encoding: [33 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
 *     signature: Object (Object)
 *   - Instruction load.local.mat$Long
 *     kind: LOAD_LOCAL_MATERIALIZED
 *     encoding: [34 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
 *     signature: Object (Object)
 *   - Instruction load.local.mat$Long$unboxed
 *     kind: LOAD_LOCAL_MATERIALIZED
 *     encoding: [35 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
 *     signature: long (Object)
 *   - Instruction load.local.mat$Boolean
 *     kind: LOAD_LOCAL_MATERIALIZED
 *     encoding: [36 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
 *     signature: Object (Object)
 *   - Instruction load.local.mat$Boolean$unboxed
 *     kind: LOAD_LOCAL_MATERIALIZED
 *     encoding: [37 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
 *     signature: boolean (Object)
 *   - Instruction load.local.mat$generic
 *     kind: LOAD_LOCAL_MATERIALIZED
 *     encoding: [38 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
 *     signature: Object (Object)
 *   - Instruction store.local.mat
 *     kind: STORE_LOCAL_MATERIALIZED
 *     encoding: [39 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
 *     signature: void (Object, Object)
 *   - Instruction store.local.mat$Long
 *     kind: STORE_LOCAL_MATERIALIZED
 *     encoding: [40 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
 *     signature: void (Object, Object)
 *   - Instruction store.local.mat$Long$Long
 *     kind: STORE_LOCAL_MATERIALIZED
 *     encoding: [41 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
 *     signature: void (long, Object)
 *   - Instruction store.local.mat$Boolean
 *     kind: STORE_LOCAL_MATERIALIZED
 *     encoding: [42 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
 *     signature: void (Object, Object)
 *   - Instruction store.local.mat$Boolean$Boolean
 *     kind: STORE_LOCAL_MATERIALIZED
 *     encoding: [43 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
 *     signature: void (boolean, Object)
 *   - Instruction store.local.mat$generic
 *     kind: STORE_LOCAL_MATERIALIZED
 *     encoding: [44 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
 *     signature: void (Object, Object)
 *   - Instruction tag.enter
 *     kind: TAG_ENTER
 *     encoding: [45 : short, tag : int]
 *     signature: void ()
 *   - Instruction tag.leave
 *     kind: TAG_LEAVE
 *     encoding: [46 : short, tag : int, child0 (bci) : int]
 *     signature: Object (Object)
 *   - Instruction tag.leave$Long
 *     kind: TAG_LEAVE
 *     encoding: [47 : short, tag : int, child0 (bci) : int]
 *     signature: Object (long)
 *   - Instruction tag.leave$Long$unboxed
 *     kind: TAG_LEAVE
 *     encoding: [48 : short, tag : int, child0 (bci) : int]
 *     signature: long (Object)
 *   - Instruction tag.leave$Boolean
 *     kind: TAG_LEAVE
 *     encoding: [49 : short, tag : int, child0 (bci) : int]
 *     signature: Object (boolean)
 *   - Instruction tag.leave$Boolean$unboxed
 *     kind: TAG_LEAVE
 *     encoding: [50 : short, tag : int, child0 (bci) : int]
 *     signature: boolean (Object)
 *   - Instruction tag.leave$generic
 *     kind: TAG_LEAVE
 *     encoding: [51 : short, tag : int, child0 (bci) : int]
 *     signature: Object (Object)
 *   - Instruction tag.leaveVoid
 *     kind: TAG_LEAVE_VOID
 *     encoding: [52 : short, tag : int]
 *     signature: Object ()
 *   - Instruction load.variadic_0
 *     kind: LOAD_VARIADIC
 *     encoding: [53 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_1
 *     kind: LOAD_VARIADIC
 *     encoding: [54 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_2
 *     kind: LOAD_VARIADIC
 *     encoding: [55 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_3
 *     kind: LOAD_VARIADIC
 *     encoding: [56 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_4
 *     kind: LOAD_VARIADIC
 *     encoding: [57 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_5
 *     kind: LOAD_VARIADIC
 *     encoding: [58 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_6
 *     kind: LOAD_VARIADIC
 *     encoding: [59 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_7
 *     kind: LOAD_VARIADIC
 *     encoding: [60 : short]
 *     signature: void (Object)
 *   - Instruction load.variadic_8
 *     kind: LOAD_VARIADIC
 *     encoding: [61 : short]
 *     signature: void (Object)
 *   - Instruction merge.variadic
 *     kind: MERGE_VARIADIC
 *     encoding: [62 : short]
 *     signature: Object (Object)
 *   - Instruction constant_null
 *     kind: STORE_NULL
 *     encoding: [63 : short]
 *     signature: Object ()
 *   - Instruction clear.local
 *     kind: CLEAR_LOCAL
 *     encoding: [64 : short, localOffset : short]
 *     signature: void ()
 *   - Instruction c.SLAlwaysHalt
 *     kind: CUSTOM
 *     encoding: [65 : short, node : int]
 *     nodeType: SLAlwaysHalt
 *     signature: void ()
 *   - Instruction c.SLLoadArgument
 *     kind: CUSTOM
 *     encoding: [66 : short, index (const) : int, node : int]
 *     nodeType: SLLoadArgument
 *     signature: Object (int)
 *   - Instruction c.SLLoadArgument$LoadInBounds
 *     kind: CUSTOM
 *     encoding: [67 : short, index (const) : int, node : int]
 *     nodeType: SLLoadArgument
 *     signature: Object (int)
 *   - Instruction c.Builtin
 *     kind: CUSTOM
 *     encoding: [68 : short, builtin (const) : int, argumentCount (const) : int, node : int]
 *     nodeType: Builtin
 *     signature: Object (SLBuiltinNode, int)
 *   - Instruction c.SLInvoke
 *     kind: CUSTOM
 *     encoding: [69 : short, node : int]
 *     nodeType: SLInvoke
 *     signature: Object (Object, Object[]...)
 *   - Instruction c.SLAdd
 *     kind: CUSTOM
 *     encoding: [70 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLAddNode
 *     signature: Object (Object, Object)
 *   - Instruction c.SLAdd$Long
 *     kind: CUSTOM
 *     encoding: [71 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLAddNode
 *     signature: long (long, long)
 *   - Instruction c.SLAdd$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [72 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLAddNode
 *     signature: long (long, long)
 *   - Instruction c.SLDiv
 *     kind: CUSTOM
 *     encoding: [73 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLDivNode
 *     signature: Object (Object, Object)
 *   - Instruction c.SLDiv$Long
 *     kind: CUSTOM
 *     encoding: [74 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLDivNode
 *     signature: long (long, long)
 *   - Instruction c.SLDiv$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [75 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLDivNode
 *     signature: long (long, long)
 *   - Instruction c.SLEqual
 *     kind: CUSTOM
 *     encoding: [76 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLEqualNode
 *     signature: boolean (Object, Object)
 *   - Instruction c.SLEqual$Long
 *     kind: CUSTOM
 *     encoding: [77 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLEqualNode
 *     signature: boolean (long, long)
 *   - Instruction c.SLEqual$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [78 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLEqualNode
 *     signature: boolean (long, long)
 *   - Instruction c.SLEqual$Boolean
 *     kind: CUSTOM
 *     encoding: [79 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLEqualNode
 *     signature: boolean (boolean, boolean)
 *   - Instruction c.SLEqual$Boolean$unboxed
 *     kind: CUSTOM
 *     encoding: [80 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLEqualNode
 *     signature: boolean (boolean, boolean)
 *   - Instruction c.SLEqual$unboxed
 *     kind: CUSTOM
 *     encoding: [81 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLEqualNode
 *     signature: boolean (Object, Object)
 *   - Instruction c.SLLessOrEqual
 *     kind: CUSTOM
 *     encoding: [82 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessOrEqualNode
 *     signature: Object (Object, Object)
 *   - Instruction c.SLLessOrEqual$Long
 *     kind: CUSTOM
 *     encoding: [83 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessOrEqualNode
 *     signature: boolean (long, long)
 *   - Instruction c.SLLessOrEqual$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [84 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessOrEqualNode
 *     signature: boolean (long, long)
 *   - Instruction c.SLLessOrEqual$SLBigInteger#InteropBigInteger0#InteropBigInteger1
 *     kind: CUSTOM
 *     encoding: [85 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessOrEqualNode
 *     signature: boolean (Object, Object)
 *   - Instruction c.SLLessOrEqual$SLBigInteger#InteropBigInteger0#InteropBigInteger1$unboxed
 *     kind: CUSTOM
 *     encoding: [86 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessOrEqualNode
 *     signature: boolean (Object, Object)
 *   - Instruction c.SLLessThan
 *     kind: CUSTOM
 *     encoding: [87 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessThanNode
 *     signature: boolean (Object, Object)
 *   - Instruction c.SLLessThan$Long
 *     kind: CUSTOM
 *     encoding: [88 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessThanNode
 *     signature: boolean (long, long)
 *   - Instruction c.SLLessThan$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [89 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessThanNode
 *     signature: boolean (long, long)
 *   - Instruction c.SLLessThan$unboxed
 *     kind: CUSTOM
 *     encoding: [90 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLLessThanNode
 *     signature: boolean (Object, Object)
 *   - Instruction c.SLLogicalNot
 *     kind: CUSTOM
 *     encoding: [91 : short, node : int, child0 (bci) : int]
 *     nodeType: SLLogicalNotNode
 *     signature: boolean (Object)
 *   - Instruction c.SLLogicalNot$Boolean
 *     kind: CUSTOM
 *     encoding: [92 : short, node : int, child0 (bci) : int]
 *     nodeType: SLLogicalNotNode
 *     signature: boolean (boolean)
 *   - Instruction c.SLLogicalNot$Boolean$unboxed
 *     kind: CUSTOM
 *     encoding: [93 : short, node : int, child0 (bci) : int]
 *     nodeType: SLLogicalNotNode
 *     signature: boolean (boolean)
 *   - Instruction c.SLLogicalNot$unboxed
 *     kind: CUSTOM
 *     encoding: [94 : short, node : int, child0 (bci) : int]
 *     nodeType: SLLogicalNotNode
 *     signature: boolean (Object)
 *   - Instruction c.SLMul
 *     kind: CUSTOM
 *     encoding: [95 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLMulNode
 *     signature: Object (Object, Object)
 *   - Instruction c.SLMul$Long
 *     kind: CUSTOM
 *     encoding: [96 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLMulNode
 *     signature: long (long, long)
 *   - Instruction c.SLMul$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [97 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLMulNode
 *     signature: long (long, long)
 *   - Instruction c.SLReadProperty
 *     kind: CUSTOM
 *     encoding: [98 : short, node : int]
 *     nodeType: SLReadPropertyNode
 *     signature: Object (Object, Object)
 *   - Instruction c.SLSub
 *     kind: CUSTOM
 *     encoding: [99 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLSubNode
 *     signature: Object (Object, Object)
 *   - Instruction c.SLSub$Long
 *     kind: CUSTOM
 *     encoding: [100 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLSubNode
 *     signature: long (long, long)
 *   - Instruction c.SLSub$Long$unboxed
 *     kind: CUSTOM
 *     encoding: [101 : short, node : int, child0 (bci) : int, child1 (bci) : int]
 *     nodeType: SLSubNode
 *     signature: long (long, long)
 *   - Instruction c.SLWriteProperty
 *     kind: CUSTOM
 *     encoding: [102 : short, node : int]
 *     nodeType: SLWritePropertyNode
 *     signature: Object (Object, Object, Object)
 *   - Instruction c.SLUnbox
 *     kind: CUSTOM
 *     encoding: [103 : short, node : int, child0 (bci) : int]
 *     nodeType: SLUnboxNode
 *     signature: Object (Object)
 *   - Instruction c.SLUnbox$FromBoolean
 *     kind: CUSTOM
 *     encoding: [104 : short, node : int, child0 (bci) : int]
 *     nodeType: SLUnboxNode
 *     signature: boolean (boolean)
 *   - Instruction c.SLUnbox$FromBoolean$unboxed
 *     kind: CUSTOM
 *     encoding: [105 : short, node : int, child0 (bci) : int]
 *     nodeType: SLUnboxNode
 *     signature: boolean (boolean)
 *   - Instruction c.SLUnbox$FromLong
 *     kind: CUSTOM
 *     encoding: [106 : short, node : int, child0 (bci) : int]
 *     nodeType: SLUnboxNode
 *     signature: long (long)
 *   - Instruction c.SLUnbox$FromLong$unboxed
 *     kind: CUSTOM
 *     encoding: [107 : short, node : int, child0 (bci) : int]
 *     nodeType: SLUnboxNode
 *     signature: long (long)
 *   - Instruction c.SLFunctionLiteral
 *     kind: CUSTOM
 *     encoding: [108 : short, node : int]
 *     nodeType: SLFunctionLiteralNode
 *     signature: SLFunction (TruffleString)
 *   - Instruction c.SLToBoolean
 *     kind: CUSTOM
 *     encoding: [109 : short, node : int, child0 (bci) : int]
 *     nodeType: SLToBooleanNode
 *     signature: boolean (Object)
 *   - Instruction c.SLToBoolean$Boolean
 *     kind: CUSTOM
 *     encoding: [110 : short, node : int, child0 (bci) : int]
 *     nodeType: SLToBooleanNode
 *     signature: boolean (boolean)
 *   - Instruction c.SLToBoolean$Boolean$unboxed
 *     kind: CUSTOM
 *     encoding: [111 : short, node : int, child0 (bci) : int]
 *     nodeType: SLToBooleanNode
 *     signature: boolean (boolean)
 *   - Instruction c.SLToBoolean$unboxed
 *     kind: CUSTOM
 *     encoding: [112 : short, node : int, child0 (bci) : int]
 *     nodeType: SLToBooleanNode
 *     signature: boolean (Object)
 *   - Instruction sc.SLAnd
 *     kind: CUSTOM_SHORT_CIRCUIT
 *     encoding: [113 : short, branch_target (bci) : int, branch_profile : int]
 *     signature: Object (boolean, boolean)
 *   - Instruction sc.SLOr
 *     kind: CUSTOM_SHORT_CIRCUIT
 *     encoding: [114 : short, branch_target (bci) : int, branch_profile : int]
 *     signature: Object (boolean, boolean)
 *   - Instruction merge.conditional
 *     kind: MERGE_CONDITIONAL
 *     encoding: [115 : short, child0 (bci) : int, child1 (bci) : int]
 *     signature: Object (boolean, Object)
 *   - Instruction merge.conditional$Long
 *     kind: MERGE_CONDITIONAL
 *     encoding: [116 : short, child0 (bci) : int, child1 (bci) : int]
 *     signature: Object (boolean, long)
 *   - Instruction merge.conditional$Long$unboxed
 *     kind: MERGE_CONDITIONAL
 *     encoding: [117 : short, child0 (bci) : int, child1 (bci) : int]
 *     signature: long (boolean, long)
 *   - Instruction merge.conditional$Boolean
 *     kind: MERGE_CONDITIONAL
 *     encoding: [118 : short, child0 (bci) : int, child1 (bci) : int]
 *     signature: Object (boolean, boolean)
 *   - Instruction merge.conditional$Boolean$unboxed
 *     kind: MERGE_CONDITIONAL
 *     encoding: [119 : short, child0 (bci) : int, child1 (bci) : int]
 *     signature: boolean (boolean, boolean)
 *   - Instruction merge.conditional$generic
 *     kind: MERGE_CONDITIONAL
 *     encoding: [120 : short, child0 (bci) : int, child1 (bci) : int]
 *     signature: Object (boolean, Object)
 *   - Instruction invalidate0
 *     kind: INVALIDATE
 *     encoding: [121 : short]
 *     signature: void ()
 *   - Instruction invalidate1
 *     kind: INVALIDATE
 *     encoding: [122 : short, invalidated0 (short) : short]
 *     signature: void ()
 *   - Instruction invalidate2
 *     kind: INVALIDATE
 *     encoding: [123 : short, invalidated0 (short) : short, invalidated1 (short) : short]
 *     signature: void ()
 *   - Instruction invalidate3
 *     kind: INVALIDATE
 *     encoding: [124 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short]
 *     signature: void ()
 *   - Instruction invalidate4
 *     kind: INVALIDATE
 *     encoding: [125 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short, invalidated3 (short) : short]
 *     signature: void ()
 *   - Instruction invalidate5
 *     kind: INVALIDATE
 *     encoding: [126 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short, invalidated3 (short) : short, invalidated4 (short) : short]
 *     signature: void ()
 *   - Instruction invalidate6
 *     kind: INVALIDATE
 *     encoding: [127 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short, invalidated3 (short) : short, invalidated4 (short) : short, invalidated5 (short) : short]
 *     signature: void ()
 */
@SuppressWarnings({"javadoc", "unused", "deprecation", "static-method"})
public final class SLBytecodeRootNodeGen extends SLBytecodeRootNode {

    private static final int[] EMPTY_INT_ARRAY = new int[0];
    private static final Object[] EMPTY_ARRAY = new Object[0];
    private static final BytecodeDSLAccess ACCESS = BytecodeDSLAccess.lookup(BytecodeRootNodesImpl.VISIBLE_TOKEN, true);
    private static final ByteArraySupport BYTES = ACCESS.getByteArraySupport();
    private static final FrameExtensions FRAMES = ACCESS.getFrameExtensions();
    private static final int BCI_INDEX = 0;
    private static final int USER_LOCALS_START_INDEX = 1;
    private static final int TAG_LONG = 1 /* FrameSlotKind.Long.tag */;
    private static final int TAG_BOOLEAN = 5 /* FrameSlotKind.Boolean.tag */;
    private static final AtomicReferenceFieldUpdater<SLBytecodeRootNodeGen, AbstractBytecodeNode> BYTECODE_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SLBytecodeRootNodeGen.class, AbstractBytecodeNode.class, "bytecode");
    private static final int EXCEPTION_HANDLER_OFFSET_START_BCI = 0;
    private static final int EXCEPTION_HANDLER_OFFSET_END_BCI = 1;
    private static final int EXCEPTION_HANDLER_OFFSET_KIND = 2;
    private static final int EXCEPTION_HANDLER_OFFSET_HANDLER_BCI = 3;
    private static final int EXCEPTION_HANDLER_OFFSET_HANDLER_SP = 4;
    private static final int EXCEPTION_HANDLER_LENGTH = 5;
    private static final int SOURCE_INFO_OFFSET_START_BCI = 0;
    private static final int SOURCE_INFO_OFFSET_END_BCI = 1;
    private static final int SOURCE_INFO_OFFSET_SOURCE = 2;
    private static final int SOURCE_INFO_OFFSET_START = 3;
    private static final int SOURCE_INFO_OFFSET_LENGTH = 4;
    private static final int SOURCE_INFO_LENGTH = 5;
    private static final int LOCALS_OFFSET_START_BCI = 0;
    private static final int LOCALS_OFFSET_END_BCI = 1;
    private static final int LOCALS_OFFSET_LOCAL_INDEX = 2;
    private static final int LOCALS_OFFSET_FRAME_INDEX = 3;
    private static final int LOCALS_OFFSET_NAME = 4;
    private static final int LOCALS_OFFSET_INFO = 5;
    private static final int LOCALS_LENGTH = 6;
    private static final int HANDLER_CUSTOM = 0;
    private static final int HANDLER_TAG_EXCEPTIONAL = 1;
    private static final ConcurrentHashMap<Integer, Class<? extends Tag>[]> TAG_MASK_TO_TAGS = new ConcurrentHashMap<>();
    private static final ClassValue<Integer> CLASS_TO_TAG_MASK = SLBytecodeRootNodeGen.initializeTagMaskToClass();
    private static final LibraryFactory<InteropLibrary> INTEROP_LIBRARY_ = LibraryFactory.resolve(InteropLibrary.class);
    private static final LibraryFactory<DynamicObjectLibrary> DYNAMIC_OBJECT_LIBRARY_ = LibraryFactory.resolve(DynamicObjectLibrary.class);

    @Child private volatile AbstractBytecodeNode bytecode;
    private final BytecodeRootNodesImpl nodes;
    /**
     * The number of frame slots required for locals.
     */
    private final int maxLocals;
    /**
     * The total number of locals created.
     */
    private final int numLocals;
    private final int buildIndex;
    private CloneReferenceList<SLBytecodeRootNodeGen> clones;

    private SLBytecodeRootNodeGen(SLLanguage language, com.oracle.truffle.api.frame.FrameDescriptor.Builder builder, BytecodeRootNodesImpl nodes, int maxLocals, int numLocals, int buildIndex, byte[] bytecodes, Object[] constants, int[] handlers, int[] locals, int[] sourceInfo, List<Source> sources, int numNodes, TagRootNode tagRoot) {
        super(language, builder.build());
        this.nodes = nodes;
        this.maxLocals = maxLocals;
        this.numLocals = numLocals;
        this.buildIndex = buildIndex;
        this.bytecode = insert(new UncachedBytecodeNode(bytecodes, constants, handlers, locals, sourceInfo, sources, numNodes, tagRoot));
    }

    @Override
    public Object execute(VirtualFrame frame) {
        return continueAt(bytecode, 0, maxLocals, frame);
    }

    @SuppressWarnings("all")
    private Object continueAt(AbstractBytecodeNode bc, int bci, int sp, VirtualFrame frame) {
        long state = (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
        while (true) {
            state = bc.continueAt(this, frame, state);
            if ((int) (state & 0xFFFFFFFFL) == 0xFFFFFFFF) {
                break;
            } else {
                // Bytecode or tier changed
                CompilerDirectives.transferToInterpreterAndInvalidate();
                AbstractBytecodeNode oldBytecode = bc;
                bc = this.bytecode;
                state = oldBytecode.transitionState(bc, state);
            }
        }
        return FRAMES.uncheckedGetObject(frame, (int) (state >>> 32));
    }

    private void transitionToCached(Frame frame, int bci) {
        CompilerDirectives.transferToInterpreterAndInvalidate();
        AbstractBytecodeNode oldBytecode;
        AbstractBytecodeNode newBytecode;
        do {
            oldBytecode = this.bytecode;
            newBytecode = insert(oldBytecode.toCached(this.numLocals));
            if (bci > 0) {
                // initialize local tags
                int localCount = newBytecode.getLocalCount(bci);
                for (int localOffset = 0; localOffset < localCount; localOffset++) {
                    newBytecode.setLocalValue(bci, frame, localOffset, newBytecode.getLocalValue(bci, frame, localOffset));
                }
            }
            VarHandle.storeStoreFence();
            if (oldBytecode == newBytecode) {
                return;
            }
        } while (!BYTECODE_UPDATER.compareAndSet(this, oldBytecode, newBytecode));
    }

    private AbstractBytecodeNode updateBytecode(byte[] bytecodes_, Object[] constants_, int[] handlers_, int[] locals_, int[] sourceInfo_, List<Source> sources_, int numNodes_, TagRootNode tagRoot_, CharSequence reason) {
        CompilerAsserts.neverPartOfCompilation();
        AbstractBytecodeNode oldBytecode;
        AbstractBytecodeNode newBytecode;
        do {
            oldBytecode = this.bytecode;
            newBytecode = insert(oldBytecode.update(bytecodes_, constants_, handlers_, locals_, sourceInfo_, sources_, numNodes_, tagRoot_));
            if (bytecodes_ == null) {
                // When bytecode doesn't change, nodes are reused and should be re-adopted.
                newBytecode.adoptNodesAfterUpdate();
            }
            VarHandle.storeStoreFence();
        } while (!BYTECODE_UPDATER.compareAndSet(this, oldBytecode, newBytecode));

        if (bytecodes_ != null) {
            oldBytecode.invalidate(newBytecode, reason);
        }
        assert Thread.holdsLock(this.nodes);
        var cloneReferences = this.clones;
        if (cloneReferences != null) {
            cloneReferences.forEach((clone) -> {
                AbstractBytecodeNode cloneOldBytecode;
                AbstractBytecodeNode cloneNewBytecode;
                do {
                    cloneOldBytecode = clone.bytecode;
                    cloneNewBytecode = clone.insert(this.bytecode.cloneUninitialized());
                    if (bytecodes_ == null) {
                        // When bytecode doesn't change, nodes are reused and should be re-adopted.
                        cloneNewBytecode.adoptNodesAfterUpdate();
                    }
                    VarHandle.storeStoreFence();
                } while (!BYTECODE_UPDATER.compareAndSet(clone, cloneOldBytecode, cloneNewBytecode));

                if (bytecodes_ != null) {
                    cloneOldBytecode.invalidate(cloneNewBytecode, reason);
                }
            }
            );
        }
        return newBytecode;
    }

    @Override
    protected boolean isInstrumentable() {
        return true;
    }

    @Override
    @SuppressWarnings("unchecked")
    protected void prepareForInstrumentation(Set<Class<?>> materializedTags) {
        com.oracle.truffle.api.bytecode.BytecodeConfig.Builder b = newConfigBuilder();
        // Sources are always needed for instrumentation.
        b.addSource();
        for (Class<?> tag : materializedTags) {
            b.addTag((Class<? extends Tag>) tag);
        }
        getRootNodes().update(b.build());
    }

    @Override
    protected Node findInstrumentableCallNode(Node callNode, Frame frame, int bytecodeIndex) {
        BytecodeNode bc = BytecodeNode.get(callNode);
        if (bc == null || !(bc instanceof AbstractBytecodeNode bytecodeNode)) {
            return super.findInstrumentableCallNode(callNode, frame, bytecodeIndex);
        }
        return bytecodeNode.findInstrumentableCallNode(bytecodeIndex);
    }

    @Override
    protected boolean isCloneUninitializedSupported() {
        return true;
    }

    @Override
    protected RootNode cloneUninitialized() {
        SLBytecodeRootNodeGen clone;
        synchronized(nodes){
            clone = (SLBytecodeRootNodeGen) this.copy();
            clone.clones = null;
            clone.bytecode = insert(this.bytecode.cloneUninitialized());
            CloneReferenceList<SLBytecodeRootNodeGen> localClones = this.clones;
            if (localClones == null) {
                this.clones = localClones = new CloneReferenceList<SLBytecodeRootNodeGen>();
            }
            localClones.add(clone);
        }
        VarHandle.storeStoreFence();
        return clone;
    }

    @Override
    @SuppressWarnings("hiding")
    protected int findBytecodeIndex(Node node, Frame frame) {
        AbstractBytecodeNode bytecode = null;
        Node prev = node;
        Node current = node;
        while (current != null) {
            if (current  instanceof AbstractBytecodeNode b) {
                bytecode = b;
                break;
            }
            prev = current;
            current = prev.getParent();
        }
        if (bytecode == null) {
            return -1;
        }
        return bytecode.findBytecodeIndex(frame, prev);
    }

    @Override
    protected boolean isCaptureFramesForTrace(boolean compiled) {
        return !compiled;
    }

    @Override
    public BytecodeNode getBytecodeNode() {
        return bytecode;
    }

    private AbstractBytecodeNode getBytecodeNodeImpl() {
        return bytecode;
    }

    private SLBytecodeRootNodeGen getBytecodeRootNodeImpl(int index) {
        return (SLBytecodeRootNodeGen) this.nodes.getNode(index);
    }

    @Override
    public BytecodeRootNodes<SLBytecodeRootNode> getRootNodes() {
        return this.nodes;
    }

    @Override
    protected boolean countsTowardsStackTraceLimit() {
        return true;
    }

    @Override
    public SourceSection getSourceSection() {
        return bytecode.getSourceSection();
    }

    @Override
    protected Object translateStackTraceElement(TruffleStackTraceElement stackTraceElement) {
        return AbstractBytecodeNode.createStackTraceElement(stackTraceElement);
    }

    private static long expectLong(Object value) throws UnexpectedResultException {
        if (value instanceof Long) {
            return (long) value;
        }
        CompilerDirectives.transferToInterpreterAndInvalidate();
        throw new UnexpectedResultException(value);
    }

    private static boolean expectBoolean(Object value) throws UnexpectedResultException {
        if (value instanceof Boolean) {
            return (boolean) value;
        }
        CompilerDirectives.transferToInterpreterAndInvalidate();
        throw new UnexpectedResultException(value);
    }

    public static com.oracle.truffle.api.bytecode.BytecodeConfig.Builder newConfigBuilder() {
        return BytecodeConfig.newBuilder(BytecodeConfigEncoderImpl.INSTANCE);
    }

    private static int encodeTags(Class<?>... tags) {
        if (tags == null) {
            return 0;
        }
        int tagMask = 0;
        for (Class<?> tag : tags) {
            tagMask |= CLASS_TO_TAG_MASK.get(tag);
        }
        return tagMask;
    }

    /**
     * Creates one or more bytecode nodes. This is the entrypoint for creating new {@link SLBytecodeRootNodeGen} instances.
     *
     * @param language the Truffle language instance.
     * @param config indicates whether to parse metadata (e.g., source information).
     * @param parser the parser that invokes a series of builder instructions to generate bytecode.
     */
    public static BytecodeRootNodes<SLBytecodeRootNode> create(SLLanguage language, BytecodeConfig config, BytecodeParser<com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder> parser) {
        BytecodeRootNodesImpl nodes = new BytecodeRootNodesImpl(parser, config);
        Builder builder = new Builder(language, nodes, config);
        parser.parse(builder);
        builder.finish();
        return nodes;
    }

    /**
     * Serializes the bytecode nodes parsed by the {@code parser}.
     * All metadata (e.g., source info) is serialized (even if it has not yet been parsed).
     * <p>
     * Unlike {@link BytecodeRootNodes#serialize}, this method does not use already-constructed root nodes,
     * so it cannot serialize field values that get set outside of the parser.
     *
     * @param buffer the buffer to write the byte output to.
     * @param callback the language-specific serializer for constants in the bytecode.
     * @param parser the parser.
     */
    @TruffleBoundary
    public static void serialize(DataOutput buffer, BytecodeSerializer callback, BytecodeParser<com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder> parser) throws IOException {
        Builder builder = new Builder(null, new BytecodeRootNodesImpl(parser, BytecodeConfig.COMPLETE), BytecodeConfig.COMPLETE);
        doSerialize(buffer, callback, builder, null);
    }

    @TruffleBoundary
    private static void doSerialize(DataOutput buffer, BytecodeSerializer callback, com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder builder, List<SLBytecodeRootNode> existingNodes) throws IOException {
        try {
            builder.serialize(buffer, callback, existingNodes);
        } catch (IOError e) {
            throw (IOException) e.getCause();
        }
    }

    /**
     * Deserializes a byte sequence to bytecode nodes. The bytes must have been produced by a previous call to {@link #serialize}.").newLine()
     *
     * @param language the language instance.
     * @param config indicates whether to deserialize metadata (e.g., source information).
     * @param input A function that supplies the bytes to deserialize. This supplier must produce a new {@link DataInput} each time, since the bytes may be processed multiple times for reparsing.
     * @param callback The language-specific deserializer for constants in the bytecode. This callback must perform the inverse of the callback that was used to {@link #serialize} the nodes to bytes.
     */
    @TruffleBoundary
    public static BytecodeRootNodes<SLBytecodeRootNode> deserialize(SLLanguage language, BytecodeConfig config, Supplier<DataInput> input, BytecodeDeserializer callback) throws IOException {
        try {
            return create(language, config, (b) -> b.deserialize(input, callback, null));
        } catch (IOError e) {
            throw (IOException) e.getCause();
        }
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    private static Class<? extends Tag>[] mapTagMaskToTagsArray(int tagMask) {
        ArrayList<Class<? extends Tag>> tags = new ArrayList<>();
        if ((tagMask & 1) != 0) {
            tags.add(CallTag.class);
        }
        if ((tagMask & 2) != 0) {
            tags.add(StatementTag.class);
        }
        if ((tagMask & 4) != 0) {
            tags.add(RootTag.class);
        }
        if ((tagMask & 8) != 0) {
            tags.add(RootBodyTag.class);
        }
        if ((tagMask & 16) != 0) {
            tags.add(ExpressionTag.class);
        }
        if ((tagMask & 32) != 0) {
            tags.add(AlwaysHalt.class);
        }
        if ((tagMask & 64) != 0) {
            tags.add(ReadVariableTag.class);
        }
        if ((tagMask & 128) != 0) {
            tags.add(WriteVariableTag.class);
        }
        return tags.toArray(new Class[tags.size()]);
    }

    private static ClassValue<Integer> initializeTagMaskToClass() {
        return new ClassValue<>(){
            protected Integer computeValue(Class<?> type) {
                if (type == CallTag.class) {
                    return 1;
                } else if (type == StatementTag.class) {
                    return 2;
                } else if (type == RootTag.class) {
                    return 4;
                } else if (type == RootBodyTag.class) {
                    return 8;
                } else if (type == ExpressionTag.class) {
                    return 16;
                } else if (type == AlwaysHalt.class) {
                    return 32;
                } else if (type == ReadVariableTag.class) {
                    return 64;
                } else if (type == WriteVariableTag.class) {
                    return 128;
                }
                throw new IllegalArgumentException(String.format("Invalid tag specified. Tag '%s' not provided by language 'com.oracle.truffle.sl.SLLanguage'.", type.getName()));
            }
        }
        ;
    }

    @SuppressWarnings("unchecked")
    private static <E extends Throwable> RuntimeException sneakyThrow(Throwable e) throws E {
        throw (E) e;
    }

    @TruffleBoundary
    private static AssertionError assertionFailed(String message) {
        throw new AssertionError(message);
    }

    @ExplodeLoop
    private static Object[] readVariadic(VirtualFrame frame, int sp, int variadicCount) {
        Object[] result = new Object[variadicCount];
        for (int i = 0; i < variadicCount; i++) {
            int index = sp - variadicCount + i;
            result[i] = FRAMES.uncheckedGetObject(frame, index);
            FRAMES.clear(frame, index);
        }
        return result;
    }

    private static Object[] mergeVariadic(Object[] array) {
        Object[] current = array;
        int length = 0;
        do {
            int currentLength = current.length - 1;
            length += currentLength;
            current = (Object[]) current[currentLength];
        } while (current != null);
        Object[] newArray = new Object[length];
        current = array;
        int index = 0;
        do {
            int currentLength = current.length - 1;
            System.arraycopy(current, 0, newArray, index, currentLength);
            index += currentLength;
            current = (Object[]) current[currentLength];
        } while (current != null);
        return newArray;
    }

    private static short applyQuickeningLong(short $operand) {
        switch ($operand) {
            case Instructions.LOAD_CONSTANT :
            case Instructions.LOAD_CONSTANT$LONG :
                return Instructions.LOAD_CONSTANT$LONG;
            case Instructions.LOAD_ARGUMENT :
            case Instructions.LOAD_ARGUMENT$LONG :
                return Instructions.LOAD_ARGUMENT$LONG;
            case Instructions.LOAD_LOCAL$LONG :
            case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                return Instructions.LOAD_LOCAL$LONG$UNBOXED;
            case Instructions.LOAD_LOCAL_MAT$LONG :
            case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                return Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED;
            case Instructions.TAG_LEAVE$LONG :
            case Instructions.TAG_LEAVE$LONG$UNBOXED :
                return Instructions.TAG_LEAVE$LONG$UNBOXED;
            case Instructions.SL_ADD$LONG_ :
            case Instructions.SL_ADD$LONG$UNBOXED_ :
                return Instructions.SL_ADD$LONG$UNBOXED_;
            case Instructions.SL_DIV$LONG_ :
            case Instructions.SL_DIV$LONG$UNBOXED_ :
                return Instructions.SL_DIV$LONG$UNBOXED_;
            case Instructions.SL_MUL$LONG_ :
            case Instructions.SL_MUL$LONG$UNBOXED_ :
                return Instructions.SL_MUL$LONG$UNBOXED_;
            case Instructions.SL_SUB$LONG_ :
            case Instructions.SL_SUB$LONG$UNBOXED_ :
                return Instructions.SL_SUB$LONG$UNBOXED_;
            case Instructions.SL_UNBOX$FROM_LONG_ :
            case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                return Instructions.SL_UNBOX$FROM_LONG$UNBOXED_;
            case Instructions.MERGE_CONDITIONAL$LONG :
            case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                return Instructions.MERGE_CONDITIONAL$LONG$UNBOXED;
            default :
                return -1;
        }
    }

    private static boolean isQuickeningLong(short operand) {
        switch (operand) {
            case Instructions.LOAD_CONSTANT$LONG :
            case Instructions.LOAD_ARGUMENT$LONG :
            case Instructions.LOAD_LOCAL$LONG$UNBOXED :
            case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
            case Instructions.TAG_LEAVE$LONG$UNBOXED :
            case Instructions.SL_ADD$LONG$UNBOXED_ :
            case Instructions.SL_DIV$LONG$UNBOXED_ :
            case Instructions.SL_MUL$LONG$UNBOXED_ :
            case Instructions.SL_SUB$LONG$UNBOXED_ :
            case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
            case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                return true;
            default :
                return false;
        }
    }

    private static short applyQuickeningBoolean(short $operand) {
        switch ($operand) {
            case Instructions.LOAD_CONSTANT :
            case Instructions.LOAD_CONSTANT$BOOLEAN :
                return Instructions.LOAD_CONSTANT$BOOLEAN;
            case Instructions.LOAD_ARGUMENT :
            case Instructions.LOAD_ARGUMENT$BOOLEAN :
                return Instructions.LOAD_ARGUMENT$BOOLEAN;
            case Instructions.LOAD_LOCAL$BOOLEAN :
            case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                return Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED;
            case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
            case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                return Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED;
            case Instructions.TAG_LEAVE$BOOLEAN :
            case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                return Instructions.TAG_LEAVE$BOOLEAN$UNBOXED;
            case Instructions.SL_EQUAL$LONG_ :
            case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                return Instructions.SL_EQUAL$LONG$UNBOXED_;
            case Instructions.SL_EQUAL$BOOLEAN_ :
            case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                return Instructions.SL_EQUAL$BOOLEAN$UNBOXED_;
            case Instructions.SL_EQUAL_ :
            case Instructions.SL_EQUAL$UNBOXED_ :
                return Instructions.SL_EQUAL$UNBOXED_;
            case Instructions.SL_LESS_OR_EQUAL$LONG_ :
            case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                return Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_;
            case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
            case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                return Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_;
            case Instructions.SL_LESS_THAN$LONG_ :
            case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                return Instructions.SL_LESS_THAN$LONG$UNBOXED_;
            case Instructions.SL_LESS_THAN_ :
            case Instructions.SL_LESS_THAN$UNBOXED_ :
                return Instructions.SL_LESS_THAN$UNBOXED_;
            case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
            case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                return Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_;
            case Instructions.SL_LOGICAL_NOT_ :
            case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                return Instructions.SL_LOGICAL_NOT$UNBOXED_;
            case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
            case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                return Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_;
            case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
            case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                return Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_;
            case Instructions.SL_TO_BOOLEAN_ :
            case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                return Instructions.SL_TO_BOOLEAN$UNBOXED_;
            case Instructions.MERGE_CONDITIONAL$BOOLEAN :
            case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                return Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED;
            default :
                return -1;
        }
    }

    private static boolean isQuickeningBoolean(short operand) {
        switch (operand) {
            case Instructions.LOAD_CONSTANT$BOOLEAN :
            case Instructions.LOAD_ARGUMENT$BOOLEAN :
            case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
            case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
            case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
            case Instructions.SL_EQUAL$LONG$UNBOXED_ :
            case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
            case Instructions.SL_EQUAL$UNBOXED_ :
            case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
            case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
            case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
            case Instructions.SL_LESS_THAN$UNBOXED_ :
            case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
            case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
            case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
            case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
            case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
            case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                return true;
            default :
                return false;
        }
    }

    private static short undoQuickening(short $operand) {
        switch ($operand) {
            case Instructions.BRANCH_FALSE$BOOLEAN :
                return Instructions.BRANCH_FALSE;
            case Instructions.LOAD_CONSTANT$LONG :
                return Instructions.LOAD_CONSTANT;
            case Instructions.LOAD_CONSTANT$BOOLEAN :
                return Instructions.LOAD_CONSTANT;
            case Instructions.LOAD_ARGUMENT$LONG :
                return Instructions.LOAD_ARGUMENT;
            case Instructions.LOAD_ARGUMENT$BOOLEAN :
                return Instructions.LOAD_ARGUMENT;
            case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                return Instructions.LOAD_LOCAL$LONG;
            case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                return Instructions.LOAD_LOCAL$BOOLEAN;
            case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                return Instructions.LOAD_LOCAL_MAT$LONG;
            case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                return Instructions.LOAD_LOCAL_MAT$BOOLEAN;
            case Instructions.TAG_LEAVE$LONG$UNBOXED :
                return Instructions.TAG_LEAVE$LONG;
            case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                return Instructions.TAG_LEAVE$BOOLEAN;
            case Instructions.SL_ADD$LONG$UNBOXED_ :
                return Instructions.SL_ADD$LONG_;
            case Instructions.SL_DIV$LONG$UNBOXED_ :
                return Instructions.SL_DIV$LONG_;
            case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                return Instructions.SL_EQUAL$LONG_;
            case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                return Instructions.SL_EQUAL$BOOLEAN_;
            case Instructions.SL_EQUAL$UNBOXED_ :
                return Instructions.SL_EQUAL_;
            case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                return Instructions.SL_LESS_OR_EQUAL$LONG_;
            case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                return Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_;
            case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                return Instructions.SL_LESS_THAN$LONG_;
            case Instructions.SL_LESS_THAN$UNBOXED_ :
                return Instructions.SL_LESS_THAN_;
            case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                return Instructions.SL_LOGICAL_NOT$BOOLEAN_;
            case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                return Instructions.SL_LOGICAL_NOT_;
            case Instructions.SL_MUL$LONG$UNBOXED_ :
                return Instructions.SL_MUL$LONG_;
            case Instructions.SL_SUB$LONG$UNBOXED_ :
                return Instructions.SL_SUB$LONG_;
            case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                return Instructions.SL_UNBOX$FROM_BOOLEAN_;
            case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                return Instructions.SL_UNBOX$FROM_LONG_;
            case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                return Instructions.SL_TO_BOOLEAN$BOOLEAN_;
            case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                return Instructions.SL_TO_BOOLEAN_;
            case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                return Instructions.MERGE_CONDITIONAL$LONG;
            case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                return Instructions.MERGE_CONDITIONAL$BOOLEAN;
            default :
                return $operand;
        }
    }

    private static final class InstructionImpl extends Instruction {

        final AbstractBytecodeNode bytecode;
        final int bci;
        final int opcode;

        InstructionImpl(AbstractBytecodeNode bytecode, int bci, int opcode) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.bytecode = bytecode;
            this.bci = bci;
            this.opcode = opcode;
        }

        @Override
        public int getBytecodeIndex() {
            return bci;
        }

        @Override
        public BytecodeNode getBytecodeNode() {
            return bytecode;
        }

        @Override
        public int getOperationCode() {
            return opcode;
        }

        @Override
        public int getLength() {
            switch (opcode) {
                case Instructions.DUP :
                case Instructions.RETURN :
                case Instructions.THROW :
                case Instructions.LOAD_NULL :
                case Instructions.LOAD_VARIADIC_0 :
                case Instructions.LOAD_VARIADIC_1 :
                case Instructions.LOAD_VARIADIC_2 :
                case Instructions.LOAD_VARIADIC_3 :
                case Instructions.LOAD_VARIADIC_4 :
                case Instructions.LOAD_VARIADIC_5 :
                case Instructions.LOAD_VARIADIC_6 :
                case Instructions.LOAD_VARIADIC_7 :
                case Instructions.LOAD_VARIADIC_8 :
                case Instructions.MERGE_VARIADIC :
                case Instructions.CONSTANT_NULL :
                case Instructions.INVALIDATE0 :
                    return 2;
                case Instructions.LOAD_ARGUMENT :
                case Instructions.LOAD_ARGUMENT$LONG :
                case Instructions.LOAD_ARGUMENT$BOOLEAN :
                case Instructions.LOAD_EXCEPTION :
                case Instructions.CLEAR_LOCAL :
                case Instructions.INVALIDATE1 :
                    return 4;
                case Instructions.POP :
                case Instructions.POP$LONG :
                case Instructions.POP$BOOLEAN :
                case Instructions.POP$GENERIC :
                case Instructions.BRANCH :
                case Instructions.LOAD_CONSTANT :
                case Instructions.LOAD_CONSTANT$LONG :
                case Instructions.LOAD_CONSTANT$BOOLEAN :
                case Instructions.LOAD_LOCAL :
                case Instructions.LOAD_LOCAL$LONG :
                case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                case Instructions.LOAD_LOCAL$BOOLEAN :
                case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                case Instructions.LOAD_LOCAL$GENERIC :
                case Instructions.TAG_ENTER :
                case Instructions.TAG_LEAVE_VOID :
                case Instructions.SL_ALWAYS_HALT_ :
                case Instructions.SL_INVOKE_ :
                case Instructions.SL_READ_PROPERTY_ :
                case Instructions.SL_WRITE_PROPERTY_ :
                case Instructions.SL_FUNCTION_LITERAL_ :
                case Instructions.INVALIDATE2 :
                    return 6;
                case Instructions.LOAD_LOCAL_MAT :
                case Instructions.LOAD_LOCAL_MAT$LONG :
                case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                case Instructions.LOAD_LOCAL_MAT$GENERIC :
                case Instructions.INVALIDATE3 :
                    return 8;
                case Instructions.BRANCH_BACKWARD :
                case Instructions.STORE_LOCAL :
                case Instructions.STORE_LOCAL$LONG :
                case Instructions.STORE_LOCAL$LONG$LONG :
                case Instructions.STORE_LOCAL$BOOLEAN :
                case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                case Instructions.STORE_LOCAL$GENERIC :
                case Instructions.TAG_LEAVE :
                case Instructions.TAG_LEAVE$LONG :
                case Instructions.TAG_LEAVE$LONG$UNBOXED :
                case Instructions.TAG_LEAVE$BOOLEAN :
                case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                case Instructions.TAG_LEAVE$GENERIC :
                case Instructions.SL_LOAD_ARGUMENT_ :
                case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                case Instructions.SL_LOGICAL_NOT_ :
                case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                case Instructions.SL_UNBOX_ :
                case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                case Instructions.SL_UNBOX$FROM_LONG_ :
                case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                case Instructions.SL_TO_BOOLEAN_ :
                case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                case Instructions.SL_AND_ :
                case Instructions.SL_OR_ :
                case Instructions.MERGE_CONDITIONAL :
                case Instructions.MERGE_CONDITIONAL$LONG :
                case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                case Instructions.MERGE_CONDITIONAL$GENERIC :
                case Instructions.INVALIDATE4 :
                    return 10;
                case Instructions.STORE_LOCAL_MAT :
                case Instructions.STORE_LOCAL_MAT$LONG :
                case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                case Instructions.STORE_LOCAL_MAT$GENERIC :
                case Instructions.INVALIDATE5 :
                    return 12;
                case Instructions.BRANCH_FALSE :
                case Instructions.BRANCH_FALSE$GENERIC :
                case Instructions.BRANCH_FALSE$BOOLEAN :
                case Instructions.BUILTIN_ :
                case Instructions.SL_ADD_ :
                case Instructions.SL_ADD$LONG_ :
                case Instructions.SL_ADD$LONG$UNBOXED_ :
                case Instructions.SL_DIV_ :
                case Instructions.SL_DIV$LONG_ :
                case Instructions.SL_DIV$LONG$UNBOXED_ :
                case Instructions.SL_EQUAL_ :
                case Instructions.SL_EQUAL$LONG_ :
                case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                case Instructions.SL_EQUAL$BOOLEAN_ :
                case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                case Instructions.SL_EQUAL$UNBOXED_ :
                case Instructions.SL_LESS_OR_EQUAL_ :
                case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                case Instructions.SL_LESS_THAN_ :
                case Instructions.SL_LESS_THAN$LONG_ :
                case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                case Instructions.SL_LESS_THAN$UNBOXED_ :
                case Instructions.SL_MUL_ :
                case Instructions.SL_MUL$LONG_ :
                case Instructions.SL_MUL$LONG$UNBOXED_ :
                case Instructions.SL_SUB_ :
                case Instructions.SL_SUB$LONG_ :
                case Instructions.SL_SUB$LONG$UNBOXED_ :
                case Instructions.INVALIDATE6 :
                    return 14;
            }
            throw CompilerDirectives.shouldNotReachHere("Invalid opcode");
        }

        @Override
        public List<Argument> getArguments() {
            switch (opcode) {
                case Instructions.POP :
                case Instructions.POP$LONG :
                case Instructions.POP$BOOLEAN :
                case Instructions.POP$GENERIC :
                    return List.of(
                        new BytecodeIndexArgument(bytecode, "child0", bci + 2));
                case Instructions.DUP :
                case Instructions.RETURN :
                case Instructions.THROW :
                case Instructions.LOAD_NULL :
                case Instructions.LOAD_VARIADIC_0 :
                case Instructions.LOAD_VARIADIC_1 :
                case Instructions.LOAD_VARIADIC_2 :
                case Instructions.LOAD_VARIADIC_3 :
                case Instructions.LOAD_VARIADIC_4 :
                case Instructions.LOAD_VARIADIC_5 :
                case Instructions.LOAD_VARIADIC_6 :
                case Instructions.LOAD_VARIADIC_7 :
                case Instructions.LOAD_VARIADIC_8 :
                case Instructions.MERGE_VARIADIC :
                case Instructions.CONSTANT_NULL :
                case Instructions.INVALIDATE0 :
                    return List.of();
                case Instructions.BRANCH :
                    return List.of(
                        new BytecodeIndexArgument(bytecode, "branch_target", bci + 2));
                case Instructions.BRANCH_BACKWARD :
                    return List.of(
                        new BytecodeIndexArgument(bytecode, "branch_target", bci + 2),
                        new BranchProfileArgument(bytecode, "loop_header_branch_profile", bci + 6));
                case Instructions.BRANCH_FALSE :
                case Instructions.BRANCH_FALSE$GENERIC :
                case Instructions.BRANCH_FALSE$BOOLEAN :
                    return List.of(
                        new BytecodeIndexArgument(bytecode, "branch_target", bci + 2),
                        new BranchProfileArgument(bytecode, "branch_profile", bci + 6),
                        new BytecodeIndexArgument(bytecode, "child0", bci + 10));
                case Instructions.STORE_LOCAL :
                case Instructions.STORE_LOCAL$LONG :
                case Instructions.STORE_LOCAL$LONG$LONG :
                case Instructions.STORE_LOCAL$BOOLEAN :
                case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                case Instructions.STORE_LOCAL$GENERIC :
                    return List.of(
                        new LocalOffsetArgument(bytecode, "localOffset", bci + 2),
                        new LocalIndexArgument(bytecode, "localIndex", bci + 4),
                        new BytecodeIndexArgument(bytecode, "child0", bci + 6));
                case Instructions.LOAD_CONSTANT :
                case Instructions.LOAD_CONSTANT$LONG :
                case Instructions.LOAD_CONSTANT$BOOLEAN :
                    return List.of(
                        new ConstantArgument(bytecode, "constant", bci + 2));
                case Instructions.LOAD_ARGUMENT :
                case Instructions.LOAD_ARGUMENT$LONG :
                case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    return List.of(
                        new IntegerArgument(bytecode, "index", bci + 2, 2));
                case Instructions.LOAD_EXCEPTION :
                    return List.of(
                        new IntegerArgument(bytecode, "exceptionSp", bci + 2, 2));
                case Instructions.LOAD_LOCAL :
                case Instructions.LOAD_LOCAL$LONG :
                case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                case Instructions.LOAD_LOCAL$BOOLEAN :
                case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                case Instructions.LOAD_LOCAL$GENERIC :
                    return List.of(
                        new LocalOffsetArgument(bytecode, "localOffset", bci + 2),
                        new LocalIndexArgument(bytecode, "localIndex", bci + 4));
                case Instructions.LOAD_LOCAL_MAT :
                case Instructions.LOAD_LOCAL_MAT$LONG :
                case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    return List.of(
                        new LocalOffsetArgument(bytecode, "localOffset", bci + 2),
                        new LocalIndexArgument(bytecode, "localIndex", bci + 4),
                        new IntegerArgument(bytecode, "rootIndex", bci + 6, 2));
                case Instructions.STORE_LOCAL_MAT :
                case Instructions.STORE_LOCAL_MAT$LONG :
                case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                case Instructions.STORE_LOCAL_MAT$GENERIC :
                    return List.of(
                        new LocalOffsetArgument(bytecode, "localOffset", bci + 2),
                        new LocalIndexArgument(bytecode, "localIndex", bci + 4),
                        new IntegerArgument(bytecode, "rootIndex", bci + 6, 2),
                        new BytecodeIndexArgument(bytecode, "child0", bci + 8));
                case Instructions.TAG_ENTER :
                case Instructions.TAG_LEAVE_VOID :
                    return List.of(
                        new TagNodeArgument(bytecode, "tag", bci + 2));
                case Instructions.TAG_LEAVE :
                case Instructions.TAG_LEAVE$LONG :
                case Instructions.TAG_LEAVE$LONG$UNBOXED :
                case Instructions.TAG_LEAVE$BOOLEAN :
                case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                case Instructions.TAG_LEAVE$GENERIC :
                    return List.of(
                        new TagNodeArgument(bytecode, "tag", bci + 2),
                        new BytecodeIndexArgument(bytecode, "child0", bci + 6));
                case Instructions.CLEAR_LOCAL :
                    return List.of(
                        new LocalOffsetArgument(bytecode, "localOffset", bci + 2));
                case Instructions.SL_ALWAYS_HALT_ :
                case Instructions.SL_INVOKE_ :
                case Instructions.SL_READ_PROPERTY_ :
                case Instructions.SL_WRITE_PROPERTY_ :
                case Instructions.SL_FUNCTION_LITERAL_ :
                    return List.of(
                        new NodeProfileArgument(bytecode, "node", bci + 2));
                case Instructions.SL_LOAD_ARGUMENT_ :
                case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                    return List.of(
                        new ConstantArgument(bytecode, "index", bci + 2),
                        new NodeProfileArgument(bytecode, "node", bci + 6));
                case Instructions.BUILTIN_ :
                    return List.of(
                        new ConstantArgument(bytecode, "builtin", bci + 2),
                        new ConstantArgument(bytecode, "argumentCount", bci + 6),
                        new NodeProfileArgument(bytecode, "node", bci + 10));
                case Instructions.SL_ADD_ :
                case Instructions.SL_ADD$LONG_ :
                case Instructions.SL_ADD$LONG$UNBOXED_ :
                case Instructions.SL_DIV_ :
                case Instructions.SL_DIV$LONG_ :
                case Instructions.SL_DIV$LONG$UNBOXED_ :
                case Instructions.SL_EQUAL_ :
                case Instructions.SL_EQUAL$LONG_ :
                case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                case Instructions.SL_EQUAL$BOOLEAN_ :
                case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                case Instructions.SL_EQUAL$UNBOXED_ :
                case Instructions.SL_LESS_OR_EQUAL_ :
                case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                case Instructions.SL_LESS_THAN_ :
                case Instructions.SL_LESS_THAN$LONG_ :
                case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                case Instructions.SL_LESS_THAN$UNBOXED_ :
                case Instructions.SL_MUL_ :
                case Instructions.SL_MUL$LONG_ :
                case Instructions.SL_MUL$LONG$UNBOXED_ :
                case Instructions.SL_SUB_ :
                case Instructions.SL_SUB$LONG_ :
                case Instructions.SL_SUB$LONG$UNBOXED_ :
                    return List.of(
                        new NodeProfileArgument(bytecode, "node", bci + 2),
                        new BytecodeIndexArgument(bytecode, "child0", bci + 6),
                        new BytecodeIndexArgument(bytecode, "child1", bci + 10));
                case Instructions.SL_LOGICAL_NOT_ :
                case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                case Instructions.SL_UNBOX_ :
                case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                case Instructions.SL_UNBOX$FROM_LONG_ :
                case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                case Instructions.SL_TO_BOOLEAN_ :
                case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                    return List.of(
                        new NodeProfileArgument(bytecode, "node", bci + 2),
                        new BytecodeIndexArgument(bytecode, "child0", bci + 6));
                case Instructions.SL_AND_ :
                case Instructions.SL_OR_ :
                    return List.of(
                        new BytecodeIndexArgument(bytecode, "branch_target", bci + 2),
                        new BranchProfileArgument(bytecode, "branch_profile", bci + 6));
                case Instructions.MERGE_CONDITIONAL :
                case Instructions.MERGE_CONDITIONAL$LONG :
                case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                case Instructions.MERGE_CONDITIONAL$GENERIC :
                    return List.of(
                        new BytecodeIndexArgument(bytecode, "child0", bci + 2),
                        new BytecodeIndexArgument(bytecode, "child1", bci + 6));
                case Instructions.INVALIDATE1 :
                    return List.of(
                        new IntegerArgument(bytecode, "invalidated0", bci + 2, 2));
                case Instructions.INVALIDATE2 :
                    return List.of(
                        new IntegerArgument(bytecode, "invalidated0", bci + 2, 2),
                        new IntegerArgument(bytecode, "invalidated1", bci + 4, 2));
                case Instructions.INVALIDATE3 :
                    return List.of(
                        new IntegerArgument(bytecode, "invalidated0", bci + 2, 2),
                        new IntegerArgument(bytecode, "invalidated1", bci + 4, 2),
                        new IntegerArgument(bytecode, "invalidated2", bci + 6, 2));
                case Instructions.INVALIDATE4 :
                    return List.of(
                        new IntegerArgument(bytecode, "invalidated0", bci + 2, 2),
                        new IntegerArgument(bytecode, "invalidated1", bci + 4, 2),
                        new IntegerArgument(bytecode, "invalidated2", bci + 6, 2),
                        new IntegerArgument(bytecode, "invalidated3", bci + 8, 2));
                case Instructions.INVALIDATE5 :
                    return List.of(
                        new IntegerArgument(bytecode, "invalidated0", bci + 2, 2),
                        new IntegerArgument(bytecode, "invalidated1", bci + 4, 2),
                        new IntegerArgument(bytecode, "invalidated2", bci + 6, 2),
                        new IntegerArgument(bytecode, "invalidated3", bci + 8, 2),
                        new IntegerArgument(bytecode, "invalidated4", bci + 10, 2));
                case Instructions.INVALIDATE6 :
                    return List.of(
                        new IntegerArgument(bytecode, "invalidated0", bci + 2, 2),
                        new IntegerArgument(bytecode, "invalidated1", bci + 4, 2),
                        new IntegerArgument(bytecode, "invalidated2", bci + 6, 2),
                        new IntegerArgument(bytecode, "invalidated3", bci + 8, 2),
                        new IntegerArgument(bytecode, "invalidated4", bci + 10, 2),
                        new IntegerArgument(bytecode, "invalidated5", bci + 12, 2));
            }
            throw CompilerDirectives.shouldNotReachHere("Invalid opcode");
        }

        @Override
        public String getName() {
            switch (opcode) {
                case Instructions.POP :
                    return "pop";
                case Instructions.POP$LONG :
                    return "pop$Long";
                case Instructions.POP$BOOLEAN :
                    return "pop$Boolean";
                case Instructions.POP$GENERIC :
                    return "pop$generic";
                case Instructions.DUP :
                    return "dup";
                case Instructions.RETURN :
                    return "return";
                case Instructions.BRANCH :
                    return "branch";
                case Instructions.BRANCH_BACKWARD :
                    return "branch.backward";
                case Instructions.BRANCH_FALSE :
                    return "branch.false";
                case Instructions.BRANCH_FALSE$GENERIC :
                    return "branch.false$Generic";
                case Instructions.BRANCH_FALSE$BOOLEAN :
                    return "branch.false$Boolean";
                case Instructions.STORE_LOCAL :
                    return "store.local";
                case Instructions.STORE_LOCAL$LONG :
                    return "store.local$Long";
                case Instructions.STORE_LOCAL$LONG$LONG :
                    return "store.local$Long$Long";
                case Instructions.STORE_LOCAL$BOOLEAN :
                    return "store.local$Boolean";
                case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    return "store.local$Boolean$Boolean";
                case Instructions.STORE_LOCAL$GENERIC :
                    return "store.local$generic";
                case Instructions.THROW :
                    return "throw";
                case Instructions.LOAD_CONSTANT :
                    return "load.constant";
                case Instructions.LOAD_CONSTANT$LONG :
                    return "load.constant$Long";
                case Instructions.LOAD_CONSTANT$BOOLEAN :
                    return "load.constant$Boolean";
                case Instructions.LOAD_NULL :
                    return "load.null";
                case Instructions.LOAD_ARGUMENT :
                    return "load.argument";
                case Instructions.LOAD_ARGUMENT$LONG :
                    return "load.argument$Long";
                case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    return "load.argument$Boolean";
                case Instructions.LOAD_EXCEPTION :
                    return "load.exception";
                case Instructions.LOAD_LOCAL :
                    return "load.local";
                case Instructions.LOAD_LOCAL$LONG :
                    return "load.local$Long";
                case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    return "load.local$Long$unboxed";
                case Instructions.LOAD_LOCAL$BOOLEAN :
                    return "load.local$Boolean";
                case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    return "load.local$Boolean$unboxed";
                case Instructions.LOAD_LOCAL$GENERIC :
                    return "load.local$generic";
                case Instructions.LOAD_LOCAL_MAT :
                    return "load.local.mat";
                case Instructions.LOAD_LOCAL_MAT$LONG :
                    return "load.local.mat$Long";
                case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    return "load.local.mat$Long$unboxed";
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    return "load.local.mat$Boolean";
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    return "load.local.mat$Boolean$unboxed";
                case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    return "load.local.mat$generic";
                case Instructions.STORE_LOCAL_MAT :
                    return "store.local.mat";
                case Instructions.STORE_LOCAL_MAT$LONG :
                    return "store.local.mat$Long";
                case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    return "store.local.mat$Long$Long";
                case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    return "store.local.mat$Boolean";
                case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    return "store.local.mat$Boolean$Boolean";
                case Instructions.STORE_LOCAL_MAT$GENERIC :
                    return "store.local.mat$generic";
                case Instructions.TAG_ENTER :
                    return "tag.enter";
                case Instructions.TAG_LEAVE :
                    return "tag.leave";
                case Instructions.TAG_LEAVE$LONG :
                    return "tag.leave$Long";
                case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    return "tag.leave$Long$unboxed";
                case Instructions.TAG_LEAVE$BOOLEAN :
                    return "tag.leave$Boolean";
                case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    return "tag.leave$Boolean$unboxed";
                case Instructions.TAG_LEAVE$GENERIC :
                    return "tag.leave$generic";
                case Instructions.TAG_LEAVE_VOID :
                    return "tag.leaveVoid";
                case Instructions.LOAD_VARIADIC_0 :
                    return "load.variadic_0";
                case Instructions.LOAD_VARIADIC_1 :
                    return "load.variadic_1";
                case Instructions.LOAD_VARIADIC_2 :
                    return "load.variadic_2";
                case Instructions.LOAD_VARIADIC_3 :
                    return "load.variadic_3";
                case Instructions.LOAD_VARIADIC_4 :
                    return "load.variadic_4";
                case Instructions.LOAD_VARIADIC_5 :
                    return "load.variadic_5";
                case Instructions.LOAD_VARIADIC_6 :
                    return "load.variadic_6";
                case Instructions.LOAD_VARIADIC_7 :
                    return "load.variadic_7";
                case Instructions.LOAD_VARIADIC_8 :
                    return "load.variadic_8";
                case Instructions.MERGE_VARIADIC :
                    return "merge.variadic";
                case Instructions.CONSTANT_NULL :
                    return "constant_null";
                case Instructions.CLEAR_LOCAL :
                    return "clear.local";
                case Instructions.SL_ALWAYS_HALT_ :
                    return "c.SLAlwaysHalt";
                case Instructions.SL_LOAD_ARGUMENT_ :
                    return "c.SLLoadArgument";
                case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                    return "c.SLLoadArgument$LoadInBounds";
                case Instructions.BUILTIN_ :
                    return "c.Builtin";
                case Instructions.SL_INVOKE_ :
                    return "c.SLInvoke";
                case Instructions.SL_ADD_ :
                    return "c.SLAdd";
                case Instructions.SL_ADD$LONG_ :
                    return "c.SLAdd$Long";
                case Instructions.SL_ADD$LONG$UNBOXED_ :
                    return "c.SLAdd$Long$unboxed";
                case Instructions.SL_DIV_ :
                    return "c.SLDiv";
                case Instructions.SL_DIV$LONG_ :
                    return "c.SLDiv$Long";
                case Instructions.SL_DIV$LONG$UNBOXED_ :
                    return "c.SLDiv$Long$unboxed";
                case Instructions.SL_EQUAL_ :
                    return "c.SLEqual";
                case Instructions.SL_EQUAL$LONG_ :
                    return "c.SLEqual$Long";
                case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    return "c.SLEqual$Long$unboxed";
                case Instructions.SL_EQUAL$BOOLEAN_ :
                    return "c.SLEqual$Boolean";
                case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    return "c.SLEqual$Boolean$unboxed";
                case Instructions.SL_EQUAL$UNBOXED_ :
                    return "c.SLEqual$unboxed";
                case Instructions.SL_LESS_OR_EQUAL_ :
                    return "c.SLLessOrEqual";
                case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    return "c.SLLessOrEqual$Long";
                case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    return "c.SLLessOrEqual$Long$unboxed";
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    return "c.SLLessOrEqual$SLBigInteger#InteropBigInteger0#InteropBigInteger1";
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                    return "c.SLLessOrEqual$SLBigInteger#InteropBigInteger0#InteropBigInteger1$unboxed";
                case Instructions.SL_LESS_THAN_ :
                    return "c.SLLessThan";
                case Instructions.SL_LESS_THAN$LONG_ :
                    return "c.SLLessThan$Long";
                case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    return "c.SLLessThan$Long$unboxed";
                case Instructions.SL_LESS_THAN$UNBOXED_ :
                    return "c.SLLessThan$unboxed";
                case Instructions.SL_LOGICAL_NOT_ :
                    return "c.SLLogicalNot";
                case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    return "c.SLLogicalNot$Boolean";
                case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    return "c.SLLogicalNot$Boolean$unboxed";
                case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                    return "c.SLLogicalNot$unboxed";
                case Instructions.SL_MUL_ :
                    return "c.SLMul";
                case Instructions.SL_MUL$LONG_ :
                    return "c.SLMul$Long";
                case Instructions.SL_MUL$LONG$UNBOXED_ :
                    return "c.SLMul$Long$unboxed";
                case Instructions.SL_READ_PROPERTY_ :
                    return "c.SLReadProperty";
                case Instructions.SL_SUB_ :
                    return "c.SLSub";
                case Instructions.SL_SUB$LONG_ :
                    return "c.SLSub$Long";
                case Instructions.SL_SUB$LONG$UNBOXED_ :
                    return "c.SLSub$Long$unboxed";
                case Instructions.SL_WRITE_PROPERTY_ :
                    return "c.SLWriteProperty";
                case Instructions.SL_UNBOX_ :
                    return "c.SLUnbox";
                case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    return "c.SLUnbox$FromBoolean";
                case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    return "c.SLUnbox$FromBoolean$unboxed";
                case Instructions.SL_UNBOX$FROM_LONG_ :
                    return "c.SLUnbox$FromLong";
                case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                    return "c.SLUnbox$FromLong$unboxed";
                case Instructions.SL_FUNCTION_LITERAL_ :
                    return "c.SLFunctionLiteral";
                case Instructions.SL_TO_BOOLEAN_ :
                    return "c.SLToBoolean";
                case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    return "c.SLToBoolean$Boolean";
                case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    return "c.SLToBoolean$Boolean$unboxed";
                case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                    return "c.SLToBoolean$unboxed";
                case Instructions.SL_AND_ :
                    return "sc.SLAnd";
                case Instructions.SL_OR_ :
                    return "sc.SLOr";
                case Instructions.MERGE_CONDITIONAL :
                    return "merge.conditional";
                case Instructions.MERGE_CONDITIONAL$LONG :
                    return "merge.conditional$Long";
                case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    return "merge.conditional$Long$unboxed";
                case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    return "merge.conditional$Boolean";
                case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    return "merge.conditional$Boolean$unboxed";
                case Instructions.MERGE_CONDITIONAL$GENERIC :
                    return "merge.conditional$generic";
                case Instructions.INVALIDATE0 :
                    return "invalidate0";
                case Instructions.INVALIDATE1 :
                    return "invalidate1";
                case Instructions.INVALIDATE2 :
                    return "invalidate2";
                case Instructions.INVALIDATE3 :
                    return "invalidate3";
                case Instructions.INVALIDATE4 :
                    return "invalidate4";
                case Instructions.INVALIDATE5 :
                    return "invalidate5";
                case Instructions.INVALIDATE6 :
                    return "invalidate6";
            }
            throw CompilerDirectives.shouldNotReachHere("Invalid opcode");
        }

        @Override
        public boolean isInstrumentation() {
            switch (opcode) {
                case Instructions.POP :
                case Instructions.POP$LONG :
                case Instructions.POP$BOOLEAN :
                case Instructions.POP$GENERIC :
                case Instructions.DUP :
                case Instructions.RETURN :
                case Instructions.BRANCH :
                case Instructions.BRANCH_BACKWARD :
                case Instructions.BRANCH_FALSE :
                case Instructions.BRANCH_FALSE$GENERIC :
                case Instructions.BRANCH_FALSE$BOOLEAN :
                case Instructions.STORE_LOCAL :
                case Instructions.STORE_LOCAL$LONG :
                case Instructions.STORE_LOCAL$LONG$LONG :
                case Instructions.STORE_LOCAL$BOOLEAN :
                case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                case Instructions.STORE_LOCAL$GENERIC :
                case Instructions.THROW :
                case Instructions.LOAD_CONSTANT :
                case Instructions.LOAD_CONSTANT$LONG :
                case Instructions.LOAD_CONSTANT$BOOLEAN :
                case Instructions.LOAD_NULL :
                case Instructions.LOAD_ARGUMENT :
                case Instructions.LOAD_ARGUMENT$LONG :
                case Instructions.LOAD_ARGUMENT$BOOLEAN :
                case Instructions.LOAD_EXCEPTION :
                case Instructions.LOAD_LOCAL :
                case Instructions.LOAD_LOCAL$LONG :
                case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                case Instructions.LOAD_LOCAL$BOOLEAN :
                case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                case Instructions.LOAD_LOCAL$GENERIC :
                case Instructions.LOAD_LOCAL_MAT :
                case Instructions.LOAD_LOCAL_MAT$LONG :
                case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                case Instructions.LOAD_LOCAL_MAT$GENERIC :
                case Instructions.STORE_LOCAL_MAT :
                case Instructions.STORE_LOCAL_MAT$LONG :
                case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                case Instructions.STORE_LOCAL_MAT$GENERIC :
                case Instructions.LOAD_VARIADIC_0 :
                case Instructions.LOAD_VARIADIC_1 :
                case Instructions.LOAD_VARIADIC_2 :
                case Instructions.LOAD_VARIADIC_3 :
                case Instructions.LOAD_VARIADIC_4 :
                case Instructions.LOAD_VARIADIC_5 :
                case Instructions.LOAD_VARIADIC_6 :
                case Instructions.LOAD_VARIADIC_7 :
                case Instructions.LOAD_VARIADIC_8 :
                case Instructions.MERGE_VARIADIC :
                case Instructions.CONSTANT_NULL :
                case Instructions.CLEAR_LOCAL :
                case Instructions.SL_ALWAYS_HALT_ :
                case Instructions.SL_LOAD_ARGUMENT_ :
                case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                case Instructions.BUILTIN_ :
                case Instructions.SL_INVOKE_ :
                case Instructions.SL_ADD_ :
                case Instructions.SL_ADD$LONG_ :
                case Instructions.SL_ADD$LONG$UNBOXED_ :
                case Instructions.SL_DIV_ :
                case Instructions.SL_DIV$LONG_ :
                case Instructions.SL_DIV$LONG$UNBOXED_ :
                case Instructions.SL_EQUAL_ :
                case Instructions.SL_EQUAL$LONG_ :
                case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                case Instructions.SL_EQUAL$BOOLEAN_ :
                case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                case Instructions.SL_EQUAL$UNBOXED_ :
                case Instructions.SL_LESS_OR_EQUAL_ :
                case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                case Instructions.SL_LESS_THAN_ :
                case Instructions.SL_LESS_THAN$LONG_ :
                case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                case Instructions.SL_LESS_THAN$UNBOXED_ :
                case Instructions.SL_LOGICAL_NOT_ :
                case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                case Instructions.SL_MUL_ :
                case Instructions.SL_MUL$LONG_ :
                case Instructions.SL_MUL$LONG$UNBOXED_ :
                case Instructions.SL_READ_PROPERTY_ :
                case Instructions.SL_SUB_ :
                case Instructions.SL_SUB$LONG_ :
                case Instructions.SL_SUB$LONG$UNBOXED_ :
                case Instructions.SL_WRITE_PROPERTY_ :
                case Instructions.SL_UNBOX_ :
                case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                case Instructions.SL_UNBOX$FROM_LONG_ :
                case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                case Instructions.SL_FUNCTION_LITERAL_ :
                case Instructions.SL_TO_BOOLEAN_ :
                case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                case Instructions.SL_AND_ :
                case Instructions.SL_OR_ :
                case Instructions.MERGE_CONDITIONAL :
                case Instructions.MERGE_CONDITIONAL$LONG :
                case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                case Instructions.MERGE_CONDITIONAL$GENERIC :
                case Instructions.INVALIDATE0 :
                case Instructions.INVALIDATE1 :
                case Instructions.INVALIDATE2 :
                case Instructions.INVALIDATE3 :
                case Instructions.INVALIDATE4 :
                case Instructions.INVALIDATE5 :
                case Instructions.INVALIDATE6 :
                    return false;
                case Instructions.TAG_ENTER :
                case Instructions.TAG_LEAVE :
                case Instructions.TAG_LEAVE$LONG :
                case Instructions.TAG_LEAVE$LONG$UNBOXED :
                case Instructions.TAG_LEAVE$BOOLEAN :
                case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                case Instructions.TAG_LEAVE$GENERIC :
                case Instructions.TAG_LEAVE_VOID :
                    return true;
            }
            throw CompilerDirectives.shouldNotReachHere("Invalid opcode");
        }

        @Override
        protected Instruction next() {
            int nextBci = getNextBytecodeIndex();
            if (nextBci >= bytecode.bytecodes.length) {
                return null;
            }
            return new InstructionImpl(bytecode, nextBci, bytecode.readValidBytecode(bytecode.bytecodes, nextBci));
        }

        private abstract static sealed class AbstractArgument extends Argument permits LocalOffsetArgument, LocalIndexArgument, IntegerArgument, BytecodeIndexArgument, ConstantArgument, NodeProfileArgument, TagNodeArgument, BranchProfileArgument {

            protected static final BytecodeDSLAccess SAFE_ACCESS = BytecodeDSLAccess.lookup(BytecodeRootNodesImpl.VISIBLE_TOKEN, false);
            protected static final ByteArraySupport SAFE_BYTES = SAFE_ACCESS.getByteArraySupport();

            final AbstractBytecodeNode bytecode;
            final String name;
            final int bci;

            AbstractArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
                this.bytecode = bytecode;
                this.name = name;
                this.bci = bci;
            }

            @Override
            public final String getName() {
                return name;
            }

        }
        private static final class LocalOffsetArgument extends AbstractArgument {

            LocalOffsetArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.LOCAL_OFFSET;
            }

            @Override
            public int asLocalOffset() {
                byte[] bc = this.bytecode.bytecodes;
                return SAFE_BYTES.getShort(bc, bci) - USER_LOCALS_START_INDEX;
            }

        }
        private static final class LocalIndexArgument extends AbstractArgument {

            LocalIndexArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.LOCAL_INDEX;
            }

            @Override
            public int asLocalIndex() {
                byte[] bc = this.bytecode.bytecodes;
                return SAFE_BYTES.getShort(bc, bci);
            }

        }
        private static final class IntegerArgument extends AbstractArgument {

            private final int width;

            IntegerArgument(AbstractBytecodeNode bytecode, String name, int bci, int width) {
                super(bytecode, name, bci);
                this.width = width;
            }

            @Override
            public Kind getKind() {
                return Kind.INTEGER;
            }

            @Override
            public int asInteger() throws UnsupportedOperationException {
                byte[] bc = this.bytecode.bytecodes;
                switch (width) {
                    case 1 :
                        return SAFE_BYTES.getByte(bc, bci);
                    case 2 :
                        return SAFE_BYTES.getShort(bc, bci);
                    case 4 :
                        return SAFE_BYTES.getInt(bc, bci);
                    default :
                        throw assertionFailed("Unexpected integer width " + width);
                }
            }

        }
        private static final class BytecodeIndexArgument extends AbstractArgument {

            BytecodeIndexArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.BYTECODE_INDEX;
            }

            @Override
            public int asBytecodeIndex() {
                byte[] bc = this.bytecode.bytecodes;
                return SAFE_BYTES.getInt(bc, bci);
            }

        }
        private static final class ConstantArgument extends AbstractArgument {

            ConstantArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.CONSTANT;
            }

            @Override
            public Object asConstant() {
                byte[] bc = this.bytecode.bytecodes;
                Object[] constants = this.bytecode.constants;
                return SAFE_ACCESS.readObject(constants, SAFE_BYTES.getInt(bc, bci));
            }

        }
        private static final class NodeProfileArgument extends AbstractArgument {

            NodeProfileArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.NODE_PROFILE;
            }

            @Override
            public Node asCachedNode() {
                Node[] cachedNodes = this.bytecode.getCachedNodes();
                if (cachedNodes == null) {
                    return null;
                }
                byte[] bc = this.bytecode.bytecodes;
                return cachedNodes[SAFE_BYTES.getInt(bc, bci)];
            }

        }
        private static final class TagNodeArgument extends AbstractArgument {

            TagNodeArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.TAG_NODE;
            }

            @Override
            public TagTreeNode asTagNode() {
                byte[] bc = this.bytecode.bytecodes;
                TagRootNode tagRoot = this.bytecode.tagRoot;
                if (tagRoot == null) {
                    return null;
                }
                return tagRoot.tagNodes[SAFE_BYTES.getInt(bc, bci)];
            }

        }
        private static final class BranchProfileArgument extends AbstractArgument {

            BranchProfileArgument(AbstractBytecodeNode bytecode, String name, int bci) {
                super(bytecode, name, bci);
            }

            @Override
            public Kind getKind() {
                return Kind.BRANCH_PROFILE;
            }

            @Override
            public BranchProfile asBranchProfile() {
                byte[] bc = this.bytecode.bytecodes;
                int index = SAFE_BYTES.getInt(bc, bci);
                int[] profiles = this.bytecode.getBranchProfiles();
                if (profiles == null) {
                    return new BranchProfile(index, 0, 0);
                }
                return new BranchProfile(index, profiles[index * 2], profiles[index * 2 + 1]);
            }

        }
    }
    private static final class TagNode extends TagTreeNode implements InstrumentableNode, TagTree {

        static final TagNode[] EMPTY_ARRAY = new TagNode[0];

        final int tags;
        final int enterBci;
        @CompilationFinal int returnBci;
        @Children TagNode[] children;
        @Child private volatile ProbeNode probe;
        @CompilationFinal private volatile SourceSection sourceSection;

        TagNode(int tags, int enterBci) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.tags = tags;
            this.enterBci = enterBci;
        }

        @Override
        public WrapperNode createWrapper(ProbeNode p) {
            return null;
        }

        @Override
        public ProbeNode findProbe() {
            ProbeNode p = this.probe;
            if (p == null) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                this.probe = p = insert(createProbe(getSourceSection()));
            }
            return p;
        }

        @Override
        public boolean isInstrumentable() {
            return true;
        }

        @Override
        public boolean hasTag(Class<? extends Tag> tag) {
            if (tag == CallTag.class) {
                return (tags & 0x1) != 0;
            } else if (tag == StatementTag.class) {
                return (tags & 0x2) != 0;
            } else if (tag == RootTag.class) {
                return (tags & 0x4) != 0;
            } else if (tag == RootBodyTag.class) {
                return (tags & 0x8) != 0;
            } else if (tag == ExpressionTag.class) {
                return (tags & 0x10) != 0;
            } else if (tag == AlwaysHalt.class) {
                return (tags & 0x20) != 0;
            } else if (tag == ReadVariableTag.class) {
                return (tags & 0x40) != 0;
            } else if (tag == WriteVariableTag.class) {
                return (tags & 0x80) != 0;
            }
            return false;
        }

        @Override
        public Node copy() {
            TagNode copy = (TagNode) super.copy();
            copy.probe = null;
            return copy;
        }

        @Override
        public SourceSection getSourceSection() {
            SourceSection section = this.sourceSection;
            if (section == null) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                this.sourceSection = section = createSourceSection();
            }
            return section;
        }

        @Override
        public SourceSection[] getSourceSections() {
            return findBytecodeNode().getSourceLocations(enterBci);
        }

        private SourceSection createSourceSection() {
            if (enterBci == -1) {
                // only happens for synthetic instrumentable root nodes.
                return null;
            }
            return findBytecodeNode().getSourceLocation(enterBci);
        }

        @TruffleBoundary
        private AbstractBytecodeNode findBytecodeNode() {
            Node current = this;
            while (!(current instanceof AbstractBytecodeNode bytecodeNode)) {
                current = current.getParent();
            }
            if (bytecodeNode == null) {
                throw CompilerDirectives.shouldNotReachHere("Unexpected disconnected node.");
            }
            return bytecodeNode;
        }

        @Override
        protected Class<?> dispatch() {
            return SLBytecodeScopeExports.class;
        }

        @Override
        protected Class<SLLanguage> getLanguage() {
            return SLLanguage.class;
        }

        @Override
        public List<TagTree> getTreeChildren() {
            return List.of(this.children);
        }

        @Override
        public List<Class<? extends Tag>> getTags() {
            return List.of(mapTagMaskToTagsArray(this.tags));
        }

        @Override
        public int getEnterBytecodeIndex() {
            return this.enterBci;
        }

        @Override
        public int getReturnBytecodeIndex() {
            return this.returnBci;
        }

    }
    private static final class TagRootNode extends Node {

        @Child TagNode root;
        final TagNode[] tagNodes;
        @Child ProbeNode probe;

        TagRootNode(TagNode root, TagNode[] tagNodes) {
            this.root = root;
            this.tagNodes = tagNodes;
        }

        ProbeNode getProbe() {
            ProbeNode localProbe = this.probe;
            if (localProbe == null) {
                this.probe = localProbe = insert(root.createProbe(null));
            }
            return localProbe;
        }

        @Override
        public Node copy() {
            TagRootNode copy = (TagRootNode) super.copy();
            copy.probe = null;
            return copy;
        }

    }
    private abstract static sealed class AbstractBytecodeNode extends BytecodeNode permits CachedBytecodeNode, UncachedBytecodeNode {

        @CompilationFinal(dimensions = 1) final byte[] bytecodes;
        @CompilationFinal(dimensions = 1) final Object[] constants;
        @CompilationFinal(dimensions = 1) final int[] handlers;
        @CompilationFinal(dimensions = 1) final int[] locals;
        @CompilationFinal(dimensions = 1) final int[] sourceInfo;
        final List<Source> sources;
        final int numNodes;
        @Child TagRootNode tagRoot;
        volatile byte[] oldBytecodes;

        protected AbstractBytecodeNode(byte[] bytecodes, Object[] constants, int[] handlers, int[] locals, int[] sourceInfo, List<Source> sources, int numNodes, TagRootNode tagRoot) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.bytecodes = bytecodes;
            this.constants = constants;
            this.handlers = handlers;
            this.locals = locals;
            this.sourceInfo = sourceInfo;
            this.sources = sources;
            this.numNodes = numNodes;
            this.tagRoot = tagRoot;
        }

        final Node findInstrumentableCallNode(int bci) {
            int[] localHandlers = handlers;
            for (int i = 0; i < localHandlers.length; i += EXCEPTION_HANDLER_LENGTH) {
                if (localHandlers[i + EXCEPTION_HANDLER_OFFSET_START_BCI] > bci) {
                    continue;
                }
                if (localHandlers[i + EXCEPTION_HANDLER_OFFSET_END_BCI] <= bci) {
                    continue;
                }
                int handlerKind = localHandlers[i + EXCEPTION_HANDLER_OFFSET_KIND];
                if (handlerKind != HANDLER_TAG_EXCEPTIONAL) {
                    continue;
                }
                int nodeId = localHandlers[i + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
                return tagRoot.tagNodes[nodeId];
            }
            return null;
        }

        @Override
        protected abstract int findBytecodeIndex(Frame frame, Node operationNode);

        final int readValidBytecode(byte[] bc, int bci) {
            int op = BYTES.getShort(bc, bci);
            switch (op) {
                case Instructions.INVALIDATE0 :
                case Instructions.INVALIDATE1 :
                case Instructions.INVALIDATE2 :
                case Instructions.INVALIDATE3 :
                case Instructions.INVALIDATE4 :
                case Instructions.INVALIDATE5 :
                case Instructions.INVALIDATE6 :
                    // While we were processing the exception handler the code invalidated.
                    // We need to re-read the op from the old bytecodes.
                    CompilerDirectives.transferToInterpreterAndInvalidate();
                    return oldBytecodes[bci];
                default :
                    return op;
            }
        }

        abstract long continueAt(SLBytecodeRootNodeGen $root, VirtualFrame frame, long startState);

        final SLBytecodeRootNodeGen getRoot() {
            return (SLBytecodeRootNodeGen) getParent();
        }

        abstract AbstractBytecodeNode toCached(int numLocals);

        abstract AbstractBytecodeNode update(byte[] bytecodes_, Object[] constants_, int[] handlers_, int[] locals_, int[] sourceInfo_, List<Source> sources_, int numNodes_, TagRootNode tagRoot_);

        final void invalidate(AbstractBytecodeNode newNode, CharSequence reason) {
            byte[] bc = this.bytecodes;
            int bci = 0;
            this.oldBytecodes = Arrays.copyOf(bc, bc.length);
            VarHandle.loadLoadFence();
            while (bci < bc.length) {
                short op = BYTES.getShort(bc, bci);
                switch (op) {
                    case Instructions.DUP :
                    case Instructions.RETURN :
                    case Instructions.THROW :
                    case Instructions.LOAD_NULL :
                    case Instructions.LOAD_VARIADIC_0 :
                    case Instructions.LOAD_VARIADIC_1 :
                    case Instructions.LOAD_VARIADIC_2 :
                    case Instructions.LOAD_VARIADIC_3 :
                    case Instructions.LOAD_VARIADIC_4 :
                    case Instructions.LOAD_VARIADIC_5 :
                    case Instructions.LOAD_VARIADIC_6 :
                    case Instructions.LOAD_VARIADIC_7 :
                    case Instructions.LOAD_VARIADIC_8 :
                    case Instructions.MERGE_VARIADIC :
                    case Instructions.CONSTANT_NULL :
                    case Instructions.INVALIDATE0 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE0);
                        bci += 2;
                        break;
                    case Instructions.LOAD_ARGUMENT :
                    case Instructions.LOAD_ARGUMENT$LONG :
                    case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    case Instructions.LOAD_EXCEPTION :
                    case Instructions.CLEAR_LOCAL :
                    case Instructions.INVALIDATE1 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE1);
                        bci += 4;
                        break;
                    case Instructions.POP :
                    case Instructions.POP$LONG :
                    case Instructions.POP$BOOLEAN :
                    case Instructions.POP$GENERIC :
                    case Instructions.BRANCH :
                    case Instructions.LOAD_CONSTANT :
                    case Instructions.LOAD_CONSTANT$LONG :
                    case Instructions.LOAD_CONSTANT$BOOLEAN :
                    case Instructions.LOAD_LOCAL :
                    case Instructions.LOAD_LOCAL$LONG :
                    case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL$BOOLEAN :
                    case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL$GENERIC :
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                    case Instructions.SL_ALWAYS_HALT_ :
                    case Instructions.SL_INVOKE_ :
                    case Instructions.SL_READ_PROPERTY_ :
                    case Instructions.SL_WRITE_PROPERTY_ :
                    case Instructions.SL_FUNCTION_LITERAL_ :
                    case Instructions.INVALIDATE2 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE2);
                        bci += 6;
                        break;
                    case Instructions.LOAD_LOCAL_MAT :
                    case Instructions.LOAD_LOCAL_MAT$LONG :
                    case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE3 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE3);
                        bci += 8;
                        break;
                    case Instructions.BRANCH_BACKWARD :
                    case Instructions.STORE_LOCAL :
                    case Instructions.STORE_LOCAL$LONG :
                    case Instructions.STORE_LOCAL$LONG$LONG :
                    case Instructions.STORE_LOCAL$BOOLEAN :
                    case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL$GENERIC :
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                    case Instructions.SL_LOAD_ARGUMENT_ :
                    case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                    case Instructions.SL_LOGICAL_NOT_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                    case Instructions.SL_UNBOX_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_UNBOX$FROM_LONG_ :
                    case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_AND_ :
                    case Instructions.SL_OR_ :
                    case Instructions.MERGE_CONDITIONAL :
                    case Instructions.MERGE_CONDITIONAL$LONG :
                    case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$GENERIC :
                    case Instructions.INVALIDATE4 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE4);
                        bci += 10;
                        break;
                    case Instructions.STORE_LOCAL_MAT :
                    case Instructions.STORE_LOCAL_MAT$LONG :
                    case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE5 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE5);
                        bci += 12;
                        break;
                    case Instructions.BRANCH_FALSE :
                    case Instructions.BRANCH_FALSE$GENERIC :
                    case Instructions.BRANCH_FALSE$BOOLEAN :
                    case Instructions.BUILTIN_ :
                    case Instructions.SL_ADD_ :
                    case Instructions.SL_ADD$LONG_ :
                    case Instructions.SL_ADD$LONG$UNBOXED_ :
                    case Instructions.SL_DIV_ :
                    case Instructions.SL_DIV$LONG_ :
                    case Instructions.SL_DIV$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL_ :
                    case Instructions.SL_EQUAL$LONG_ :
                    case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL$BOOLEAN_ :
                    case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_EQUAL$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                    case Instructions.SL_LESS_THAN_ :
                    case Instructions.SL_LESS_THAN$LONG_ :
                    case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_THAN$UNBOXED_ :
                    case Instructions.SL_MUL_ :
                    case Instructions.SL_MUL$LONG_ :
                    case Instructions.SL_MUL$LONG$UNBOXED_ :
                    case Instructions.SL_SUB_ :
                    case Instructions.SL_SUB$LONG_ :
                    case Instructions.SL_SUB$LONG$UNBOXED_ :
                    case Instructions.INVALIDATE6 :
                        BYTES.putShort(bc, bci, Instructions.INVALIDATE6);
                        bci += 14;
                        break;
                }
            }
            reportReplace(this, newNode, reason);
        }

        private final boolean validateBytecodes() {
            SLBytecodeRootNodeGen root;
            byte[] bc = this.bytecodes;
            if (bc == null) {
                // bc is null for serialization root nodes.
                return true;
            }
            Node[] cachedNodes = getCachedNodes();
            int[] branchProfiles = getBranchProfiles();
            int bci = 0;
            TagNode[] tagNodes = tagRoot != null ? tagRoot.tagNodes : null;
            if (bc.length == 0) {
                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: bytecode array must not be null%n%s", dumpInvalid(findLocation(bci))));
            }
            while (bci < bc.length) {
                try {
                    switch (BYTES.getShort(bc, bci)) {
                        case Instructions.POP :
                        case Instructions.POP$GENERIC :
                        {
                            int child0 = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
                            if (child0 < -1 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.POP$LONG :
                        case Instructions.POP$BOOLEAN :
                        {
                            int child0 = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.DUP :
                        case Instructions.RETURN :
                        case Instructions.THROW :
                        case Instructions.LOAD_NULL :
                        case Instructions.LOAD_VARIADIC_0 :
                        case Instructions.LOAD_VARIADIC_1 :
                        case Instructions.LOAD_VARIADIC_2 :
                        case Instructions.LOAD_VARIADIC_3 :
                        case Instructions.LOAD_VARIADIC_4 :
                        case Instructions.LOAD_VARIADIC_5 :
                        case Instructions.LOAD_VARIADIC_6 :
                        case Instructions.LOAD_VARIADIC_7 :
                        case Instructions.LOAD_VARIADIC_8 :
                        case Instructions.MERGE_VARIADIC :
                        case Instructions.CONSTANT_NULL :
                        case Instructions.INVALIDATE0 :
                        {
                            bci = bci + 2;
                            break;
                        }
                        case Instructions.BRANCH :
                        {
                            int branch_target = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                            if (branch_target < 0 || branch_target >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.BRANCH_BACKWARD :
                        {
                            int branch_target = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                            if (branch_target < 0 || branch_target >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int loop_header_branch_profile = BYTES.getIntUnaligned(bc, bci + 6 /* imm loop_header_branch_profile */);
                            if (branchProfiles != null) {
                                if (loop_header_branch_profile < 0 || loop_header_branch_profile >= branchProfiles.length) {
                                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. branch profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                                }
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.BRANCH_FALSE :
                        case Instructions.BRANCH_FALSE$GENERIC :
                        case Instructions.BRANCH_FALSE$BOOLEAN :
                        {
                            int branch_target = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                            if (branch_target < 0 || branch_target >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int branch_profile = BYTES.getIntUnaligned(bc, bci + 6 /* imm branch_profile */);
                            if (branchProfiles != null) {
                                if (branch_profile < 0 || branch_profile >= branchProfiles.length) {
                                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. branch profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                                }
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 10 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 14;
                            break;
                        }
                        case Instructions.STORE_LOCAL :
                        case Instructions.STORE_LOCAL$GENERIC :
                        {
                            short localOffset = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
                            root = this.getRoot();
                            if (localOffset < USER_LOCALS_START_INDEX || localOffset >= root.maxLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local offset is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
                            if (localIndex < 0 || localIndex >= root.numLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
                            if (child0 < -1 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.STORE_LOCAL$LONG :
                        case Instructions.STORE_LOCAL$LONG$LONG :
                        case Instructions.STORE_LOCAL$BOOLEAN :
                        case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                        {
                            short localOffset = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
                            root = this.getRoot();
                            if (localOffset < USER_LOCALS_START_INDEX || localOffset >= root.maxLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local offset is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
                            if (localIndex < 0 || localIndex >= root.numLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.LOAD_CONSTANT :
                        case Instructions.LOAD_CONSTANT$LONG :
                        case Instructions.LOAD_CONSTANT$BOOLEAN :
                        {
                            int constant = BYTES.getIntUnaligned(bc, bci + 2 /* imm constant */);
                            if (constant < 0 || constant >= constants.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. constant is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.LOAD_ARGUMENT :
                        case Instructions.LOAD_ARGUMENT$LONG :
                        case Instructions.LOAD_ARGUMENT$BOOLEAN :
                        {
                            short index = BYTES.getShort(bc, bci + 2 /* imm index */);
                            bci = bci + 4;
                            break;
                        }
                        case Instructions.LOAD_EXCEPTION :
                        {
                            short exceptionSp = BYTES.getShort(bc, bci + 2 /* imm exceptionSp */);
                            root = this.getRoot();
                            int maxStackHeight = root.getFrameDescriptor().getNumberOfSlots() - root.maxLocals;
                            if (exceptionSp < 0 || exceptionSp > maxStackHeight) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. stack pointer is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 4;
                            break;
                        }
                        case Instructions.LOAD_LOCAL :
                        case Instructions.LOAD_LOCAL$LONG :
                        case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                        case Instructions.LOAD_LOCAL$BOOLEAN :
                        case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                        case Instructions.LOAD_LOCAL$GENERIC :
                        {
                            short localOffset = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
                            root = this.getRoot();
                            if (localOffset < USER_LOCALS_START_INDEX || localOffset >= root.maxLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local offset is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
                            if (localIndex < 0 || localIndex >= root.numLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT :
                        case Instructions.LOAD_LOCAL_MAT$LONG :
                        case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                        case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                        case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                        case Instructions.LOAD_LOCAL_MAT$GENERIC :
                        {
                            short localOffset = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
                            root = this.getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */));
                            if (localOffset < USER_LOCALS_START_INDEX || localOffset >= root.maxLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local offset is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
                            if (localIndex < 0 || localIndex >= root.numLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short rootIndex = BYTES.getShort(bc, bci + 6 /* imm rootIndex */);
                            bci = bci + 8;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT :
                        case Instructions.STORE_LOCAL_MAT$LONG :
                        case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                        case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                        case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                        case Instructions.STORE_LOCAL_MAT$GENERIC :
                        {
                            short localOffset = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
                            root = this.getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */));
                            if (localOffset < USER_LOCALS_START_INDEX || localOffset >= root.maxLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local offset is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
                            if (localIndex < 0 || localIndex >= root.numLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            short rootIndex = BYTES.getShort(bc, bci + 6 /* imm rootIndex */);
                            int child0 = BYTES.getIntUnaligned(bc, bci + 8 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 12;
                            break;
                        }
                        case Instructions.TAG_ENTER :
                        case Instructions.TAG_LEAVE_VOID :
                        {
                            int tag = BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */);
                            if (tagNodes != null) {
                                TagNode node = tagRoot.tagNodes[tag];
                                if (node == null) {
                                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. tagNode is null%n%s", bci, dumpInvalid(findLocation(bci))));
                                }
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.TAG_LEAVE :
                        case Instructions.TAG_LEAVE$LONG :
                        case Instructions.TAG_LEAVE$LONG$UNBOXED :
                        case Instructions.TAG_LEAVE$BOOLEAN :
                        case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                        case Instructions.TAG_LEAVE$GENERIC :
                        {
                            int tag = BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */);
                            if (tagNodes != null) {
                                TagNode node = tagRoot.tagNodes[tag];
                                if (node == null) {
                                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. tagNode is null%n%s", bci, dumpInvalid(findLocation(bci))));
                                }
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.CLEAR_LOCAL :
                        {
                            short localOffset = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
                            root = this.getRoot();
                            if (localOffset < USER_LOCALS_START_INDEX || localOffset >= root.maxLocals) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. local offset is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 4;
                            break;
                        }
                        case Instructions.SL_ALWAYS_HALT_ :
                        case Instructions.SL_INVOKE_ :
                        case Instructions.SL_READ_PROPERTY_ :
                        case Instructions.SL_WRITE_PROPERTY_ :
                        case Instructions.SL_FUNCTION_LITERAL_ :
                        {
                            int node = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                            if (node < 0 || node >= numNodes) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. node profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.SL_LOAD_ARGUMENT_ :
                        case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                        {
                            int index = BYTES.getIntUnaligned(bc, bci + 2 /* imm index */);
                            if (index < 0 || index >= constants.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. constant is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int node = BYTES.getIntUnaligned(bc, bci + 6 /* imm node */);
                            if (node < 0 || node >= numNodes) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. node profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.BUILTIN_ :
                        {
                            int builtin = BYTES.getIntUnaligned(bc, bci + 2 /* imm builtin */);
                            if (builtin < 0 || builtin >= constants.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. constant is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int argumentCount = BYTES.getIntUnaligned(bc, bci + 6 /* imm argumentCount */);
                            if (argumentCount < 0 || argumentCount >= constants.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. constant is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int node = BYTES.getIntUnaligned(bc, bci + 10 /* imm node */);
                            if (node < 0 || node >= numNodes) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. node profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 14;
                            break;
                        }
                        case Instructions.SL_ADD_ :
                        case Instructions.SL_ADD$LONG_ :
                        case Instructions.SL_ADD$LONG$UNBOXED_ :
                        case Instructions.SL_DIV_ :
                        case Instructions.SL_DIV$LONG_ :
                        case Instructions.SL_DIV$LONG$UNBOXED_ :
                        case Instructions.SL_EQUAL_ :
                        case Instructions.SL_EQUAL$LONG_ :
                        case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                        case Instructions.SL_EQUAL$BOOLEAN_ :
                        case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                        case Instructions.SL_EQUAL$UNBOXED_ :
                        case Instructions.SL_LESS_OR_EQUAL_ :
                        case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                        case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                        case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                        case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                        case Instructions.SL_LESS_THAN_ :
                        case Instructions.SL_LESS_THAN$LONG_ :
                        case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                        case Instructions.SL_LESS_THAN$UNBOXED_ :
                        case Instructions.SL_MUL_ :
                        case Instructions.SL_MUL$LONG_ :
                        case Instructions.SL_MUL$LONG$UNBOXED_ :
                        case Instructions.SL_SUB_ :
                        case Instructions.SL_SUB$LONG_ :
                        case Instructions.SL_SUB$LONG$UNBOXED_ :
                        {
                            int node = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                            if (node < 0 || node >= numNodes) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. node profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child1 = BYTES.getIntUnaligned(bc, bci + 10 /* imm child1 */);
                            if (child1 < 0 || child1 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 14;
                            break;
                        }
                        case Instructions.SL_LOGICAL_NOT_ :
                        case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                        case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                        case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                        case Instructions.SL_UNBOX_ :
                        case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                        case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                        case Instructions.SL_UNBOX$FROM_LONG_ :
                        case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                        case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                        case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                        case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                        {
                            int node = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                            if (node < 0 || node >= numNodes) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. node profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.SL_TO_BOOLEAN_ :
                        {
                            int node = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                            if (node < 0 || node >= numNodes) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. node profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child0 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
                            if (child0 < -1 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.SL_AND_ :
                        case Instructions.SL_OR_ :
                        {
                            int branch_target = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                            if (branch_target < 0 || branch_target >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int branch_profile = BYTES.getIntUnaligned(bc, bci + 6 /* imm branch_profile */);
                            if (branchProfiles != null) {
                                if (branch_profile < 0 || branch_profile >= branchProfiles.length) {
                                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. branch profile is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                                }
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL :
                        case Instructions.MERGE_CONDITIONAL$GENERIC :
                        {
                            int child0 = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
                            if (child0 < -1 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child1 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child1 */);
                            if (child1 < -1 || child1 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL$LONG :
                        case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                        case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                        case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                        {
                            int child0 = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
                            if (child0 < 0 || child0 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            int child1 = BYTES.getIntUnaligned(bc, bci + 6 /* imm child1 */);
                            if (child1 < 0 || child1 >= bc.length) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error at index: %s. bytecode index is out of bounds%n%s", bci, dumpInvalid(findLocation(bci))));
                            }
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.INVALIDATE1 :
                        {
                            short invalidated0 = BYTES.getShort(bc, bci + 2 /* imm invalidated0 */);
                            bci = bci + 4;
                            break;
                        }
                        case Instructions.INVALIDATE2 :
                        {
                            short invalidated0 = BYTES.getShort(bc, bci + 2 /* imm invalidated0 */);
                            short invalidated1 = BYTES.getShort(bc, bci + 4 /* imm invalidated1 */);
                            bci = bci + 6;
                            break;
                        }
                        case Instructions.INVALIDATE3 :
                        {
                            short invalidated0 = BYTES.getShort(bc, bci + 2 /* imm invalidated0 */);
                            short invalidated1 = BYTES.getShort(bc, bci + 4 /* imm invalidated1 */);
                            short invalidated2 = BYTES.getShort(bc, bci + 6 /* imm invalidated2 */);
                            bci = bci + 8;
                            break;
                        }
                        case Instructions.INVALIDATE4 :
                        {
                            short invalidated0 = BYTES.getShort(bc, bci + 2 /* imm invalidated0 */);
                            short invalidated1 = BYTES.getShort(bc, bci + 4 /* imm invalidated1 */);
                            short invalidated2 = BYTES.getShort(bc, bci + 6 /* imm invalidated2 */);
                            short invalidated3 = BYTES.getShort(bc, bci + 8 /* imm invalidated3 */);
                            bci = bci + 10;
                            break;
                        }
                        case Instructions.INVALIDATE5 :
                        {
                            short invalidated0 = BYTES.getShort(bc, bci + 2 /* imm invalidated0 */);
                            short invalidated1 = BYTES.getShort(bc, bci + 4 /* imm invalidated1 */);
                            short invalidated2 = BYTES.getShort(bc, bci + 6 /* imm invalidated2 */);
                            short invalidated3 = BYTES.getShort(bc, bci + 8 /* imm invalidated3 */);
                            short invalidated4 = BYTES.getShort(bc, bci + 10 /* imm invalidated4 */);
                            bci = bci + 12;
                            break;
                        }
                        case Instructions.INVALIDATE6 :
                        {
                            short invalidated0 = BYTES.getShort(bc, bci + 2 /* imm invalidated0 */);
                            short invalidated1 = BYTES.getShort(bc, bci + 4 /* imm invalidated1 */);
                            short invalidated2 = BYTES.getShort(bc, bci + 6 /* imm invalidated2 */);
                            short invalidated3 = BYTES.getShort(bc, bci + 8 /* imm invalidated3 */);
                            short invalidated4 = BYTES.getShort(bc, bci + 10 /* imm invalidated4 */);
                            short invalidated5 = BYTES.getShort(bc, bci + 12 /* imm invalidated5 */);
                            bci = bci + 14;
                            break;
                        }
                        default :
                            throw CompilerDirectives.shouldNotReachHere("Invalid BCI at index: " + bci);
                    }
                } catch (AssertionError e) {
                    throw e;
                } catch (Throwable e) {
                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error:%n%s", dumpInvalid(findLocation(bci))), e);
                }
            }
            int[] ex = this.handlers;
            if (ex.length % EXCEPTION_HANDLER_LENGTH != 0) {
                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: exception handler table size is incorrect%n%s", dumpInvalid(findLocation(bci))));
            }
            for (int i = 0; i < ex.length; i = i + EXCEPTION_HANDLER_LENGTH) {
                int startBci = ex[i + EXCEPTION_HANDLER_OFFSET_START_BCI];
                int endBci = ex[i + EXCEPTION_HANDLER_OFFSET_END_BCI];
                int handlerKind = ex[i + EXCEPTION_HANDLER_OFFSET_KIND];
                int handlerBci = ex[i + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
                int handlerSp = ex[i + EXCEPTION_HANDLER_OFFSET_HANDLER_SP];
                if (startBci < 0 || startBci >= bc.length) {
                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: exception handler startBci is out of bounds%n%s", dumpInvalid(findLocation(bci))));
                }
                if (endBci < 0 || endBci > bc.length) {
                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: exception handler endBci is out of bounds%n%s", dumpInvalid(findLocation(bci))));
                }
                if (startBci > endBci) {
                    throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: exception handler bci range is malformed%n%s", dumpInvalid(findLocation(bci))));
                }
                switch (handlerKind) {
                    case HANDLER_TAG_EXCEPTIONAL :
                        if (tagNodes != null) {
                            TagNode node = tagRoot.tagNodes[handlerBci];
                            if (node == null) {
                                throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: tagNode is null%n%s", dumpInvalid(findLocation(bci))));
                            }
                        }
                        break;
                    default :
                        if (handlerKind != HANDLER_CUSTOM) {
                            throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: unexpected handler kind%n%s", dumpInvalid(findLocation(bci))));
                        }
                        if (handlerBci < 0 || handlerBci >= bc.length) {
                            throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: exception handler handlerBci is out of bounds%n%s", dumpInvalid(findLocation(bci))));
                        }
                        break;
                }
            }
            int[] info = this.sourceInfo;
            List<Source> localSources = this.sources;
            if (info != null) {
                for (int i = 0; i < info.length; i += SOURCE_INFO_LENGTH) {
                    int startBci = info[i + SOURCE_INFO_OFFSET_START_BCI];
                    int endBci = info[i + SOURCE_INFO_OFFSET_END_BCI];
                    int sourceIndex = info[i + SOURCE_INFO_OFFSET_SOURCE];
                    if (startBci > endBci) {
                        throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: source bci range is malformed%n%s", dumpInvalid(findLocation(bci))));
                    } else if (sourceIndex < 0 || sourceIndex > localSources.size()) {
                        throw CompilerDirectives.shouldNotReachHere(String.format("Bytecode validation error: source index is out of bounds%n%s", dumpInvalid(findLocation(bci))));
                    }
                }
            }
            return true;
        }

        private final String dumpInvalid(BytecodeLocation highlightedLocation) {
            try {
                return dump(highlightedLocation);
            } catch (Throwable t) {
                return "<dump error>";
            }
        }

        abstract AbstractBytecodeNode cloneUninitialized();

        abstract Node[] getCachedNodes();

        abstract byte[] getLocalTags();

        abstract int[] getBranchProfiles();

        @Override
        @TruffleBoundary
        public SourceSection getSourceSection() {
            int[] info = this.sourceInfo;
            if (info == null) {
                return null;
            }
            // The source table encodes a preorder traversal of a logical tree of source sections (with entries in reverse).
            // The most specific source section corresponds to the "lowest" node in the tree that covers the whole bytecode range.
            // We find this node by iterating the entries from the root until we hit a node that does not cover the bytecode range.
            int mostSpecific = -1;
            for (int i = info.length - SOURCE_INFO_LENGTH; i >= 0; i -= SOURCE_INFO_LENGTH) {
                if (info[i + SOURCE_INFO_OFFSET_START_BCI] != 0 ||
                    info[i + SOURCE_INFO_OFFSET_END_BCI] != bytecodes.length) {
                    break;
                }
                mostSpecific = i;
            }
            if (mostSpecific != -1) {
                return createSourceSection(sources, info, mostSpecific);
            }
            return null;
        }

        @Override
        public final SourceSection getSourceLocation(int bci) {
            assert validateBytecodeIndex(bci);
            int[] info = this.sourceInfo;
            if (info == null) {
                return null;
            }
            for (int i = 0; i < info.length; i += SOURCE_INFO_LENGTH) {
                int startBci = info[i + SOURCE_INFO_OFFSET_START_BCI];
                int endBci = info[i + SOURCE_INFO_OFFSET_END_BCI];
                if (startBci <= bci && bci < endBci) {
                    return createSourceSection(sources, info, i);
                }
            }
            return null;
        }

        @Override
        public final SourceSection[] getSourceLocations(int bci) {
            assert validateBytecodeIndex(bci);
            int[] info = this.sourceInfo;
            if (info == null) {
                return null;
            }
            int sectionIndex = 0;
            SourceSection[] sections = new SourceSection[8];
            for (int i = 0; i < info.length; i += SOURCE_INFO_LENGTH) {
                int startBci = info[i + SOURCE_INFO_OFFSET_START_BCI];
                int endBci = info[i + SOURCE_INFO_OFFSET_END_BCI];
                if (startBci <= bci && bci < endBci) {
                    if (sectionIndex == sections.length) {
                        sections = Arrays.copyOf(sections, Math.min(sections.length * 2, info.length / SOURCE_INFO_LENGTH));
                    }
                    sections[sectionIndex++] = createSourceSection(sources, info, i);
                }
            }
            return Arrays.copyOf(sections, sectionIndex);
        }

        @Override
        protected Instruction findInstruction(int bci) {
            return new InstructionImpl(this, bci, readValidBytecode(this.bytecodes, bci));
        }

        @Override
        protected boolean validateBytecodeIndex(int bci) {
            byte[] bc = this.bytecodes;
            if (bci < 0 || bci >= bc.length) {
                throw new IllegalArgumentException("Bytecode index out of range " + bci);
            }
            int op = readValidBytecode(bc, bci);
            if (op < 0 || op > 127) {
                throw new IllegalArgumentException("Invalid op at bytecode index " + op);
            }
            return true;
        }

        @Override
        public List<SourceInformation> getSourceInformation() {
            if (sourceInfo == null) {
                return null;
            }
            return new SourceInformationList(this);
        }

        @Override
        public boolean hasSourceInformation() {
            return sourceInfo != null;
        }

        @Override
        public SourceInformationTree getSourceInformationTree() {
            if (sourceInfo == null) {
                return null;
            }
            return SourceInformationTreeImpl.parse(this);
        }

        @Override
        public List<ExceptionHandler> getExceptionHandlers() {
            return new ExceptionHandlerList(this);
        }

        @Override
        public TagTree getTagTree() {
            if (this.tagRoot == null) {
                return null;
            }
            return this.tagRoot.root;
        }

        @Override
        @ExplodeLoop
        public final int getLocalCount(int bci) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            int count = 0;
            for (int index = 0; index < locals.length; index += LOCALS_LENGTH) {
                int startIndex = locals[index + LOCALS_OFFSET_START_BCI];
                int endIndex = locals[index + LOCALS_OFFSET_END_BCI];
                if (bci >= startIndex && bci < endIndex) {
                    count++;
                }
            }
            CompilerAsserts.partialEvaluationConstant(count);
            return count;
        }

        @Override
        public final Object getLocalValue(int bci, Frame frame, int localOffset) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            int frameIndex = USER_LOCALS_START_INDEX + localOffset;
            try {
                FrameSlotKind kind;
                if (CompilerDirectives.inInterpreter()) {
                    // Resolving the local index is expensive. Don't do it in the interpreter.
                    kind = FrameSlotKind.fromTag(frame.getTag(frameIndex));
                } else {
                    kind = getCachedLocalKind(frame, frameIndex, bci, localOffset);
                }
                switch (kind) {
                    case Long :
                        return frame.expectLong(frameIndex);
                    case Boolean :
                        return frame.expectBoolean(frameIndex);
                    case Object :
                        return frame.expectObject(frameIndex);
                    case Illegal :
                        return frame.getFrameDescriptor().getDefaultValue();
                    default :
                        throw CompilerDirectives.shouldNotReachHere("unexpected slot");
                }
            } catch (UnexpectedResultException ex) {
                return ex.getResult();
            }
        }

        @Override
        public void setLocalValue(int bci, Frame frame, int localOffset, Object value) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            int frameIndex = USER_LOCALS_START_INDEX + localOffset;
            setLocalValueImpl(frame, frameIndex, value, bci, localOffset);
        }

        private void setLocalValueImpl(Frame frame, int frameIndex, Object value, int bci, int localOffset) {
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            FrameSlotKind oldKind = getCachedLocalKind(frame, frameIndex, bci, localOffset);
            FrameSlotKind newKind;
            switch (oldKind) {
                case Long :
                    if (value instanceof Long longValue) {
                        frame.setLong(frameIndex, longValue);
                        return;
                    } else {
                        newKind = FrameSlotKind.Object;
                    }
                    break;
                case Boolean :
                    if (value instanceof Boolean booleanValue) {
                        frame.setBoolean(frameIndex, booleanValue);
                        return;
                    } else {
                        newKind = FrameSlotKind.Object;
                    }
                    break;
                case Object :
                    frame.setObject(frameIndex, value);
                    return;
                default :
                    newKind = specializeSlotKind(value);
                    break;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            setCachedLocalKind(frameIndex, newKind, bci, localOffset);
            setLocalValueImpl(frame, frameIndex, value, bci, localOffset);
        }

        @Override
        public final long getLocalValueLong(int bci, Frame frame, int localOffset) throws UnexpectedResultException {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            int frameIndex = USER_LOCALS_START_INDEX + localOffset;
            return frame.expectLong(frameIndex);
        }

        @Override
        public void setLocalValueLong(int bci, Frame frame, int localOffset, long value) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            int frameIndex = USER_LOCALS_START_INDEX + localOffset;
            setLocalValueLongImpl(frame, frameIndex, value, bci, localOffset);
        }

        private void setLocalValueLongImpl(Frame frame, int frameIndex, long value, int bci, int localOffset) {
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            FrameSlotKind oldKind = getCachedLocalKind(frame, frameIndex, bci, localOffset);
            FrameSlotKind newKind;
            switch (oldKind) {
                case Long :
                    frame.setLong(frameIndex, value);
                    return;
                case Object :
                    frame.setObject(frameIndex, value);
                    return;
                default :
                    newKind = specializeSlotKind(value);
                    break;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            setCachedLocalKind(frameIndex, newKind, bci, localOffset);
            setLocalValueImpl(frame, frameIndex, value, bci, localOffset);
        }

        @Override
        public final boolean getLocalValueBoolean(int bci, Frame frame, int localOffset) throws UnexpectedResultException {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            int frameIndex = USER_LOCALS_START_INDEX + localOffset;
            return frame.expectBoolean(frameIndex);
        }

        @Override
        public void setLocalValueBoolean(int bci, Frame frame, int localOffset, boolean value) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            int frameIndex = USER_LOCALS_START_INDEX + localOffset;
            setLocalValueBooleanImpl(frame, frameIndex, value, bci, localOffset);
        }

        private void setLocalValueBooleanImpl(Frame frame, int frameIndex, boolean value, int bci, int localOffset) {
            assert getRoot().getFrameDescriptor() == frame.getFrameDescriptor() : "Invalid frame with invalid descriptor passed.";
            FrameSlotKind oldKind = getCachedLocalKind(frame, frameIndex, bci, localOffset);
            FrameSlotKind newKind;
            switch (oldKind) {
                case Boolean :
                    frame.setBoolean(frameIndex, value);
                    return;
                case Object :
                    frame.setObject(frameIndex, value);
                    return;
                default :
                    newKind = specializeSlotKind(value);
                    break;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            setCachedLocalKind(frameIndex, newKind, bci, localOffset);
            setLocalValueImpl(frame, frameIndex, value, bci, localOffset);
        }

        final FrameSlotKind getCachedLocalKind(Frame frame, int frameIndex, int bci, int localOffset) {
            assert locals[localOffsetToTableIndex(bci, localOffset) + LOCALS_OFFSET_FRAME_INDEX] == frameIndex : "Inconsistent indices.";
            byte[] localTags = getLocalTags();
            if (localTags == null) {
                // bytecode not yet cached.
                return FrameSlotKind.Object;
            } else {
                int localIndex = locals[localOffsetToTableIndex(bci, localOffset) + LOCALS_OFFSET_LOCAL_INDEX];
                return FrameSlotKind.fromTag(localTags[localIndex]);
            }
        }

        final FrameSlotKind getCachedLocalKindInternal(int frameIndex, int localIndex) {
            byte[] localTags = getLocalTags();
            if (localTags == null) {
                // bytecode not yet cached.
                return FrameSlotKind.Object;
            } else {
                return FrameSlotKind.fromTag(localTags[localIndex]);
            }
        }

        private void setCachedLocalKind(int frameIndex, FrameSlotKind kind, int bci, int localOffset) {
            assert locals[localOffsetToTableIndex(bci, localOffset) + LOCALS_OFFSET_FRAME_INDEX] == frameIndex : "Inconsistent indices.";
            byte[] localTags = getLocalTags();
            if (localTags == null) {
                // bytecode not yet cached.
                return;
            } else {
                int localIndex = locals[localOffsetToTableIndex(bci, localOffset) + LOCALS_OFFSET_LOCAL_INDEX];
                localTags[localIndex] = kind.tag;
            }
        }

        final void setCachedLocalKindInternal(int frameIndex, FrameSlotKind kind, int localIndex) {
            byte[] localTags = getLocalTags();
            if (localTags == null) {
                // bytecode node not yet cached.
                return;
            } else {
                localTags[localIndex] = kind.tag;
            }
        }

        @ExplodeLoop
        private int localOffsetToTableIndex(int bci, int localOffset) {
            int count = 0;
            for (int index = 0; index < locals.length; index += LOCALS_LENGTH) {
                int startIndex = locals[index + LOCALS_OFFSET_START_BCI];
                int endIndex = locals[index + LOCALS_OFFSET_END_BCI];
                if (bci >= startIndex && bci < endIndex) {
                    if (count == localOffset) {
                        return index;
                    }
                    count++;
                }
            }
            return -1;
        }

        @ExplodeLoop
        private int localIndexToTableIndex(int bci, int localIndex) {
            for (int index = 0; index < locals.length; index += LOCALS_LENGTH) {
                int startIndex = locals[index + LOCALS_OFFSET_START_BCI];
                int endIndex = locals[index + LOCALS_OFFSET_END_BCI];
                if (bci >= startIndex && bci < endIndex) {
                    if (locals[index + LOCALS_OFFSET_LOCAL_INDEX] == localIndex) {
                        return index;
                    }
                }
            }
            return -1;
        }

        @Override
        public Object getLocalName(int bci, int localOffset) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            int index = localOffsetToTableIndex(bci, localOffset);
            if (index == -1) {
                return null;
            }
            int nameId = locals[index + LOCALS_OFFSET_NAME];
            if (nameId == -1) {
                return null;
            } else {
                return ACCESS.readObject(constants, nameId);
            }
        }

        @Override
        public Object getLocalInfo(int bci, int localOffset) {
            assert validateBytecodeIndex(bci);
            CompilerAsserts.partialEvaluationConstant(bci);
            CompilerAsserts.partialEvaluationConstant(localOffset);
            assert localOffset >= 0 && localOffset < getLocalCount(bci) : "Invalid out-of-bounds local offset provided.";
            int index = localOffsetToTableIndex(bci, localOffset);
            if (index == -1) {
                return null;
            }
            int infoId = locals[index + LOCALS_OFFSET_INFO];
            if (infoId == -1) {
                return null;
            } else {
                return ACCESS.readObject(constants, infoId);
            }
        }

        @Override
        public List<LocalVariable> getLocals() {
            return new LocalVariableList(this);
        }

        private TagNode[] getTagNodes() {
            return tagRoot != null ? tagRoot.tagNodes : null;
        }

        @Override
        protected int translateBytecodeIndex(BytecodeNode newNode, int bytecodeIndex) {
            return (int) (transitionState((AbstractBytecodeNode) newNode, (bytecodeIndex & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
        }

        final long transitionState(AbstractBytecodeNode newBytecode, long state) {
            byte[] oldBc = this.oldBytecodes;
            byte[] newBc = newBytecode.bytecodes;
            if (oldBc == null || this == newBytecode || this.bytecodes == newBc) {
                // No change in bytecodes.
                return state;
            }
            int oldBci = (int) (state & 0xFFFFFFFFL);
            int newBci = computeNewBci(oldBci, oldBc, newBc, this.getTagNodes(), newBytecode.getTagNodes());
            return (state & 0xFFFFFFFF00000000L) | (newBci & 0xFFFFFFFFL);
        }

        public void adoptNodesAfterUpdate() {
            // no nodes to adopt
        }

        static BytecodeLocation findLocation(AbstractBytecodeNode node, int bci) {
            return node.findLocation(bci);
        }

        private static SourceSection createSourceSection(List<Source> sources, int[] info, int index) {
            int sourceIndex = info[index + SOURCE_INFO_OFFSET_SOURCE];
            int start = info[index + SOURCE_INFO_OFFSET_START];
            int length = info[index + SOURCE_INFO_OFFSET_LENGTH];
            if (start == -1 && length == -1) {
                return sources.get(sourceIndex).createUnavailableSection();
            }
            assert start >= 0 : "invalid source start index";
            assert length >= 0 : "invalid source length";
            return sources.get(sourceIndex).createSection(start, length);
        }

        private static FrameSlotKind specializeSlotKind(Object value) {
            if (value instanceof Long) {
                return FrameSlotKind.Long;
            } else if (value instanceof Boolean) {
                return FrameSlotKind.Boolean;
            } else {
                return FrameSlotKind.Object;
            }
        }

        private static int toStableBytecodeIndex(byte[] bc, int searchBci) {
            int bci = 0;
            int stableBci = 0;
            while (bci != searchBci && bci < bc.length) {
                switch (BYTES.getShort(bc, bci)) {
                    case Instructions.DUP :
                    case Instructions.RETURN :
                    case Instructions.THROW :
                    case Instructions.LOAD_NULL :
                    case Instructions.LOAD_VARIADIC_0 :
                    case Instructions.LOAD_VARIADIC_1 :
                    case Instructions.LOAD_VARIADIC_2 :
                    case Instructions.LOAD_VARIADIC_3 :
                    case Instructions.LOAD_VARIADIC_4 :
                    case Instructions.LOAD_VARIADIC_5 :
                    case Instructions.LOAD_VARIADIC_6 :
                    case Instructions.LOAD_VARIADIC_7 :
                    case Instructions.LOAD_VARIADIC_8 :
                    case Instructions.MERGE_VARIADIC :
                    case Instructions.CONSTANT_NULL :
                    case Instructions.INVALIDATE0 :
                        bci += 2;
                        stableBci += 2;
                        break;
                    case Instructions.LOAD_ARGUMENT :
                    case Instructions.LOAD_ARGUMENT$LONG :
                    case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    case Instructions.LOAD_EXCEPTION :
                    case Instructions.CLEAR_LOCAL :
                    case Instructions.INVALIDATE1 :
                        bci += 4;
                        stableBci += 4;
                        break;
                    case Instructions.POP :
                    case Instructions.POP$LONG :
                    case Instructions.POP$BOOLEAN :
                    case Instructions.POP$GENERIC :
                    case Instructions.BRANCH :
                    case Instructions.LOAD_CONSTANT :
                    case Instructions.LOAD_CONSTANT$LONG :
                    case Instructions.LOAD_CONSTANT$BOOLEAN :
                    case Instructions.LOAD_LOCAL :
                    case Instructions.LOAD_LOCAL$LONG :
                    case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL$BOOLEAN :
                    case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL$GENERIC :
                    case Instructions.SL_ALWAYS_HALT_ :
                    case Instructions.SL_INVOKE_ :
                    case Instructions.SL_READ_PROPERTY_ :
                    case Instructions.SL_WRITE_PROPERTY_ :
                    case Instructions.SL_FUNCTION_LITERAL_ :
                    case Instructions.INVALIDATE2 :
                        bci += 6;
                        stableBci += 6;
                        break;
                    case Instructions.LOAD_LOCAL_MAT :
                    case Instructions.LOAD_LOCAL_MAT$LONG :
                    case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE3 :
                        bci += 8;
                        stableBci += 8;
                        break;
                    case Instructions.BRANCH_BACKWARD :
                    case Instructions.STORE_LOCAL :
                    case Instructions.STORE_LOCAL$LONG :
                    case Instructions.STORE_LOCAL$LONG$LONG :
                    case Instructions.STORE_LOCAL$BOOLEAN :
                    case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL$GENERIC :
                    case Instructions.SL_LOAD_ARGUMENT_ :
                    case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                    case Instructions.SL_LOGICAL_NOT_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                    case Instructions.SL_UNBOX_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_UNBOX$FROM_LONG_ :
                    case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_AND_ :
                    case Instructions.SL_OR_ :
                    case Instructions.MERGE_CONDITIONAL :
                    case Instructions.MERGE_CONDITIONAL$LONG :
                    case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$GENERIC :
                    case Instructions.INVALIDATE4 :
                        bci += 10;
                        stableBci += 10;
                        break;
                    case Instructions.STORE_LOCAL_MAT :
                    case Instructions.STORE_LOCAL_MAT$LONG :
                    case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE5 :
                        bci += 12;
                        stableBci += 12;
                        break;
                    case Instructions.BRANCH_FALSE :
                    case Instructions.BRANCH_FALSE$GENERIC :
                    case Instructions.BRANCH_FALSE$BOOLEAN :
                    case Instructions.BUILTIN_ :
                    case Instructions.SL_ADD_ :
                    case Instructions.SL_ADD$LONG_ :
                    case Instructions.SL_ADD$LONG$UNBOXED_ :
                    case Instructions.SL_DIV_ :
                    case Instructions.SL_DIV$LONG_ :
                    case Instructions.SL_DIV$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL_ :
                    case Instructions.SL_EQUAL$LONG_ :
                    case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL$BOOLEAN_ :
                    case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_EQUAL$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                    case Instructions.SL_LESS_THAN_ :
                    case Instructions.SL_LESS_THAN$LONG_ :
                    case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_THAN$UNBOXED_ :
                    case Instructions.SL_MUL_ :
                    case Instructions.SL_MUL$LONG_ :
                    case Instructions.SL_MUL$LONG$UNBOXED_ :
                    case Instructions.SL_SUB_ :
                    case Instructions.SL_SUB$LONG_ :
                    case Instructions.SL_SUB$LONG$UNBOXED_ :
                    case Instructions.INVALIDATE6 :
                        bci += 14;
                        stableBci += 14;
                        break;
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                        bci += 6;
                        break;
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                        bci += 10;
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Invalid bytecode.");
                }
            }
            if (bci >= bc.length) {
                throw CompilerDirectives.shouldNotReachHere("Could not translate bytecode index.");
            }
            return stableBci;
        }

        private static int fromStableBytecodeIndex(byte[] bc, int stableSearchBci) {
            int bci = 0;
            int stableBci = 0;
            while (stableBci != stableSearchBci && bci < bc.length) {
                switch (BYTES.getShort(bc, bci)) {
                    case Instructions.DUP :
                    case Instructions.RETURN :
                    case Instructions.THROW :
                    case Instructions.LOAD_NULL :
                    case Instructions.LOAD_VARIADIC_0 :
                    case Instructions.LOAD_VARIADIC_1 :
                    case Instructions.LOAD_VARIADIC_2 :
                    case Instructions.LOAD_VARIADIC_3 :
                    case Instructions.LOAD_VARIADIC_4 :
                    case Instructions.LOAD_VARIADIC_5 :
                    case Instructions.LOAD_VARIADIC_6 :
                    case Instructions.LOAD_VARIADIC_7 :
                    case Instructions.LOAD_VARIADIC_8 :
                    case Instructions.MERGE_VARIADIC :
                    case Instructions.CONSTANT_NULL :
                    case Instructions.INVALIDATE0 :
                        bci += 2;
                        stableBci += 2;
                        break;
                    case Instructions.LOAD_ARGUMENT :
                    case Instructions.LOAD_ARGUMENT$LONG :
                    case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    case Instructions.LOAD_EXCEPTION :
                    case Instructions.CLEAR_LOCAL :
                    case Instructions.INVALIDATE1 :
                        bci += 4;
                        stableBci += 4;
                        break;
                    case Instructions.POP :
                    case Instructions.POP$LONG :
                    case Instructions.POP$BOOLEAN :
                    case Instructions.POP$GENERIC :
                    case Instructions.BRANCH :
                    case Instructions.LOAD_CONSTANT :
                    case Instructions.LOAD_CONSTANT$LONG :
                    case Instructions.LOAD_CONSTANT$BOOLEAN :
                    case Instructions.LOAD_LOCAL :
                    case Instructions.LOAD_LOCAL$LONG :
                    case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL$BOOLEAN :
                    case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL$GENERIC :
                    case Instructions.SL_ALWAYS_HALT_ :
                    case Instructions.SL_INVOKE_ :
                    case Instructions.SL_READ_PROPERTY_ :
                    case Instructions.SL_WRITE_PROPERTY_ :
                    case Instructions.SL_FUNCTION_LITERAL_ :
                    case Instructions.INVALIDATE2 :
                        bci += 6;
                        stableBci += 6;
                        break;
                    case Instructions.LOAD_LOCAL_MAT :
                    case Instructions.LOAD_LOCAL_MAT$LONG :
                    case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE3 :
                        bci += 8;
                        stableBci += 8;
                        break;
                    case Instructions.BRANCH_BACKWARD :
                    case Instructions.STORE_LOCAL :
                    case Instructions.STORE_LOCAL$LONG :
                    case Instructions.STORE_LOCAL$LONG$LONG :
                    case Instructions.STORE_LOCAL$BOOLEAN :
                    case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL$GENERIC :
                    case Instructions.SL_LOAD_ARGUMENT_ :
                    case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                    case Instructions.SL_LOGICAL_NOT_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                    case Instructions.SL_UNBOX_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_UNBOX$FROM_LONG_ :
                    case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_AND_ :
                    case Instructions.SL_OR_ :
                    case Instructions.MERGE_CONDITIONAL :
                    case Instructions.MERGE_CONDITIONAL$LONG :
                    case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$GENERIC :
                    case Instructions.INVALIDATE4 :
                        bci += 10;
                        stableBci += 10;
                        break;
                    case Instructions.STORE_LOCAL_MAT :
                    case Instructions.STORE_LOCAL_MAT$LONG :
                    case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE5 :
                        bci += 12;
                        stableBci += 12;
                        break;
                    case Instructions.BRANCH_FALSE :
                    case Instructions.BRANCH_FALSE$GENERIC :
                    case Instructions.BRANCH_FALSE$BOOLEAN :
                    case Instructions.BUILTIN_ :
                    case Instructions.SL_ADD_ :
                    case Instructions.SL_ADD$LONG_ :
                    case Instructions.SL_ADD$LONG$UNBOXED_ :
                    case Instructions.SL_DIV_ :
                    case Instructions.SL_DIV$LONG_ :
                    case Instructions.SL_DIV$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL_ :
                    case Instructions.SL_EQUAL$LONG_ :
                    case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL$BOOLEAN_ :
                    case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_EQUAL$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                    case Instructions.SL_LESS_THAN_ :
                    case Instructions.SL_LESS_THAN$LONG_ :
                    case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_THAN$UNBOXED_ :
                    case Instructions.SL_MUL_ :
                    case Instructions.SL_MUL$LONG_ :
                    case Instructions.SL_MUL$LONG$UNBOXED_ :
                    case Instructions.SL_SUB_ :
                    case Instructions.SL_SUB$LONG_ :
                    case Instructions.SL_SUB$LONG$UNBOXED_ :
                    case Instructions.INVALIDATE6 :
                        bci += 14;
                        stableBci += 14;
                        break;
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                        bci += 6;
                        break;
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                        bci += 10;
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Invalid bytecode.");
                }
            }
            if (bci >= bc.length) {
                throw CompilerDirectives.shouldNotReachHere("Could not translate bytecode index.");
            }
            return bci;
        }

        private static int transitionInstrumentationIndex(byte[] oldBc, int oldBciBase, int oldBciTarget, byte[] newBc, int newBciBase, TagNode[] oldTagNodes, TagNode[] newTagNodes) {
            int oldBci = oldBciBase;
            int newBci = newBciBase;
            short searchOp = -1;
            int searchTags = -1;
            while (oldBci < oldBciTarget) {
                short op = BYTES.getShort(oldBc, oldBci);
                searchOp = op;
                switch (op) {
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                        searchTags = ACCESS.uncheckedCast(ACCESS.readObject(oldTagNodes, BYTES.getIntUnaligned(oldBc, oldBci + 2 /* imm tag */)), TagNode.class).tags;
                        oldBci += 6;
                        break;
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                        searchTags = ACCESS.uncheckedCast(ACCESS.readObject(oldTagNodes, BYTES.getIntUnaligned(oldBc, oldBci + 2 /* imm tag */)), TagNode.class).tags;
                        oldBci += 10;
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Unexpected bytecode.");
                }
            }
            assert searchOp != -1;
            oldBci = oldBciBase;
            int opCounter = 0;
            while (oldBci < oldBciTarget) {
                short op = BYTES.getShort(oldBc, oldBci);
                switch (op) {
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                    {
                        int opTags = ACCESS.uncheckedCast(ACCESS.readObject(oldTagNodes, BYTES.getIntUnaligned(oldBc, oldBci + 2 /* imm tag */)), TagNode.class).tags;
                        if (searchOp == op && searchTags == opTags) {
                            opCounter++;
                        }
                        oldBci += 6;
                        break;
                    }
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                    {
                        int opTags = ACCESS.uncheckedCast(ACCESS.readObject(oldTagNodes, BYTES.getIntUnaligned(oldBc, oldBci + 2 /* imm tag */)), TagNode.class).tags;
                        if (searchOp == op && searchTags == opTags) {
                            opCounter++;
                        }
                        oldBci += 10;
                        break;
                    }
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Unexpected bytecode.");
                }
            }
            assert opCounter > 0;
            while (opCounter > 0) {
                short op = BYTES.getShort(newBc, newBci);
                switch (op) {
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                    {
                        int opTags = ACCESS.uncheckedCast(ACCESS.readObject(newTagNodes, BYTES.getIntUnaligned(newBc, newBci + 2 /* imm tag */)), TagNode.class).tags;
                        if (searchOp == op && searchTags == opTags) {
                            opCounter--;
                        }
                        newBci += 6;
                        break;
                    }
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                    {
                        int opTags = ACCESS.uncheckedCast(ACCESS.readObject(newTagNodes, BYTES.getIntUnaligned(newBc, newBci + 2 /* imm tag */)), TagNode.class).tags;
                        if (searchOp == op && searchTags == opTags) {
                            opCounter--;
                        }
                        newBci += 10;
                        break;
                    }
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Unexpected bytecode.");
                }
            }
            return newBci;
        }

        static final int computeNewBci(int oldBci, byte[] oldBc, byte[] newBc, TagNode[] oldTagNodes, TagNode[] newTagNodes) {
            int stableBci = toStableBytecodeIndex(oldBc, oldBci);
            int newBci = fromStableBytecodeIndex(newBc, stableBci);
            int oldBciBase = fromStableBytecodeIndex(oldBc, stableBci);
            if (oldBci != oldBciBase) {
                // Transition within an in instrumentation bytecode.
                // Needs to compute exact location where to continue.
                newBci = transitionInstrumentationIndex(oldBc, oldBciBase, oldBci, newBc, newBci, oldTagNodes, newTagNodes);
            }
            return newBci;
        }

        private static Object createStackTraceElement(TruffleStackTraceElement stackTraceElement) {
            return createDefaultStackTraceElement(stackTraceElement);
        }

    }
    @DenyReplace
    private static final class CachedBytecodeNode extends AbstractBytecodeNode implements BytecodeOSRNode {

        private static final boolean[] EMPTY_EXCEPTION_PROFILES = new boolean[0];

        @CompilationFinal(dimensions = 1) private Node[] cachedNodes_;
        @CompilationFinal(dimensions = 1) private final boolean[] exceptionProfiles_;
        @CompilationFinal(dimensions = 1) private final byte[] localTags_;
        @CompilationFinal(dimensions = 1) private final int[] branchProfiles_;
        @CompilationFinal private Object osrMetadata_;

        CachedBytecodeNode(byte[] bytecodes, Object[] constants, int[] handlers, int[] locals, int[] sourceInfo, List<Source> sources, int numNodes, TagRootNode tagRoot, int numLocals) {
            super(bytecodes, constants, handlers, locals, sourceInfo, sources, numNodes, tagRoot);
            CompilerAsserts.neverPartOfCompilation();
            Node[] result = new Node[this.numNodes];
            byte[] bc = bytecodes;
            int bci = 0;
            int numConditionalBranches = 0;
            loop: while (bci < bc.length) {
                switch (BYTES.getShort(bc, bci)) {
                    case Instructions.DUP :
                    case Instructions.RETURN :
                    case Instructions.THROW :
                    case Instructions.LOAD_NULL :
                    case Instructions.LOAD_VARIADIC_0 :
                    case Instructions.LOAD_VARIADIC_1 :
                    case Instructions.LOAD_VARIADIC_2 :
                    case Instructions.LOAD_VARIADIC_3 :
                    case Instructions.LOAD_VARIADIC_4 :
                    case Instructions.LOAD_VARIADIC_5 :
                    case Instructions.LOAD_VARIADIC_6 :
                    case Instructions.LOAD_VARIADIC_7 :
                    case Instructions.LOAD_VARIADIC_8 :
                    case Instructions.MERGE_VARIADIC :
                    case Instructions.CONSTANT_NULL :
                    case Instructions.INVALIDATE0 :
                        bci += 2;
                        break;
                    case Instructions.LOAD_ARGUMENT :
                    case Instructions.LOAD_ARGUMENT$LONG :
                    case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    case Instructions.LOAD_EXCEPTION :
                    case Instructions.CLEAR_LOCAL :
                    case Instructions.INVALIDATE1 :
                        bci += 4;
                        break;
                    case Instructions.POP :
                    case Instructions.POP$LONG :
                    case Instructions.POP$BOOLEAN :
                    case Instructions.POP$GENERIC :
                    case Instructions.BRANCH :
                    case Instructions.LOAD_CONSTANT :
                    case Instructions.LOAD_CONSTANT$LONG :
                    case Instructions.LOAD_CONSTANT$BOOLEAN :
                    case Instructions.LOAD_LOCAL :
                    case Instructions.LOAD_LOCAL$LONG :
                    case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL$BOOLEAN :
                    case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL$GENERIC :
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                    case Instructions.INVALIDATE2 :
                        bci += 6;
                        break;
                    case Instructions.LOAD_LOCAL_MAT :
                    case Instructions.LOAD_LOCAL_MAT$LONG :
                    case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE3 :
                        bci += 8;
                        break;
                    case Instructions.BRANCH_BACKWARD :
                    case Instructions.STORE_LOCAL :
                    case Instructions.STORE_LOCAL$LONG :
                    case Instructions.STORE_LOCAL$LONG$LONG :
                    case Instructions.STORE_LOCAL$BOOLEAN :
                    case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL$GENERIC :
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                    case Instructions.MERGE_CONDITIONAL :
                    case Instructions.MERGE_CONDITIONAL$LONG :
                    case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$GENERIC :
                    case Instructions.INVALIDATE4 :
                        bci += 10;
                        break;
                    case Instructions.STORE_LOCAL_MAT :
                    case Instructions.STORE_LOCAL_MAT$LONG :
                    case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE5 :
                        bci += 12;
                        break;
                    case Instructions.INVALIDATE6 :
                        bci += 14;
                        break;
                    case Instructions.SL_ALWAYS_HALT_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLAlwaysHalt_Node());
                        bci += 6;
                        break;
                    case Instructions.SL_INVOKE_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLInvoke_Node());
                        bci += 6;
                        break;
                    case Instructions.SL_READ_PROPERTY_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLReadProperty_Node());
                        bci += 6;
                        break;
                    case Instructions.SL_WRITE_PROPERTY_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLWriteProperty_Node());
                        bci += 6;
                        break;
                    case Instructions.SL_FUNCTION_LITERAL_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLFunctionLiteral_Node());
                        bci += 6;
                        break;
                    case Instructions.SL_LOAD_ARGUMENT_ :
                    case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                        result[BYTES.getIntUnaligned(bc, bci + 6 /* imm node */)] = insert(new SLLoadArgument_Node());
                        bci += 10;
                        break;
                    case Instructions.SL_LOGICAL_NOT_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLLogicalNot_Node());
                        bci += 10;
                        break;
                    case Instructions.SL_UNBOX_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_UNBOX$FROM_LONG_ :
                    case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLUnbox_Node());
                        bci += 10;
                        break;
                    case Instructions.SL_TO_BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLToBoolean_Node());
                        bci += 10;
                        break;
                    case Instructions.BUILTIN_ :
                        result[BYTES.getIntUnaligned(bc, bci + 10 /* imm node */)] = insert(new Builtin_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_ADD_ :
                    case Instructions.SL_ADD$LONG_ :
                    case Instructions.SL_ADD$LONG$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLAdd_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_DIV_ :
                    case Instructions.SL_DIV$LONG_ :
                    case Instructions.SL_DIV$LONG$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLDiv_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_EQUAL_ :
                    case Instructions.SL_EQUAL$LONG_ :
                    case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL$BOOLEAN_ :
                    case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_EQUAL$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLEqual_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_LESS_OR_EQUAL_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLLessOrEqual_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_LESS_THAN_ :
                    case Instructions.SL_LESS_THAN$LONG_ :
                    case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_THAN$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLLessThan_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_MUL_ :
                    case Instructions.SL_MUL$LONG_ :
                    case Instructions.SL_MUL$LONG$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLMul_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_SUB_ :
                    case Instructions.SL_SUB$LONG_ :
                    case Instructions.SL_SUB$LONG$UNBOXED_ :
                        result[BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)] = insert(new SLSub_Node());
                        bci += 14;
                        break;
                    case Instructions.SL_AND_ :
                    case Instructions.SL_OR_ :
                        numConditionalBranches++;
                        bci += 10;
                        break;
                    case Instructions.BRANCH_FALSE :
                    case Instructions.BRANCH_FALSE$GENERIC :
                    case Instructions.BRANCH_FALSE$BOOLEAN :
                        numConditionalBranches++;
                        bci += 14;
                        break;
                    default :
                    {
                        throw assertionFailed("Should not reach here");
                    }
                }
            }
            assert bci == bc.length;
            this.cachedNodes_ = result;
            this.branchProfiles_ = allocateBranchProfiles(numConditionalBranches);
            this.exceptionProfiles_ = handlers.length == 0 ? EMPTY_EXCEPTION_PROFILES : new boolean[handlers.length / 5];
            byte[] localTags = new byte[numLocals];
            Arrays.fill(localTags, FrameSlotKind.Illegal.tag);
            this.localTags_ = localTags;
        }

        CachedBytecodeNode(byte[] bytecodes, Object[] constants, int[] handlers, int[] locals, int[] sourceInfo, List<Source> sources, int numNodes, TagRootNode tagRoot, Node[] cachedNodes_, boolean[] exceptionProfiles_, byte[] localTags_, int[] branchProfiles_, Object osrMetadata_) {
            super(bytecodes, constants, handlers, locals, sourceInfo, sources, numNodes, tagRoot);
            this.cachedNodes_ = cachedNodes_;
            this.exceptionProfiles_ = exceptionProfiles_;
            this.localTags_ = localTags_;
            this.branchProfiles_ = branchProfiles_;
            this.osrMetadata_ = osrMetadata_;
        }

        @Override
        @BytecodeInterpreterSwitch
        @ExplodeLoop(kind = LoopExplosionKind.MERGE_EXPLODE)
        long continueAt(SLBytecodeRootNodeGen $root, VirtualFrame frame, long startState) {
            byte[] bc = this.bytecodes;
            Node[] cachedNodes = this.cachedNodes_;
            int[] branchProfiles = this.branchProfiles_;
            int bci = (int) (startState & 0xFFFFFFFFL);
            int sp = (int) (startState >>> 32);
            int op;
            long temp;
            LoopCounter loopCounter = new LoopCounter();
            FRAMES.setInt(frame, BCI_INDEX, -1);
            loop: while (true) {
                op = BYTES.getShort(bc, bci);
                try {
                    switch (op) {
                        case Instructions.POP :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doPop(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.POP$LONG :
                        {
                            doPop$Long(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.POP$BOOLEAN :
                        {
                            doPop$Boolean(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.POP$GENERIC :
                        {
                            doPop$generic(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.DUP :
                        {
                            FRAMES.copy(frame, sp - 1, sp);
                            sp += 1;
                            bci += 2;
                            break;
                        }
                        case Instructions.RETURN :
                        {
                            if (CompilerDirectives.hasNextTier() && loopCounter.value > 0) {
                                LoopNode.reportLoopCount(this, loopCounter.value);
                            }
                            return (((long) (sp - 1)) << 32) | 0xFFFFFFFFL;
                        }
                        case Instructions.BRANCH :
                        {
                            bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                            break;
                        }
                        case Instructions.BRANCH_BACKWARD :
                        {
                            if (CompilerDirectives.hasNextTier() && ++loopCounter.value >= LoopCounter.REPORT_LOOP_STRIDE) {
                                LoopNode.reportLoopCount(this, loopCounter.value);
                                loopCounter.value = 0;
                            }
                            temp = doBranchBackward(frame, bc, bci, sp);
                            if (temp != -1) {
                                return temp;
                            }
                            bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                            break;
                        }
                        case Instructions.BRANCH_FALSE :
                        {
                            if (profileBranch(branchProfiles, BYTES.getIntUnaligned(bc, bci + 6 /* imm branch_profile */), doBranchFalse(frame, bc, bci, sp))) {
                                sp -= 1;
                                bci += 14;
                                break;
                            } else {
                                sp -= 1;
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                break;
                            }
                        }
                        case Instructions.BRANCH_FALSE$GENERIC :
                        {
                            if (profileBranch(branchProfiles, BYTES.getIntUnaligned(bc, bci + 6 /* imm branch_profile */), doBranchFalse$Generic(frame, bc, bci, sp))) {
                                sp -= 1;
                                bci += 14;
                                break;
                            } else {
                                sp -= 1;
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                break;
                            }
                        }
                        case Instructions.BRANCH_FALSE$BOOLEAN :
                        {
                            if (profileBranch(branchProfiles, BYTES.getIntUnaligned(bc, bci + 6 /* imm branch_profile */), doBranchFalse$Boolean(frame, bc, bci, sp))) {
                                sp -= 1;
                                bci += 14;
                                break;
                            } else {
                                sp -= 1;
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                break;
                            }
                        }
                        case Instructions.STORE_LOCAL :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doStoreLocal(frame, bc, bci, sp, FRAMES.getObject(frame, sp - 1));
                            FRAMES.clear(frame, sp - 1);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.STORE_LOCAL$LONG :
                        {
                            doStoreLocal$Long(frame, bc, bci, sp);
                            FRAMES.clear(frame, sp - 1);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.STORE_LOCAL$LONG$LONG :
                        {
                            doStoreLocal$Long$Long(frame, bc, bci, sp);
                            FRAMES.clear(frame, sp - 1);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.STORE_LOCAL$BOOLEAN :
                        {
                            doStoreLocal$Boolean(frame, bc, bci, sp);
                            FRAMES.clear(frame, sp - 1);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                        {
                            doStoreLocal$Boolean$Boolean(frame, bc, bci, sp);
                            FRAMES.clear(frame, sp - 1);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.STORE_LOCAL$GENERIC :
                        {
                            doStoreLocal$generic(frame, bc, bci, sp);
                            FRAMES.clear(frame, sp - 1);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.THROW :
                        {
                            throw sneakyThrow((Throwable) FRAMES.uncheckedGetObject(frame, sp - 1));
                        }
                        case Instructions.LOAD_CONSTANT :
                        {
                            if (CompilerDirectives.inCompiledCode()) {
                                loadConstantCompiled(frame, bc, bci, sp, constants);
                            } else {
                                FRAMES.setObject(frame, sp, ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm constant */)));
                            }
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_CONSTANT$LONG :
                        {
                            FRAMES.setLong(frame, sp, ACCESS.uncheckedCast(ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm constant */)), Long.class));
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_CONSTANT$BOOLEAN :
                        {
                            FRAMES.setBoolean(frame, sp, ACCESS.uncheckedCast(ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm constant */)), Boolean.class));
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_NULL :
                        {
                            FRAMES.setObject(frame, sp, null);
                            sp += 1;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_ARGUMENT :
                        {
                            FRAMES.setObject(frame, sp, frame.getArguments()[BYTES.getShort(bc, bci + 2 /* imm index */)]);
                            sp += 1;
                            bci += 4;
                            break;
                        }
                        case Instructions.LOAD_ARGUMENT$LONG :
                        {
                            doLoadArgument$Long(frame, bc, bci, sp);
                            sp += 1;
                            bci += 4;
                            break;
                        }
                        case Instructions.LOAD_ARGUMENT$BOOLEAN :
                        {
                            doLoadArgument$Boolean(frame, bc, bci, sp);
                            sp += 1;
                            bci += 4;
                            break;
                        }
                        case Instructions.LOAD_EXCEPTION :
                        {
                            FRAMES.setObject(frame, sp, FRAMES.getObject(frame, $root.maxLocals + BYTES.getShort(bc, bci + 2 /* imm exceptionSp */)));
                            sp += 1;
                            bci += 4;
                            break;
                        }
                        case Instructions.LOAD_LOCAL :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doLoadLocal(frame, bc, bci, sp);
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL$LONG :
                        {
                            doLoadLocal$Long(frame, bc, bci, sp);
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                        {
                            doLoadLocal$Long$unboxed(frame, bc, bci, sp);
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL$BOOLEAN :
                        {
                            doLoadLocal$Boolean(frame, bc, bci, sp);
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                        {
                            doLoadLocal$Boolean$unboxed(frame, bc, bci, sp);
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL$GENERIC :
                        {
                            doLoadLocal$generic(frame, bc, bci, sp);
                            sp += 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doLoadLocalMat(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                            bci += 8;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT$LONG :
                        {
                            doLoadLocalMat$Long(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                            bci += 8;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                        {
                            doLoadLocalMat$Long$unboxed(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                            bci += 8;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                        {
                            doLoadLocalMat$Boolean(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                            bci += 8;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                        {
                            doLoadLocalMat$Boolean$unboxed(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                            bci += 8;
                            break;
                        }
                        case Instructions.LOAD_LOCAL_MAT$GENERIC :
                        {
                            doLoadLocalMat$generic(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                            bci += 8;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doStoreLocalMat(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp, FRAMES.getObject(frame, sp - 1));
                            sp -= 2;
                            bci += 12;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT$LONG :
                        {
                            doStoreLocalMat$Long(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp);
                            sp -= 2;
                            bci += 12;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                        {
                            doStoreLocalMat$Long$Long(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp);
                            sp -= 2;
                            bci += 12;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                        {
                            doStoreLocalMat$Boolean(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp);
                            sp -= 2;
                            bci += 12;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                        {
                            doStoreLocalMat$Boolean$Boolean(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp);
                            sp -= 2;
                            bci += 12;
                            break;
                        }
                        case Instructions.STORE_LOCAL_MAT$GENERIC :
                        {
                            doStoreLocalMat$generic(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp);
                            sp -= 2;
                            bci += 12;
                            break;
                        }
                        case Instructions.TAG_ENTER :
                        {
                            doTagEnter(frame, bc, bci, sp);
                            bci += 6;
                            break;
                        }
                        case Instructions.TAG_LEAVE :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doTagLeave(frame, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.TAG_LEAVE$LONG :
                        {
                            doTagLeave$Long(frame, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.TAG_LEAVE$LONG$UNBOXED :
                        {
                            doTagLeave$Long$unboxed(frame, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.TAG_LEAVE$BOOLEAN :
                        {
                            doTagLeave$Boolean(frame, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                        {
                            doTagLeave$Boolean$unboxed(frame, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.TAG_LEAVE$GENERIC :
                        {
                            doTagLeave$generic(frame, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.TAG_LEAVE_VOID :
                        {
                            doTagLeaveVoid(frame, bc, bci, sp);
                            bci += 6;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_0 :
                        {
                            FRAMES.setObject(frame, sp, EMPTY_ARRAY);
                            sp += 1;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_1 :
                        {
                            FRAMES.setObject(frame, sp - 1, readVariadic(frame, sp, 1));
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_2 :
                        {
                            FRAMES.setObject(frame, sp - 2, readVariadic(frame, sp, 2));
                            sp -= 1;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_3 :
                        {
                            FRAMES.setObject(frame, sp - 3, readVariadic(frame, sp, 3));
                            sp -= 2;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_4 :
                        {
                            FRAMES.setObject(frame, sp - 4, readVariadic(frame, sp, 4));
                            sp -= 3;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_5 :
                        {
                            FRAMES.setObject(frame, sp - 5, readVariadic(frame, sp, 5));
                            sp -= 4;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_6 :
                        {
                            FRAMES.setObject(frame, sp - 6, readVariadic(frame, sp, 6));
                            sp -= 5;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_7 :
                        {
                            FRAMES.setObject(frame, sp - 7, readVariadic(frame, sp, 7));
                            sp -= 6;
                            bci += 2;
                            break;
                        }
                        case Instructions.LOAD_VARIADIC_8 :
                        {
                            FRAMES.setObject(frame, sp - 8, readVariadic(frame, sp, 8));
                            sp -= 7;
                            bci += 2;
                            break;
                        }
                        case Instructions.MERGE_VARIADIC :
                        {
                            FRAMES.setObject(frame, sp - 1, mergeVariadic((Object[]) FRAMES.uncheckedGetObject(frame, sp - 1)));
                            bci += 2;
                            break;
                        }
                        case Instructions.CONSTANT_NULL :
                        {
                            FRAMES.setObject(frame, sp, null);
                            sp += 1;
                            bci += 2;
                            break;
                        }
                        case Instructions.CLEAR_LOCAL :
                        {
                            FRAMES.clear(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */));
                            bci += 4;
                            break;
                        }
                        case Instructions.SL_ALWAYS_HALT_ :
                        {
                            doSLAlwaysHalt_(frame, cachedNodes, bc, bci, sp);
                            bci += 6;
                            break;
                        }
                        case Instructions.SL_LOAD_ARGUMENT_ :
                        {
                            doSLLoadArgument_(frame, cachedNodes, bc, bci, sp);
                            sp += 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                        {
                            doSLLoadArgument$LoadInBounds_(frame, cachedNodes, bc, bci, sp);
                            sp += 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.BUILTIN_ :
                        {
                            doBuiltin_(frame, cachedNodes, bc, bci, sp);
                            sp += 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_INVOKE_ :
                        {
                            doSLInvoke_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.SL_ADD_ :
                        {
                            doSLAdd_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_ADD$LONG_ :
                        {
                            doSLAdd$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_ADD$LONG$UNBOXED_ :
                        {
                            doSLAdd$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_DIV_ :
                        {
                            doSLDiv_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_DIV$LONG_ :
                        {
                            doSLDiv$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_DIV$LONG$UNBOXED_ :
                        {
                            doSLDiv$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_EQUAL_ :
                        {
                            doSLEqual_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_EQUAL$LONG_ :
                        {
                            doSLEqual$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                        {
                            doSLEqual$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_EQUAL$BOOLEAN_ :
                        {
                            doSLEqual$Boolean_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                        {
                            doSLEqual$Boolean$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_EQUAL$UNBOXED_ :
                        {
                            doSLEqual$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_OR_EQUAL_ :
                        {
                            doSLLessOrEqual_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                        {
                            doSLLessOrEqual$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                        {
                            doSLLessOrEqual$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                        {
                            doSLLessOrEqual$SLBigInteger$InteropBigInteger0$InteropBigInteger1_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                        {
                            doSLLessOrEqual$SLBigInteger$InteropBigInteger0$InteropBigInteger1$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_THAN_ :
                        {
                            doSLLessThan_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_THAN$LONG_ :
                        {
                            doSLLessThan$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                        {
                            doSLLessThan$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LESS_THAN$UNBOXED_ :
                        {
                            doSLLessThan$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_LOGICAL_NOT_ :
                        {
                            doSLLogicalNot_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                        {
                            doSLLogicalNot$Boolean_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                        {
                            doSLLogicalNot$Boolean$unboxed_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                        {
                            doSLLogicalNot$unboxed_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_MUL_ :
                        {
                            doSLMul_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_MUL$LONG_ :
                        {
                            doSLMul$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_MUL$LONG$UNBOXED_ :
                        {
                            doSLMul$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_READ_PROPERTY_ :
                        {
                            doSLReadProperty_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 6;
                            break;
                        }
                        case Instructions.SL_SUB_ :
                        {
                            doSLSub_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_SUB$LONG_ :
                        {
                            doSLSub$Long_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_SUB$LONG$UNBOXED_ :
                        {
                            doSLSub$Long$unboxed_(frame, cachedNodes, bc, bci, sp);
                            sp -= 1;
                            bci += 14;
                            break;
                        }
                        case Instructions.SL_WRITE_PROPERTY_ :
                        {
                            doSLWriteProperty_(frame, cachedNodes, bc, bci, sp);
                            sp -= 2;
                            bci += 6;
                            break;
                        }
                        case Instructions.SL_UNBOX_ :
                        {
                            doSLUnbox_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                        {
                            doSLUnbox$FromBoolean_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                        {
                            doSLUnbox$FromBoolean$unboxed_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_UNBOX$FROM_LONG_ :
                        {
                            doSLUnbox$FromLong_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                        {
                            doSLUnbox$FromLong$unboxed_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_FUNCTION_LITERAL_ :
                        {
                            doSLFunctionLiteral_(frame, cachedNodes, bc, bci, sp);
                            bci += 6;
                            break;
                        }
                        case Instructions.SL_TO_BOOLEAN_ :
                        {
                            doSLToBoolean_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                        {
                            doSLToBoolean$Boolean_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                        {
                            doSLToBoolean$Boolean$unboxed_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                        {
                            doSLToBoolean$unboxed_(frame, cachedNodes, bc, bci, sp);
                            bci += 10;
                            break;
                        }
                        case Instructions.SL_AND_ :
                        {
                            if (!(boolean) FRAMES.uncheckedGetObject(frame, sp - 1)) {
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                break;
                            } else {
                                FRAMES.clear(frame, sp - 1);
                                sp -= 1;
                                bci += 10;
                                break;
                            }
                        }
                        case Instructions.SL_OR_ :
                        {
                            if ((boolean) FRAMES.uncheckedGetObject(frame, sp - 1)) {
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                break;
                            } else {
                                FRAMES.clear(frame, sp - 1);
                                sp -= 1;
                                bci += 10;
                                break;
                            }
                        }
                        case Instructions.MERGE_CONDITIONAL :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            doMergeConditional(frame, bc, bci, sp, FRAMES.requireObject(frame, sp - 1));
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL$LONG :
                        {
                            doMergeConditional$Long(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                        {
                            doMergeConditional$Long$unboxed(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                        {
                            doMergeConditional$Boolean(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                        {
                            doMergeConditional$Boolean$unboxed(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.MERGE_CONDITIONAL$GENERIC :
                        {
                            doMergeConditional$generic(frame, bc, bci, sp);
                            sp -= 1;
                            bci += 10;
                            break;
                        }
                        case Instructions.INVALIDATE0 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                        case Instructions.INVALIDATE1 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                        case Instructions.INVALIDATE2 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                        case Instructions.INVALIDATE3 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                        case Instructions.INVALIDATE4 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                        case Instructions.INVALIDATE5 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                        case Instructions.INVALIDATE6 :
                        {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                        }
                    }
                } catch (Throwable throwable) {
                    throwable = resolveThrowable($root, frame, bci, throwable);
                    op = -EXCEPTION_HANDLER_LENGTH;
                    while ((op = resolveHandler(bci, op + EXCEPTION_HANDLER_LENGTH, this.handlers)) != -1) {
                        try {
                            switch (this.handlers[op + EXCEPTION_HANDLER_OFFSET_KIND]) {
                                case HANDLER_TAG_EXCEPTIONAL :
                                    long result = doTagExceptional($root, frame, bc, bci, throwable, this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI], this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_SP]);
                                    temp = (int) (result >>> 32);
                                    bci = (int) (result & 0xFFFFFFFFL);
                                    if (sp < (int) temp + $root.maxLocals) {
                                        // The instrumentation pushed a value on the stack.
                                        assert sp == (int) temp + $root.maxLocals - 1;
                                        sp++;
                                    }
                                    break;
                                default :
                                    if (throwable instanceof java.lang.ThreadDeath) {
                                        continue;
                                    }
                                    assert throwable instanceof AbstractTruffleException;
                                    bci = this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
                                    temp = this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_SP];
                                    FRAMES.setObject(frame, ((int) temp) - 1 + $root.maxLocals, throwable);
                                    break;
                            }
                        } catch (Throwable t) {
                            if (t != throwable) {
                                throwable = resolveThrowable($root, frame, bci, t);
                            }
                            continue;
                        }
                        temp = temp + $root.maxLocals;
                        assert sp >= temp - 1;
                        while (sp > temp) {
                            FRAMES.clear(frame, --sp);
                        }
                        sp = (int) temp;
                        continue loop;
                    }
                    if (CompilerDirectives.hasNextTier() && loopCounter.value > 0) {
                        LoopNode.reportLoopCount(this, loopCounter.value);
                    }
                    throw sneakyThrow(throwable);
                }
            }
        }

        private long doBranchBackward(VirtualFrame frame, byte[] bc, int bci, int sp) {
            if (CompilerDirectives.inInterpreter() && BytecodeOSRNode.pollOSRBackEdge(this)) {
                int branchProfileIndex = BYTES.getIntUnaligned(bc, bci + 6 /* imm loop_header_branch_profile */);
                ensureFalseProfile(branchProfiles_, branchProfileIndex);
                Object osrResult = BytecodeOSRNode.tryOSR(this, BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */), sp, null, frame);
                if (osrResult != null) {
                    return (long) osrResult;
                }
            }
            return -1;
        }

        private void doStoreLocal(Frame frame, byte[] bc, int bci, int sp, Object local) {
            short newInstruction;
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            int operandIndex = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
            if (operandIndex != -1) {
                short newOperand;
                short operand = BYTES.getShort(bc, operandIndex);
                FrameSlotKind oldKind = this.getCachedLocalKindInternal(slot, localIndex);
                FrameSlotKind newKind;
                if (local instanceof Long) {
                    switch (oldKind) {
                        case Long :
                        case Illegal :
                            if ((newOperand = applyQuickeningLong(operand)) != -1) {
                                newInstruction = Instructions.STORE_LOCAL$LONG$LONG;
                            } else {
                                newInstruction = Instructions.STORE_LOCAL$LONG;
                                newOperand = operand;
                            }
                            newKind = FrameSlotKind.Long;
                            FRAMES.setLong(frame, slot, (long) local);
                            break;
                        case Boolean :
                        case Object :
                            newInstruction = Instructions.STORE_LOCAL$GENERIC;
                            newOperand = undoQuickening(operand);
                            newKind = FrameSlotKind.Object;
                            FRAMES.setObject(frame, slot, local);
                            break;
                        default :
                            throw CompilerDirectives.shouldNotReachHere("Unexpected FrameSlotKind.");
                    }
                } else if (local instanceof Boolean) {
                    switch (oldKind) {
                        case Boolean :
                        case Illegal :
                            if ((newOperand = applyQuickeningBoolean(operand)) != -1) {
                                newInstruction = Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN;
                            } else {
                                newInstruction = Instructions.STORE_LOCAL$BOOLEAN;
                                newOperand = operand;
                            }
                            newKind = FrameSlotKind.Boolean;
                            FRAMES.setBoolean(frame, slot, (boolean) local);
                            break;
                        case Long :
                        case Object :
                            newInstruction = Instructions.STORE_LOCAL$GENERIC;
                            newOperand = undoQuickening(operand);
                            newKind = FrameSlotKind.Object;
                            FRAMES.setObject(frame, slot, local);
                            break;
                        default :
                            throw CompilerDirectives.shouldNotReachHere("Unexpected FrameSlotKind.");
                    }
                } else {
                    newInstruction = Instructions.STORE_LOCAL$GENERIC;
                    newOperand = undoQuickening(operand);
                    newKind = FrameSlotKind.Object;
                    FRAMES.setObject(frame, slot, local);
                }
                this.setCachedLocalKindInternal(slot, newKind, localIndex);
                BYTES.putShort(bc, operandIndex, newOperand);
            } else {
                newInstruction = Instructions.STORE_LOCAL$GENERIC;
                FRAMES.setObject(frame, slot, local);
                this.setCachedLocalKindInternal(slot, FrameSlotKind.Object, localIndex);
            }
            BYTES.putShort(bc, bci, newInstruction);
            FRAMES.clear(frame, sp - 1);
        }

        private void doStoreLocal$Long(Frame frame, byte[] bc, int bci, int sp) {
            Object local;
            try {
                local = FRAMES.expectObject(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocal(frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            FrameSlotKind kind = this.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Long) {
                try {
                    FRAMES.setLong(frame, slot, SLBytecodeRootNodeGen.expectLong(local));
                    if (CompilerDirectives.inCompiledCode()) {
                        // Clear primitive for compiler liveness analysis
                        FRAMES.clear(frame, sp - 1);
                    }
                    return;
                } catch (UnexpectedResultException ex) {
                    local = ex.getResult();
                    // fall through to slow-path
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocal(frame, bc, bci, sp, local);
        }

        private void doStoreLocal$Long$Long(Frame frame, byte[] bc, int bci, int sp) {
            long local;
            try {
                local = FRAMES.expectLong(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocal(frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            FrameSlotKind kind = this.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Long) {
                FRAMES.setLong(frame, slot, local);
                if (CompilerDirectives.inCompiledCode()) {
                    // Clear primitive for compiler liveness analysis
                    FRAMES.clear(frame, sp - 1);
                }
                return;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocal(frame, bc, bci, sp, local);
        }

        private void doStoreLocal$Boolean(Frame frame, byte[] bc, int bci, int sp) {
            Object local;
            try {
                local = FRAMES.expectObject(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocal(frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            FrameSlotKind kind = this.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Boolean) {
                try {
                    FRAMES.setBoolean(frame, slot, SLBytecodeRootNodeGen.expectBoolean(local));
                    if (CompilerDirectives.inCompiledCode()) {
                        // Clear primitive for compiler liveness analysis
                        FRAMES.clear(frame, sp - 1);
                    }
                    return;
                } catch (UnexpectedResultException ex) {
                    local = ex.getResult();
                    // fall through to slow-path
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocal(frame, bc, bci, sp, local);
        }

        private void doStoreLocal$Boolean$Boolean(Frame frame, byte[] bc, int bci, int sp) {
            boolean local;
            try {
                local = FRAMES.expectBoolean(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocal(frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            FrameSlotKind kind = this.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Boolean) {
                FRAMES.setBoolean(frame, slot, local);
                if (CompilerDirectives.inCompiledCode()) {
                    // Clear primitive for compiler liveness analysis
                    FRAMES.clear(frame, sp - 1);
                }
                return;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocal(frame, bc, bci, sp, local);
        }

        private void doStoreLocal$generic(Frame frame, byte[] bc, int bci, int sp) {
            Object local;
            try {
                local = FRAMES.expectObject(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocal(frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */), local);
            FRAMES.clear(frame, sp - 1);
        }

        private void doLoadArgument$Long(VirtualFrame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setLong(frame, sp, SLBytecodeRootNodeGen.expectLong(frame.getArguments()[BYTES.getShort(bc, bci + 2 /* imm index */)]));
            } catch (UnexpectedResultException e) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                BYTES.putShort(bc, bci, Instructions.LOAD_ARGUMENT);
                FRAMES.setObject(frame, sp, e.getResult());
            }
        }

        private void doLoadArgument$Boolean(VirtualFrame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setBoolean(frame, sp, SLBytecodeRootNodeGen.expectBoolean(frame.getArguments()[BYTES.getShort(bc, bci + 2 /* imm index */)]));
            } catch (UnexpectedResultException e) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                BYTES.putShort(bc, bci, Instructions.LOAD_ARGUMENT);
                FRAMES.setObject(frame, sp, e.getResult());
            }
        }

        private void doLoadLocal(Frame frame, byte[] bc, int bci, int sp) {
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            FrameSlotKind kind = this.getCachedLocalKindInternal(slot, localIndex);
            Object value;
            short newInstruction;
            try {
                switch (kind) {
                    case Long :
                        newInstruction = Instructions.LOAD_LOCAL$LONG;
                        value = FRAMES.expectLong(frame, slot);
                        break;
                    case Boolean :
                        newInstruction = Instructions.LOAD_LOCAL$BOOLEAN;
                        value = FRAMES.expectBoolean(frame, slot);
                        break;
                    case Object :
                    case Illegal :
                        newInstruction = Instructions.LOAD_LOCAL$GENERIC;
                        value = FRAMES.expectObject(frame, slot);
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Unexpected FrameSlotKind.");
                }
            } catch (UnexpectedResultException ex) {
                newInstruction = Instructions.LOAD_LOCAL$GENERIC;
                value = ex.getResult();
            }
            BYTES.putShort(bc, bci, newInstruction);
            FRAMES.setObject(frame, sp, value);
        }

        private void doLoadLocal$Long(Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setObject(frame, sp, FRAMES.expectLong(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocal(frame, bc, bci, sp);
            }
        }

        private void doLoadLocal$Long$unboxed(Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setLong(frame, sp, FRAMES.expectLong(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocal(frame, bc, bci, sp);
            }
        }

        private void doLoadLocal$Boolean(Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setObject(frame, sp, FRAMES.expectBoolean(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocal(frame, bc, bci, sp);
            }
        }

        private void doLoadLocal$Boolean$unboxed(Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setBoolean(frame, sp, FRAMES.expectBoolean(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocal(frame, bc, bci, sp);
            }
        }

        private void doLoadLocal$generic(Frame frame, byte[] bc, int bci, int sp) {
            FRAMES.setObject(frame, sp, FRAMES.requireObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
        }

        private void doLoadLocalMat(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            AbstractBytecodeNode bytecodeNode = this.getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */)).getBytecodeNodeImpl();
            FrameSlotKind kind = bytecodeNode.getCachedLocalKindInternal(slot, localIndex);
            Object value;
            short newInstruction;
            try {
                switch (kind) {
                    case Long :
                        newInstruction = Instructions.LOAD_LOCAL_MAT$LONG;
                        value = FRAMES.expectLong(frame, slot);
                        break;
                    case Boolean :
                        newInstruction = Instructions.LOAD_LOCAL_MAT$BOOLEAN;
                        value = FRAMES.expectBoolean(frame, slot);
                        break;
                    case Object :
                    case Illegal :
                        newInstruction = Instructions.LOAD_LOCAL_MAT$GENERIC;
                        value = FRAMES.expectObject(frame, slot);
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere("Unexpected FrameSlotKind.");
                }
            } catch (UnexpectedResultException ex) {
                newInstruction = Instructions.LOAD_LOCAL_MAT$GENERIC;
                value = ex.getResult();
            }
            BYTES.putShort(bc, bci, newInstruction);
            FRAMES.setObject(stackFrame, sp - 1, value);
        }

        private void doLoadLocalMat$Long(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setObject(stackFrame, sp - 1, FRAMES.expectLong(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocalMat(stackFrame, frame, bc, bci, sp);
            }
        }

        private void doLoadLocalMat$Long$unboxed(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setLong(stackFrame, sp - 1, FRAMES.expectLong(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocalMat(stackFrame, frame, bc, bci, sp);
            }
        }

        private void doLoadLocalMat$Boolean(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setObject(stackFrame, sp - 1, FRAMES.expectBoolean(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocalMat(stackFrame, frame, bc, bci, sp);
            }
        }

        private void doLoadLocalMat$Boolean$unboxed(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            try {
                FRAMES.setBoolean(stackFrame, sp - 1, FRAMES.expectBoolean(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
            } catch (UnexpectedResultException ex) {
                doLoadLocalMat(stackFrame, frame, bc, bci, sp);
            }
        }

        private void doLoadLocalMat$generic(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            FRAMES.setObject(stackFrame, sp - 1, FRAMES.requireObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
        }

        private void doStoreLocalMat(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp, Object local) {
            short newInstruction;
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            int operandIndex = BYTES.getIntUnaligned(bc, bci + 8 /* imm child0 */);
            AbstractBytecodeNode bytecodeNode = this.getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */)).getBytecodeNodeImpl();
            if (operandIndex != -1) {
                short newOperand;
                short operand = BYTES.getShort(bc, operandIndex);
                FrameSlotKind oldKind = bytecodeNode.getCachedLocalKindInternal(slot, localIndex);
                FrameSlotKind newKind;
                if (local instanceof Long) {
                    switch (oldKind) {
                        case Long :
                        case Illegal :
                            if ((newOperand = applyQuickeningLong(operand)) != -1) {
                                newInstruction = Instructions.STORE_LOCAL_MAT$LONG$LONG;
                            } else {
                                newInstruction = Instructions.STORE_LOCAL_MAT$LONG;
                                newOperand = operand;
                            }
                            newKind = FrameSlotKind.Long;
                            FRAMES.setLong(frame, slot, (long) local);
                            break;
                        case Boolean :
                        case Object :
                            newInstruction = Instructions.STORE_LOCAL_MAT$GENERIC;
                            newOperand = undoQuickening(operand);
                            newKind = FrameSlotKind.Object;
                            FRAMES.setObject(frame, slot, local);
                            break;
                        default :
                            throw CompilerDirectives.shouldNotReachHere("Unexpected FrameSlotKind.");
                    }
                } else if (local instanceof Boolean) {
                    switch (oldKind) {
                        case Boolean :
                        case Illegal :
                            if ((newOperand = applyQuickeningBoolean(operand)) != -1) {
                                newInstruction = Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN;
                            } else {
                                newInstruction = Instructions.STORE_LOCAL_MAT$BOOLEAN;
                                newOperand = operand;
                            }
                            newKind = FrameSlotKind.Boolean;
                            FRAMES.setBoolean(frame, slot, (boolean) local);
                            break;
                        case Long :
                        case Object :
                            newInstruction = Instructions.STORE_LOCAL_MAT$GENERIC;
                            newOperand = undoQuickening(operand);
                            newKind = FrameSlotKind.Object;
                            FRAMES.setObject(frame, slot, local);
                            break;
                        default :
                            throw CompilerDirectives.shouldNotReachHere("Unexpected FrameSlotKind.");
                    }
                } else {
                    newInstruction = Instructions.STORE_LOCAL_MAT$GENERIC;
                    newOperand = undoQuickening(operand);
                    newKind = FrameSlotKind.Object;
                    FRAMES.setObject(frame, slot, local);
                }
                bytecodeNode.setCachedLocalKindInternal(slot, newKind, localIndex);
                BYTES.putShort(bc, operandIndex, newOperand);
            } else {
                newInstruction = Instructions.STORE_LOCAL_MAT$GENERIC;
                FRAMES.setObject(frame, slot, local);
                bytecodeNode.setCachedLocalKindInternal(slot, FrameSlotKind.Object, localIndex);
            }
            BYTES.putShort(bc, bci, newInstruction);
            FRAMES.clear(stackFrame, sp - 1);
            FRAMES.clear(stackFrame, sp - 2);
        }

        private void doStoreLocalMat$Long(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            Object local;
            try {
                local = FRAMES.expectObject(stackFrame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocalMat(stackFrame, frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            AbstractBytecodeNode bytecodeNode = getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */)).getBytecodeNodeImpl();
            FrameSlotKind kind = bytecodeNode.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Long) {
                try {
                    FRAMES.setLong(frame, slot, SLBytecodeRootNodeGen.expectLong(local));
                    FRAMES.clear(stackFrame, sp - 1);
                    if (CompilerDirectives.inCompiledCode()) {
                        // Clear primitive for compiler liveness analysis
                        FRAMES.clear(stackFrame, sp - 2);
                    }
                    return;
                } catch (UnexpectedResultException ex) {
                    local = ex.getResult();
                    // fall through to slow-path
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocalMat(stackFrame, frame, bc, bci, sp, local);
        }

        private void doStoreLocalMat$Long$Long(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            long local;
            try {
                local = FRAMES.expectLong(stackFrame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocalMat(stackFrame, frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            AbstractBytecodeNode bytecodeNode = getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */)).getBytecodeNodeImpl();
            FrameSlotKind kind = bytecodeNode.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Long) {
                FRAMES.setLong(frame, slot, local);
                FRAMES.clear(stackFrame, sp - 1);
                if (CompilerDirectives.inCompiledCode()) {
                    // Clear primitive for compiler liveness analysis
                    FRAMES.clear(stackFrame, sp - 2);
                }
                return;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocalMat(stackFrame, frame, bc, bci, sp, local);
        }

        private void doStoreLocalMat$Boolean(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            Object local;
            try {
                local = FRAMES.expectObject(stackFrame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocalMat(stackFrame, frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            AbstractBytecodeNode bytecodeNode = getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */)).getBytecodeNodeImpl();
            FrameSlotKind kind = bytecodeNode.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Boolean) {
                try {
                    FRAMES.setBoolean(frame, slot, SLBytecodeRootNodeGen.expectBoolean(local));
                    FRAMES.clear(stackFrame, sp - 1);
                    if (CompilerDirectives.inCompiledCode()) {
                        // Clear primitive for compiler liveness analysis
                        FRAMES.clear(stackFrame, sp - 2);
                    }
                    return;
                } catch (UnexpectedResultException ex) {
                    local = ex.getResult();
                    // fall through to slow-path
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocalMat(stackFrame, frame, bc, bci, sp, local);
        }

        private void doStoreLocalMat$Boolean$Boolean(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            boolean local;
            try {
                local = FRAMES.expectBoolean(stackFrame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocalMat(stackFrame, frame, bc, bci, sp, ex.getResult());
                return;
            }
            int slot = BYTES.getShort(bc, bci + 2 /* imm localOffset */);
            int localIndex = BYTES.getShort(bc, bci + 4 /* imm localIndex */);
            AbstractBytecodeNode bytecodeNode = getRoot().getBytecodeRootNodeImpl(BYTES.getShort(bc, bci + 6 /* imm rootIndex */)).getBytecodeNodeImpl();
            FrameSlotKind kind = bytecodeNode.getCachedLocalKindInternal(slot, localIndex);
            if (kind == FrameSlotKind.Boolean) {
                FRAMES.setBoolean(frame, slot, local);
                FRAMES.clear(stackFrame, sp - 1);
                if (CompilerDirectives.inCompiledCode()) {
                    // Clear primitive for compiler liveness analysis
                    FRAMES.clear(stackFrame, sp - 2);
                }
                return;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            doStoreLocalMat(stackFrame, frame, bc, bci, sp, local);
        }

        private void doStoreLocalMat$generic(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            Object local;
            try {
                local = FRAMES.expectObject(stackFrame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doStoreLocalMat(stackFrame, frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */), local);
            FRAMES.clear(stackFrame, sp - 1);
            FRAMES.clear(stackFrame, sp - 2);
        }

        @InliningCutoff
        private void doTagEnter(VirtualFrame frame, byte[] bc, int bci, int sp) {
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onEnter(frame);
        }

        private void doTagLeave(VirtualFrame frame, byte[] bc, int bci, int sp) {
            CompilerDirectives.transferToInterpreterAndInvalidate();
            short newInstruction;
            short newOperand;
            int operandIndex = BYTES.getIntUnaligned(bc, bci + 6 /* imm child0 */);
            short operand = BYTES.getShort(bc, operandIndex);
            Object value = FRAMES.requireObject(frame, sp - 1);
            if (value instanceof Long &&
                 (newOperand = applyQuickeningLong(operand)) != -1) {
                newInstruction = Instructions.TAG_LEAVE$LONG;
            } else if (value instanceof Boolean &&
                 (newOperand = applyQuickeningBoolean(operand)) != -1) {
                newInstruction = Instructions.TAG_LEAVE$BOOLEAN;
            } else {
                newOperand = undoQuickening(operand);
                newInstruction = Instructions.TAG_LEAVE$GENERIC;
            }
            BYTES.putShort(bc, operandIndex, newOperand);
            BYTES.putShort(bc, bci, newInstruction);
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, value);
        }

        private void doTagLeave$Long(VirtualFrame frame, byte[] bc, int bci, int sp) {
            long returnValue;
            try {
                returnValue = FRAMES.expectLong(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doTagLeave(frame, bc, bci, sp);
                return;
            }
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, returnValue);
            FRAMES.setObject(frame, sp - 1, returnValue);
        }

        private void doTagLeave$Long$unboxed(VirtualFrame frame, byte[] bc, int bci, int sp) {
            long returnValue;
            try {
                returnValue = FRAMES.expectLong(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doTagLeave(frame, bc, bci, sp);
                return;
            }
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, returnValue);
        }

        private void doTagLeave$Boolean(VirtualFrame frame, byte[] bc, int bci, int sp) {
            boolean returnValue;
            try {
                returnValue = FRAMES.expectBoolean(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doTagLeave(frame, bc, bci, sp);
                return;
            }
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, returnValue);
            FRAMES.setObject(frame, sp - 1, returnValue);
        }

        private void doTagLeave$Boolean$unboxed(VirtualFrame frame, byte[] bc, int bci, int sp) {
            boolean returnValue;
            try {
                returnValue = FRAMES.expectBoolean(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doTagLeave(frame, bc, bci, sp);
                return;
            }
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, returnValue);
        }

        private void doTagLeave$generic(VirtualFrame frame, byte[] bc, int bci, int sp) {
            Object returnValue;
            returnValue = FRAMES.requireObject(frame, sp - 1);
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, returnValue);
        }

        @InliningCutoff
        private void doTagLeaveVoid(VirtualFrame frame, byte[] bc, int bci, int sp) {
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, null);
        }

        private void doSLAlwaysHalt_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLAlwaysHalt_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLAlwaysHalt_Node.class);
            node.execute(frame, this, bc, bci, sp);
        }

        private void doSLLoadArgument_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLoadArgument_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 6 /* imm node */)), SLLoadArgument_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp, result);
        }

        private void doSLLoadArgument$LoadInBounds_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLoadArgument_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 6 /* imm node */)), SLLoadArgument_Node.class);
            Object result = node.executeLoadInBounds(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp, result);
        }

        private void doBuiltin_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            Builtin_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 10 /* imm node */)), Builtin_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp, result);
        }

        private void doSLInvoke_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLInvoke_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLInvoke_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLAdd_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLAdd_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLAdd_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLAdd$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLAdd_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLAdd_Node.class);
            try {
                long result = node.executeLong(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLAdd$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLAdd_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLAdd_Node.class);
            try {
                long result = node.executeLong$unboxed(frame, this, bc, bci, sp);
                FRAMES.setLong(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLDiv_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLDiv_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLDiv_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLDiv$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLDiv_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLDiv_Node.class);
            try {
                long result = node.executeLong(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLDiv$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLDiv_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLDiv_Node.class);
            try {
                long result = node.executeLong$unboxed(frame, this, bc, bci, sp);
                FRAMES.setLong(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLEqual_Node.class);
            boolean result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLEqual_Node.class);
            boolean result = node.executeLong(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLEqual_Node.class);
            boolean result = node.executeLong$unboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual$Boolean_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLEqual_Node.class);
            boolean result = node.executeBoolean(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual$Boolean$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLEqual_Node.class);
            boolean result = node.executeBoolean$unboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLEqual_Node.class);
            boolean result = node.executeunboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessOrEqual_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessOrEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessOrEqual_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessOrEqual$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessOrEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessOrEqual_Node.class);
            try {
                boolean result = node.executeLong(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessOrEqual$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessOrEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessOrEqual_Node.class);
            try {
                boolean result = node.executeLong$unboxed(frame, this, bc, bci, sp);
                FRAMES.setBoolean(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessOrEqual$SLBigInteger$InteropBigInteger0$InteropBigInteger1_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessOrEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessOrEqual_Node.class);
            try {
                boolean result = node.executeSLBigInteger_InteropBigInteger0_InteropBigInteger1(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessOrEqual$SLBigInteger$InteropBigInteger0$InteropBigInteger1$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessOrEqual_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessOrEqual_Node.class);
            try {
                boolean result = node.executeSLBigInteger_InteropBigInteger0_InteropBigInteger1$unboxed(frame, this, bc, bci, sp);
                FRAMES.setBoolean(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessThan_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessThan_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessThan_Node.class);
            boolean result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessThan$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessThan_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessThan_Node.class);
            boolean result = node.executeLong(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessThan$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessThan_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessThan_Node.class);
            boolean result = node.executeLong$unboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessThan$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLessThan_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLessThan_Node.class);
            boolean result = node.executeunboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLogicalNot_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLogicalNot_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLogicalNot_Node.class);
            boolean result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLLogicalNot$Boolean_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLogicalNot_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLogicalNot_Node.class);
            boolean result = node.executeBoolean(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLLogicalNot$Boolean$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLogicalNot_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLogicalNot_Node.class);
            boolean result = node.executeBoolean$unboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 1, result);
        }

        private void doSLLogicalNot$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLLogicalNot_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLLogicalNot_Node.class);
            boolean result = node.executeunboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 1, result);
        }

        private void doSLMul_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLMul_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLMul_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLMul$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLMul_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLMul_Node.class);
            try {
                long result = node.executeLong(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLMul$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLMul_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLMul_Node.class);
            try {
                long result = node.executeLong$unboxed(frame, this, bc, bci, sp);
                FRAMES.setLong(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLReadProperty_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLReadProperty_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLReadProperty_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLSub_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLSub_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLSub_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLSub$Long_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLSub_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLSub_Node.class);
            try {
                long result = node.executeLong(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLSub$Long$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLSub_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLSub_Node.class);
            try {
                long result = node.executeLong$unboxed(frame, this, bc, bci, sp);
                FRAMES.setLong(frame, sp - 2, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 2, ex.getResult());
            }
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLWriteProperty_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLWriteProperty_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLWriteProperty_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 3, result);
            FRAMES.clear(frame, sp - 2);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLUnbox_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLUnbox_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLUnbox_Node.class);
            Object result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLUnbox$FromBoolean_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLUnbox_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLUnbox_Node.class);
            try {
                boolean result = node.executeFromBoolean(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 1, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 1, ex.getResult());
            }
        }

        private void doSLUnbox$FromBoolean$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLUnbox_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLUnbox_Node.class);
            try {
                boolean result = node.executeFromBoolean$unboxed(frame, this, bc, bci, sp);
                FRAMES.setBoolean(frame, sp - 1, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 1, ex.getResult());
            }
        }

        private void doSLUnbox$FromLong_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLUnbox_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLUnbox_Node.class);
            try {
                long result = node.executeFromLong(frame, this, bc, bci, sp);
                FRAMES.setObject(frame, sp - 1, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 1, ex.getResult());
            }
        }

        private void doSLUnbox$FromLong$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLUnbox_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLUnbox_Node.class);
            try {
                long result = node.executeFromLong$unboxed(frame, this, bc, bci, sp);
                FRAMES.setLong(frame, sp - 1, result);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                FRAMES.setObject(frame, sp - 1, ex.getResult());
            }
        }

        private void doSLFunctionLiteral_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLFunctionLiteral_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLFunctionLiteral_Node.class);
            SLFunction result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLToBoolean_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLToBoolean_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLToBoolean_Node.class);
            boolean result = node.execute(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLToBoolean$Boolean_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLToBoolean_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLToBoolean_Node.class);
            boolean result = node.executeBoolean(frame, this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLToBoolean$Boolean$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLToBoolean_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLToBoolean_Node.class);
            boolean result = node.executeBoolean$unboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 1, result);
        }

        private void doSLToBoolean$unboxed_(VirtualFrame frame, Node[] cachedNodes, byte[] bc, int bci, int sp) {
            SLToBoolean_Node node = ACCESS.uncheckedCast(ACCESS.readObject(cachedNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm node */)), SLToBoolean_Node.class);
            boolean result = node.executeunboxed(frame, this, bc, bci, sp);
            FRAMES.setBoolean(frame, sp - 1, result);
        }

        @Override
        public void adoptNodesAfterUpdate() {
            insert(this.cachedNodes_);
        }

        @Override
        public Object executeOSR(VirtualFrame frame, int target, Object sp) {
            return continueAt(getRoot(), frame, (((long) (int) sp) << 32) | (target & 0xFFFFFFFFL));
        }

        @Override
        public Object getOSRMetadata() {
            return osrMetadata_;
        }

        @Override
        public void setOSRMetadata(Object osrMetadata) {
            osrMetadata_ = osrMetadata;
        }

        @Override
        public Object[] storeParentFrameInArguments(VirtualFrame parentFrame) {
            Object[] parentArgs = parentFrame.getArguments();
            Object[] result = Arrays.copyOf(parentArgs, parentArgs.length + 1);
            result[result.length - 1] = parentFrame;
            return result;
        }

        @Override
        public Frame restoreParentFrameFromArguments(Object[] arguments) {
            return (Frame) arguments[arguments.length - 1];
        }

        @Override
        public void setUncachedThreshold(int threshold) {
        }

        @Override
        public BytecodeTier getTier() {
            return BytecodeTier.CACHED;
        }

        @InliningCutoff
        private Throwable resolveThrowable(SLBytecodeRootNodeGen $root, VirtualFrame frame, int bci, Throwable throwable) {
            if (throwable instanceof AbstractTruffleException ate) {
                return ate;
            } else if (throwable instanceof ControlFlowException cfe) {
                throw cfe;
            } else if (throwable instanceof java.lang.ThreadDeath cfe) {
                return cfe;
            } else {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                throw sneakyThrow(throwable);
            }
        }

        @ExplodeLoop
        private int resolveHandler(int bci, int handler, int[] localHandlers) {
            int handlerEntryIndex = Math.floorDiv(handler, EXCEPTION_HANDLER_LENGTH);
            for (int i = handler; i < localHandlers.length; i += EXCEPTION_HANDLER_LENGTH, handlerEntryIndex++) {
                if (localHandlers[i + EXCEPTION_HANDLER_OFFSET_START_BCI] > bci) {
                    continue;
                }
                if (localHandlers[i + EXCEPTION_HANDLER_OFFSET_END_BCI] <= bci) {
                    continue;
                }
                if (!this.exceptionProfiles_[handlerEntryIndex]) {
                    CompilerDirectives.transferToInterpreterAndInvalidate();
                    this.exceptionProfiles_[handlerEntryIndex] = true;
                }
                return i;
            }
            return -1;
        }

        private long doTagExceptional(SLBytecodeRootNodeGen $root, VirtualFrame frame, byte[] bc, int bci, Throwable exception, int nodeId, int handlerSp) throws Throwable {
            boolean wasOnReturnExecuted;
            int nextBci;
            int nextSp;
            switch (readValidBytecode(bc, bci)) {
                case Instructions.TAG_LEAVE :
                case Instructions.TAG_LEAVE$LONG :
                case Instructions.TAG_LEAVE$LONG$UNBOXED :
                case Instructions.TAG_LEAVE$BOOLEAN :
                case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                case Instructions.TAG_LEAVE$GENERIC :
                    wasOnReturnExecuted = BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */) == nodeId;
                    break;
                case Instructions.TAG_LEAVE_VOID :
                    wasOnReturnExecuted = BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */) == nodeId;
                    break;
                default :
                    wasOnReturnExecuted = false;
                    break;
            }
            TagNode node = this.tagRoot.tagNodes[nodeId];
            Object result = node.findProbe().onReturnExceptionalOrUnwind(frame, exception, wasOnReturnExecuted);
            if (result == null) {
                throw exception;
            } else if (result == ProbeNode.UNWIND_ACTION_REENTER) {
                // Reenter by jumping to the begin bci.
                return (((long) handlerSp) << 32) | (node.enterBci & 0xFFFFFFFFL);
            } else {
                // We jump to the return address which is at sp + 1.
                int targetSp;
                int targetBci;
                switch (readValidBytecode(bc, node.returnBci)) {
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$GENERIC :
                        targetBci = node.returnBci + 10;
                        targetSp = handlerSp + 1 ;
                        FRAMES.setObject(frame, targetSp - 1 + $root.maxLocals, result);
                        break;
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                        targetBci = node.returnBci + 10;
                        targetSp = handlerSp + 1 ;
                        try {
                            FRAMES.setLong(frame, targetSp - 1 + $root.maxLocals, SLBytecodeRootNodeGen.expectLong(result));
                        } catch (UnexpectedResultException e) {
                            FRAMES.setObject(frame, targetSp - 1 + $root.maxLocals, e.getResult());
                        }
                        break;
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                        targetBci = node.returnBci + 10;
                        targetSp = handlerSp + 1 ;
                        try {
                            FRAMES.setBoolean(frame, targetSp - 1 + $root.maxLocals, SLBytecodeRootNodeGen.expectBoolean(result));
                        } catch (UnexpectedResultException e) {
                            FRAMES.setObject(frame, targetSp - 1 + $root.maxLocals, e.getResult());
                        }
                        break;
                    case Instructions.TAG_LEAVE_VOID :
                        targetBci = node.returnBci + 6;
                        targetSp = handlerSp ;
                        // discard return value
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere();
                }
                assert targetBci < bc.length : "returnBci must be reachable";
                return (((long) targetSp) << 32) | (targetBci & 0xFFFFFFFFL);
            }
        }

        @Override
        byte[] getLocalTags() {
            return this.localTags_;
        }

        @Override
        AbstractBytecodeNode toCached(int numLocals) {
            return this;
        }

        @Override
        AbstractBytecodeNode update(byte[] bytecodes_, Object[] constants_, int[] handlers_, int[] locals_, int[] sourceInfo_, List<Source> sources_, int numNodes_, TagRootNode tagRoot_) {
            assert bytecodes_ != null || sourceInfo_ != null;
            byte[] bytecodes__;
            Object[] constants__;
            int[] handlers__;
            int[] locals__;
            int[] sourceInfo__;
            List<Source> sources__;
            int numNodes__;
            TagRootNode tagRoot__;
            if (bytecodes_ != null) {
                bytecodes__ = bytecodes_;
                constants__ = constants_;
                handlers__ = handlers_;
                numNodes__ = numNodes_;
                locals__ = locals_;
                tagRoot__ = tagRoot_;
            } else {
                bytecodes__ = this.bytecodes;
                constants__ = this.constants;
                handlers__ = this.handlers;
                numNodes__ = this.numNodes;
                locals__ = this.locals;
                tagRoot__ = this.tagRoot;
            }
            if (sourceInfo_ != null) {
                sourceInfo__ = sourceInfo_;
                sources__ = sources_;
            } else {
                sourceInfo__ = this.sourceInfo;
                sources__ = this.sources;
            }
            if (bytecodes_ != null) {
                // Can't reuse profile if bytecodes are changed.
                return new CachedBytecodeNode(bytecodes__, constants__, handlers__, locals__, sourceInfo__, sources__, numNodes__, tagRoot__, this.localTags_.length);
            } else {
                // Can reuse profile if bytecodes are unchanged.
                return new CachedBytecodeNode(bytecodes__, constants__, handlers__, locals__, sourceInfo__, sources__, numNodes__, tagRoot__, this.cachedNodes_, this.exceptionProfiles_, this.localTags_, this.branchProfiles_, this.osrMetadata_);
            }
        }

        @Override
        AbstractBytecodeNode cloneUninitialized() {
            return new CachedBytecodeNode(unquickenBytecode(this.bytecodes), this.constants, this.handlers, this.locals, this.sourceInfo, this.sources, this.numNodes, tagRoot != null ? (TagRootNode) tagRoot.deepCopy() : null, this.localTags_.length);
        }

        @Override
        Node[] getCachedNodes() {
            return this.cachedNodes_;
        }

        @Override
        int[] getBranchProfiles() {
            return this.branchProfiles_;
        }

        @Override
        @TruffleBoundary
        protected int findBytecodeIndex(FrameInstance frameInstance) {
            Node prev = null;
            for (Node current = frameInstance.getCallNode(); current != null; current = current.getParent()) {
                if (current == this && prev != null) {
                    return findBytecodeIndexOfOperationNode(prev);
                }
                prev = current;
            }
            return -1;
        }

        @Override
        protected int findBytecodeIndex(Frame frame, Node node) {
            if (node != null) {
                return findBytecodeIndexOfOperationNode(node);
            }
            return -1;
        }

        @TruffleBoundary
        int findBytecodeIndexOfOperationNode(Node operationNode) {
            assert operationNode.getParent() == this : "Passed node must be an operation node of the same bytecode node.";
            Node[] localNodes = this.cachedNodes_;
            byte[] bc = this.bytecodes;
            int bci = 0;
            loop: while (bci < bc.length) {
                int currentBci = bci;
                int nodeIndex;
                switch (BYTES.getShort(bc, bci)) {
                    case Instructions.POP :
                    case Instructions.POP$LONG :
                    case Instructions.POP$BOOLEAN :
                    case Instructions.POP$GENERIC :
                    case Instructions.BRANCH :
                    case Instructions.LOAD_CONSTANT :
                    case Instructions.LOAD_CONSTANT$LONG :
                    case Instructions.LOAD_CONSTANT$BOOLEAN :
                    case Instructions.LOAD_LOCAL :
                    case Instructions.LOAD_LOCAL$LONG :
                    case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL$BOOLEAN :
                    case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL$GENERIC :
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                    case Instructions.INVALIDATE2 :
                    {
                        bci += 6;
                        continue loop;
                    }
                    case Instructions.DUP :
                    case Instructions.RETURN :
                    case Instructions.THROW :
                    case Instructions.LOAD_NULL :
                    case Instructions.LOAD_VARIADIC_0 :
                    case Instructions.LOAD_VARIADIC_1 :
                    case Instructions.LOAD_VARIADIC_2 :
                    case Instructions.LOAD_VARIADIC_3 :
                    case Instructions.LOAD_VARIADIC_4 :
                    case Instructions.LOAD_VARIADIC_5 :
                    case Instructions.LOAD_VARIADIC_6 :
                    case Instructions.LOAD_VARIADIC_7 :
                    case Instructions.LOAD_VARIADIC_8 :
                    case Instructions.MERGE_VARIADIC :
                    case Instructions.CONSTANT_NULL :
                    case Instructions.INVALIDATE0 :
                    {
                        bci += 2;
                        continue loop;
                    }
                    case Instructions.BRANCH_BACKWARD :
                    case Instructions.STORE_LOCAL :
                    case Instructions.STORE_LOCAL$LONG :
                    case Instructions.STORE_LOCAL$LONG$LONG :
                    case Instructions.STORE_LOCAL$BOOLEAN :
                    case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL$GENERIC :
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                    case Instructions.SL_AND_ :
                    case Instructions.SL_OR_ :
                    case Instructions.MERGE_CONDITIONAL :
                    case Instructions.MERGE_CONDITIONAL$LONG :
                    case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$GENERIC :
                    case Instructions.INVALIDATE4 :
                    {
                        bci += 10;
                        continue loop;
                    }
                    case Instructions.BRANCH_FALSE :
                    case Instructions.BRANCH_FALSE$GENERIC :
                    case Instructions.BRANCH_FALSE$BOOLEAN :
                    case Instructions.INVALIDATE6 :
                    {
                        bci += 14;
                        continue loop;
                    }
                    case Instructions.LOAD_ARGUMENT :
                    case Instructions.LOAD_ARGUMENT$LONG :
                    case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    case Instructions.LOAD_EXCEPTION :
                    case Instructions.CLEAR_LOCAL :
                    case Instructions.INVALIDATE1 :
                    {
                        bci += 4;
                        continue loop;
                    }
                    case Instructions.LOAD_LOCAL_MAT :
                    case Instructions.LOAD_LOCAL_MAT$LONG :
                    case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE3 :
                    {
                        bci += 8;
                        continue loop;
                    }
                    case Instructions.STORE_LOCAL_MAT :
                    case Instructions.STORE_LOCAL_MAT$LONG :
                    case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$GENERIC :
                    case Instructions.INVALIDATE5 :
                    {
                        bci += 12;
                        continue loop;
                    }
                    case Instructions.SL_ALWAYS_HALT_ :
                    case Instructions.SL_INVOKE_ :
                    case Instructions.SL_READ_PROPERTY_ :
                    case Instructions.SL_WRITE_PROPERTY_ :
                    case Instructions.SL_FUNCTION_LITERAL_ :
                    {
                        nodeIndex = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                        bci += 6;
                        break;
                    }
                    case Instructions.SL_LOAD_ARGUMENT_ :
                    case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                    {
                        nodeIndex = BYTES.getIntUnaligned(bc, bci + 6 /* imm node */);
                        bci += 10;
                        break;
                    }
                    case Instructions.BUILTIN_ :
                    {
                        nodeIndex = BYTES.getIntUnaligned(bc, bci + 10 /* imm node */);
                        bci += 14;
                        break;
                    }
                    case Instructions.SL_ADD_ :
                    case Instructions.SL_ADD$LONG_ :
                    case Instructions.SL_ADD$LONG$UNBOXED_ :
                    case Instructions.SL_DIV_ :
                    case Instructions.SL_DIV$LONG_ :
                    case Instructions.SL_DIV$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL_ :
                    case Instructions.SL_EQUAL$LONG_ :
                    case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL$BOOLEAN_ :
                    case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_EQUAL$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                    case Instructions.SL_LESS_THAN_ :
                    case Instructions.SL_LESS_THAN$LONG_ :
                    case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_THAN$UNBOXED_ :
                    case Instructions.SL_MUL_ :
                    case Instructions.SL_MUL$LONG_ :
                    case Instructions.SL_MUL$LONG$UNBOXED_ :
                    case Instructions.SL_SUB_ :
                    case Instructions.SL_SUB$LONG_ :
                    case Instructions.SL_SUB$LONG$UNBOXED_ :
                    {
                        nodeIndex = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                        bci += 14;
                        break;
                    }
                    case Instructions.SL_LOGICAL_NOT_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                    case Instructions.SL_UNBOX_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_UNBOX$FROM_LONG_ :
                    case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                    {
                        nodeIndex = BYTES.getIntUnaligned(bc, bci + 2 /* imm node */);
                        bci += 10;
                        break;
                    }
                    default :
                    {
                        throw assertionFailed("Should not reach here");
                    }
                }
                if (localNodes[nodeIndex] == operationNode) {
                    return currentBci;
                }
            }
            return -1;
        }

        @Override
        public String toString() {
            return String.format("BytecodeNode [name=%s, sources=%s, tier=cached]", ((RootNode) getParent()).getQualifiedName(), this.sourceInfo != null);
        }

        private static void doPop(Frame frame, byte[] bc, int bci, int sp) {
            CompilerDirectives.transferToInterpreterAndInvalidate();
            short newInstruction;
            int operandIndex = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
            if (operandIndex != -1) {
                short newOperand;
                short operand = BYTES.getShort(bc, operandIndex);
                Object value = FRAMES.requireObject(frame, sp - 1);
                if (value instanceof Long &&
                     (newOperand = applyQuickeningLong(operand)) != -1) {
                    newInstruction = Instructions.POP$LONG;
                } else if (value instanceof Boolean &&
                     (newOperand = applyQuickeningBoolean(operand)) != -1) {
                    newInstruction = Instructions.POP$BOOLEAN;
                } else {
                    newOperand = undoQuickening(operand);
                    newInstruction = Instructions.POP$GENERIC;
                }
                BYTES.putShort(bc, operandIndex, newOperand);
            } else {
                newInstruction = Instructions.POP$GENERIC;
            }
            BYTES.putShort(bc, bci, newInstruction);
            FRAMES.clear(frame, sp - 1);
        }

        private static void doPop$Long(Frame frame, byte[] bc, int bci, int sp) {
            if (CompilerDirectives.inCompiledCode()) {
                // Always clear in compiled code for liveness analysis
                FRAMES.clear(frame, sp - 1);
                return;
            }
            if (frame.getTag(sp - 1) != SLBytecodeRootNodeGen.TAG_LONG) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                doPop(frame, bc, bci, sp);
                return;
            }
            // No need to clear for primitives in the interpreter
        }

        private static void doPop$Boolean(Frame frame, byte[] bc, int bci, int sp) {
            if (CompilerDirectives.inCompiledCode()) {
                // Always clear in compiled code for liveness analysis
                FRAMES.clear(frame, sp - 1);
                return;
            }
            if (frame.getTag(sp - 1) != SLBytecodeRootNodeGen.TAG_BOOLEAN) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                doPop(frame, bc, bci, sp);
                return;
            }
            // No need to clear for primitives in the interpreter
        }

        private static void doPop$generic(Frame frame, byte[] bc, int bci, int sp) {
            FRAMES.clear(frame, sp - 1);
        }

        private static boolean doBranchFalse(Frame frame, byte[] bc, int bci, int sp) {
            CompilerDirectives.transferToInterpreterAndInvalidate();
            boolean value = (boolean)FRAMES.requireObject(frame, sp - 1);
            short newInstruction;
            short newOperand;
            int operandIndex = BYTES.getIntUnaligned(bc, bci + 10 /* imm child0 */);
            short operand = BYTES.getShort(bc, operandIndex);
            if ((newOperand = applyQuickeningBoolean(operand)) != -1) {
                newInstruction = Instructions.BRANCH_FALSE$BOOLEAN;
            } else {
                newInstruction = Instructions.BRANCH_FALSE$GENERIC;
                newOperand = operand;
            }
            BYTES.putShort(bc, operandIndex, newOperand);
            BYTES.putShort(bc, bci, newInstruction);
            return value;
        }

        private static boolean doBranchFalse$Generic(Frame frame, byte[] bc, int bci, int sp) {
            try {
                return (boolean) FRAMES.expectObject(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                return doBranchFalse(frame, bc, bci, sp);
            }
        }

        private static boolean doBranchFalse$Boolean(Frame frame, byte[] bc, int bci, int sp) {
            try {
                return FRAMES.expectBoolean(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                return doBranchFalse(frame, bc, bci, sp);
            }
        }

        private static void doMergeConditional(Frame frame, byte[] bc, int bci, int sp, Object local) {
            boolean condition = (boolean) FRAMES.getValue(frame, sp - 2);
            short newInstruction;
            short newOperand;
            short newOtherOperand;
            int operandIndex;
            int otherOperandIndex;
            if (condition) {
                operandIndex = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
                otherOperandIndex = BYTES.getIntUnaligned(bc, bci + 6 /* imm child1 */);
            } else {
                operandIndex = BYTES.getIntUnaligned(bc, bci + 6 /* imm child1 */);
                otherOperandIndex = BYTES.getIntUnaligned(bc, bci + 2 /* imm child0 */);
            }
            if (operandIndex != -1 && otherOperandIndex != -1) {
                short operand = BYTES.getShort(bc, operandIndex);
                short otherOperand = BYTES.getShort(bc, otherOperandIndex);
                if (local instanceof Long
                   && ((newOperand = applyQuickeningLong(operand)) != -1)) {
                    switch (BYTES.getShort(bc, bci)) {
                        case Instructions.MERGE_CONDITIONAL :
                        case Instructions.MERGE_CONDITIONAL$LONG :
                            newOtherOperand = otherOperand;
                            newInstruction = Instructions.MERGE_CONDITIONAL$LONG;
                            break;
                        case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                            newOtherOperand = otherOperand;
                            newInstruction = Instructions.MERGE_CONDITIONAL$LONG$UNBOXED;
                            break;
                        default :
                            newOtherOperand = undoQuickening(otherOperand);
                            newInstruction = Instructions.MERGE_CONDITIONAL$GENERIC;
                            break;
                    }
                } else if (local instanceof Boolean
                   && ((newOperand = applyQuickeningBoolean(operand)) != -1)) {
                    switch (BYTES.getShort(bc, bci)) {
                        case Instructions.MERGE_CONDITIONAL :
                        case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                            newOtherOperand = otherOperand;
                            newInstruction = Instructions.MERGE_CONDITIONAL$BOOLEAN;
                            break;
                        case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                            newOtherOperand = otherOperand;
                            newInstruction = Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED;
                            break;
                        default :
                            newOtherOperand = undoQuickening(otherOperand);
                            newInstruction = Instructions.MERGE_CONDITIONAL$GENERIC;
                            break;
                    }
                } else {
                    newOperand = operand;
                    newOtherOperand = undoQuickening(otherOperand);
                    newInstruction = Instructions.MERGE_CONDITIONAL$GENERIC;
                }
                BYTES.putShort(bc, operandIndex, newOperand);
                BYTES.putShort(bc, otherOperandIndex, newOtherOperand);
            } else {
                newInstruction = Instructions.MERGE_CONDITIONAL$GENERIC;
            }
            BYTES.putShort(bc, bci, newInstruction);
            FRAMES.setObject(frame, sp - 2, local);
            FRAMES.clear(frame, sp - 1);
        }

        private static void doMergeConditional$Long(Frame frame, byte[] bc, int bci, int sp) {
            long value;
            try {
                value = FRAMES.expectLong(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doMergeConditional(frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setObject(frame, sp - 2, value);
        }

        private static void doMergeConditional$Long$unboxed(Frame frame, byte[] bc, int bci, int sp) {
            long value;
            try {
                value = FRAMES.expectLong(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doMergeConditional(frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setLong(frame, sp - 2, value);
        }

        private static void doMergeConditional$Boolean(Frame frame, byte[] bc, int bci, int sp) {
            boolean value;
            try {
                value = FRAMES.expectBoolean(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doMergeConditional(frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setObject(frame, sp - 2, value);
        }

        private static void doMergeConditional$Boolean$unboxed(Frame frame, byte[] bc, int bci, int sp) {
            boolean value;
            try {
                value = FRAMES.expectBoolean(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doMergeConditional(frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setBoolean(frame, sp - 2, value);
        }

        private static void doMergeConditional$generic(Frame frame, byte[] bc, int bci, int sp) {
            Object value;
            try {
                value = FRAMES.expectObject(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doMergeConditional(frame, bc, bci, sp, ex.getResult());
                return;
            }
            FRAMES.setObject(frame, sp - 2, value);
            FRAMES.clear(frame, sp - 1);
        }

        private static void loadConstantCompiled(VirtualFrame frame, byte[] bc, int bci, int sp, Object[] constants) {
            Object constant = ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm constant */));
            if (constant instanceof Boolean b) {
                FRAMES.setObject(frame, sp, b.booleanValue());
                return;
            } else if (constant instanceof Byte b) {
                FRAMES.setObject(frame, sp, b.byteValue());
                return;
            } else if (constant instanceof Character c) {
                FRAMES.setObject(frame, sp, c.charValue());
                return;
            } else if (constant instanceof Float f) {
                FRAMES.setObject(frame, sp, f.floatValue());
                return;
            } else if (constant instanceof Integer i) {
                FRAMES.setObject(frame, sp, i.intValue());
                return;
            } else if (constant instanceof Long l) {
                FRAMES.setObject(frame, sp, l.longValue());
                return;
            } else if (constant instanceof Short s) {
                FRAMES.setObject(frame, sp, s.shortValue());
                return;
            } else if (constant instanceof Double d) {
                FRAMES.setObject(frame, sp, d.doubleValue());
                return;
            }
            FRAMES.setObject(frame, sp, constant);
        }

        private static int[] allocateBranchProfiles(int numProfiles) {
            // Encoding: [t1, f1, t2, f2, ..., tn, fn]
            return new int[numProfiles * 2];
        }

        private static boolean profileBranch(int[] branchProfiles, int profileIndex, boolean condition) {
            int t = ACCESS.readInt(branchProfiles, profileIndex * 2);
            int f = ACCESS.readInt(branchProfiles, profileIndex * 2 + 1);
            boolean val = condition;
            if (val) {
                if (t == 0) {
                    CompilerDirectives.transferToInterpreterAndInvalidate();
                }
                if (f == 0) {
                    // Make this branch fold during PE
                    val = true;
                }
                if (CompilerDirectives.inInterpreter()) {
                    if (t < Integer.MAX_VALUE) {
                        ACCESS.writeInt(branchProfiles, profileIndex * 2, t + 1);
                    }
                }
            } else {
                if (f == 0) {
                    CompilerDirectives.transferToInterpreterAndInvalidate();
                }
                if (t == 0) {
                    // Make this branch fold during PE
                    val = false;
                }
                if (CompilerDirectives.inInterpreter()) {
                    if (f < Integer.MAX_VALUE) {
                        ACCESS.writeInt(branchProfiles, profileIndex * 2 + 1, f + 1);
                    }
                }
            }
            if (CompilerDirectives.inInterpreter()) {
                // no branch probability calculation in the interpreter
                return val;
            } else {
                int sum = t + f;
                return CompilerDirectives.injectBranchProbability((double) t / (double) sum, val);
            }
        }

        private static void ensureFalseProfile(int[] branchProfiles, int profileIndex) {
            if (ACCESS.readInt(branchProfiles, profileIndex * 2 + 1) == 0) {
                ACCESS.writeInt(branchProfiles, profileIndex * 2 + 1, 1);
            }
        }

        private static byte[] unquickenBytecode(byte[] original) {
            byte[] copy = Arrays.copyOf(original, original.length);
            int bci = 0;
            while (bci < copy.length) {
                switch (BYTES.getShort(copy, bci)) {
                    case Instructions.LOAD_ARGUMENT$BOOLEAN :
                    case Instructions.LOAD_ARGUMENT$LONG :
                        BYTES.putShort(copy, bci, Instructions.LOAD_ARGUMENT);
                        bci += 4;
                        break;
                    case Instructions.LOAD_CONSTANT$BOOLEAN :
                    case Instructions.LOAD_CONSTANT$LONG :
                        BYTES.putShort(copy, bci, Instructions.LOAD_CONSTANT);
                        bci += 6;
                        break;
                    case Instructions.LOAD_LOCAL$BOOLEAN :
                    case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL$LONG :
                    case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.LOAD_LOCAL);
                        bci += 6;
                        break;
                    case Instructions.POP$BOOLEAN :
                    case Instructions.POP$LONG :
                    case Instructions.POP$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.POP);
                        bci += 6;
                        break;
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                    case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$LONG :
                    case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                    case Instructions.LOAD_LOCAL_MAT$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.LOAD_LOCAL_MAT);
                        bci += 8;
                        break;
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                    case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$LONG :
                    case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                    case Instructions.MERGE_CONDITIONAL$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.MERGE_CONDITIONAL);
                        bci += 10;
                        break;
                    case Instructions.STORE_LOCAL$BOOLEAN :
                    case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL$LONG :
                    case Instructions.STORE_LOCAL$LONG$LONG :
                    case Instructions.STORE_LOCAL$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.STORE_LOCAL);
                        bci += 10;
                        break;
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                    case Instructions.TAG_LEAVE$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.TAG_LEAVE);
                        bci += 10;
                        break;
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                    case Instructions.STORE_LOCAL_MAT$LONG :
                    case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                    case Instructions.STORE_LOCAL_MAT$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.STORE_LOCAL_MAT);
                        bci += 12;
                        break;
                    case Instructions.BRANCH_FALSE$BOOLEAN :
                    case Instructions.BRANCH_FALSE$GENERIC :
                        BYTES.putShort(copy, bci, Instructions.BRANCH_FALSE);
                        bci += 14;
                        break;
                    case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                        BYTES.putShort(copy, bci, Instructions.SL_LOAD_ARGUMENT_);
                        bci += 10;
                        break;
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                    case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_LOGICAL_NOT_);
                        bci += 10;
                        break;
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                    case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_TO_BOOLEAN_);
                        bci += 10;
                        break;
                    case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                    case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                    case Instructions.SL_UNBOX$FROM_LONG_ :
                    case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_UNBOX_);
                        bci += 10;
                        break;
                    case Instructions.SL_ADD$LONG_ :
                    case Instructions.SL_ADD$LONG$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_ADD_);
                        bci += 14;
                        break;
                    case Instructions.SL_DIV$LONG_ :
                    case Instructions.SL_DIV$LONG$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_DIV_);
                        bci += 14;
                        break;
                    case Instructions.SL_EQUAL$BOOLEAN_ :
                    case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                    case Instructions.SL_EQUAL$LONG_ :
                    case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_EQUAL$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_EQUAL_);
                        bci += 14;
                        break;
                    case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                    case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                    case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_LESS_OR_EQUAL_);
                        bci += 14;
                        break;
                    case Instructions.SL_LESS_THAN$LONG_ :
                    case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                    case Instructions.SL_LESS_THAN$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_LESS_THAN_);
                        bci += 14;
                        break;
                    case Instructions.SL_MUL$LONG_ :
                    case Instructions.SL_MUL$LONG$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_MUL_);
                        bci += 14;
                        break;
                    case Instructions.SL_SUB$LONG_ :
                    case Instructions.SL_SUB$LONG$UNBOXED_ :
                        BYTES.putShort(copy, bci, Instructions.SL_SUB_);
                        bci += 14;
                        break;
                    case Instructions.CONSTANT_NULL :
                    case Instructions.DUP :
                    case Instructions.INVALIDATE0 :
                    case Instructions.LOAD_NULL :
                    case Instructions.LOAD_VARIADIC_0 :
                    case Instructions.LOAD_VARIADIC_1 :
                    case Instructions.LOAD_VARIADIC_2 :
                    case Instructions.LOAD_VARIADIC_3 :
                    case Instructions.LOAD_VARIADIC_4 :
                    case Instructions.LOAD_VARIADIC_5 :
                    case Instructions.LOAD_VARIADIC_6 :
                    case Instructions.LOAD_VARIADIC_7 :
                    case Instructions.LOAD_VARIADIC_8 :
                    case Instructions.MERGE_VARIADIC :
                    case Instructions.RETURN :
                    case Instructions.THROW :
                        bci += 2;
                        break;
                    case Instructions.CLEAR_LOCAL :
                    case Instructions.INVALIDATE1 :
                    case Instructions.LOAD_ARGUMENT :
                    case Instructions.LOAD_EXCEPTION :
                        bci += 4;
                        break;
                    case Instructions.BRANCH :
                    case Instructions.SL_ALWAYS_HALT_ :
                    case Instructions.SL_FUNCTION_LITERAL_ :
                    case Instructions.SL_INVOKE_ :
                    case Instructions.SL_READ_PROPERTY_ :
                    case Instructions.SL_WRITE_PROPERTY_ :
                    case Instructions.INVALIDATE2 :
                    case Instructions.LOAD_CONSTANT :
                    case Instructions.LOAD_LOCAL :
                    case Instructions.POP :
                    case Instructions.TAG_ENTER :
                    case Instructions.TAG_LEAVE_VOID :
                        bci += 6;
                        break;
                    case Instructions.INVALIDATE3 :
                    case Instructions.LOAD_LOCAL_MAT :
                        bci += 8;
                        break;
                    case Instructions.BRANCH_BACKWARD :
                    case Instructions.SL_LOAD_ARGUMENT_ :
                    case Instructions.SL_LOGICAL_NOT_ :
                    case Instructions.SL_TO_BOOLEAN_ :
                    case Instructions.SL_UNBOX_ :
                    case Instructions.INVALIDATE4 :
                    case Instructions.MERGE_CONDITIONAL :
                    case Instructions.SL_AND_ :
                    case Instructions.SL_OR_ :
                    case Instructions.STORE_LOCAL :
                    case Instructions.TAG_LEAVE :
                        bci += 10;
                        break;
                    case Instructions.INVALIDATE5 :
                    case Instructions.STORE_LOCAL_MAT :
                        bci += 12;
                        break;
                    case Instructions.BRANCH_FALSE :
                    case Instructions.BUILTIN_ :
                    case Instructions.SL_ADD_ :
                    case Instructions.SL_DIV_ :
                    case Instructions.SL_EQUAL_ :
                    case Instructions.SL_LESS_OR_EQUAL_ :
                    case Instructions.SL_LESS_THAN_ :
                    case Instructions.SL_MUL_ :
                    case Instructions.SL_SUB_ :
                    case Instructions.INVALIDATE6 :
                        bci += 14;
                        break;
                }
            }
            return copy;
        }

    }
    @DenyReplace
    private static final class UncachedBytecodeNode extends AbstractBytecodeNode {

        private int uncachedExecuteCount_ = 16;

        UncachedBytecodeNode(byte[] bytecodes, Object[] constants, int[] handlers, int[] locals, int[] sourceInfo, List<Source> sources, int numNodes, TagRootNode tagRoot) {
            super(bytecodes, constants, handlers, locals, sourceInfo, sources, numNodes, tagRoot);
        }

        UncachedBytecodeNode(byte[] bytecodes, Object[] constants, int[] handlers, int[] locals, int[] sourceInfo, List<Source> sources, int numNodes, TagRootNode tagRoot, int uncachedExecuteCount_) {
            super(bytecodes, constants, handlers, locals, sourceInfo, sources, numNodes, tagRoot);
            this.uncachedExecuteCount_ = uncachedExecuteCount_;
        }

        @Override
        @BytecodeInterpreterSwitch
        long continueAt(SLBytecodeRootNodeGen $root, VirtualFrame frame, long startState) {
            EncapsulatingNodeReference encapsulatingNode = EncapsulatingNodeReference.getCurrent();
            Node prev = encapsulatingNode.set(this);
            try {
                int uncachedExecuteCount = this.uncachedExecuteCount_;
                if (uncachedExecuteCount <= 0 && uncachedExecuteCount != Integer.MIN_VALUE) {
                    $root.transitionToCached(frame, 0);
                    return startState;
                }
                byte[] bc = this.bytecodes;
                int bci = (int) (startState & 0xFFFFFFFFL);
                int sp = (int) (startState >>> 32);
                int op;
                long temp;
                loop: while (true) {
                    op = BYTES.getShort(bc, bci);
                    try {
                        switch (op) {
                            case Instructions.POP :
                            case Instructions.POP$LONG :
                            case Instructions.POP$BOOLEAN :
                            case Instructions.POP$GENERIC :
                            {
                                doPop(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 6;
                                break;
                            }
                            case Instructions.DUP :
                            {
                                FRAMES.copy(frame, sp - 1, sp);
                                sp += 1;
                                bci += 2;
                                break;
                            }
                            case Instructions.RETURN :
                            {
                                FRAMES.setInt(frame, BCI_INDEX, bci);
                                if (uncachedExecuteCount <= 1) {
                                    if (uncachedExecuteCount != Integer.MIN_VALUE) {
                                        CompilerDirectives.transferToInterpreterAndInvalidate();
                                        $root.transitionToCached(frame, bci);
                                    }
                                } else {
                                    uncachedExecuteCount--;
                                    this.uncachedExecuteCount_ = uncachedExecuteCount;
                                }
                                return (((long) (sp - 1)) << 32) | 0xFFFFFFFFL;
                            }
                            case Instructions.BRANCH :
                            {
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                break;
                            }
                            case Instructions.BRANCH_BACKWARD :
                            {
                                bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                if (uncachedExecuteCount <= 1) {
                                    if (uncachedExecuteCount != Integer.MIN_VALUE) {
                                        CompilerDirectives.transferToInterpreterAndInvalidate();
                                        $root.transitionToCached(frame, bci);
                                        return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                                    }
                                } else {
                                    uncachedExecuteCount--;
                                }
                                break;
                            }
                            case Instructions.BRANCH_FALSE :
                            case Instructions.BRANCH_FALSE$GENERIC :
                            case Instructions.BRANCH_FALSE$BOOLEAN :
                            {
                                if ((Boolean) FRAMES.uncheckedGetObject(frame, sp - 1) == Boolean.TRUE) {
                                    sp -= 1;
                                    bci += 14;
                                    break;
                                } else {
                                    sp -= 1;
                                    bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                    break;
                                }
                            }
                            case Instructions.STORE_LOCAL :
                            case Instructions.STORE_LOCAL$LONG :
                            case Instructions.STORE_LOCAL$LONG$LONG :
                            case Instructions.STORE_LOCAL$BOOLEAN :
                            case Instructions.STORE_LOCAL$BOOLEAN$BOOLEAN :
                            case Instructions.STORE_LOCAL$GENERIC :
                            {
                                doStoreLocal(frame, bc, bci, sp);
                                FRAMES.clear(frame, sp - 1);
                                sp -= 1;
                                bci += 10;
                                break;
                            }
                            case Instructions.THROW :
                            {
                                throw sneakyThrow((Throwable) FRAMES.uncheckedGetObject(frame, sp - 1));
                            }
                            case Instructions.LOAD_CONSTANT :
                            case Instructions.LOAD_CONSTANT$LONG :
                            case Instructions.LOAD_CONSTANT$BOOLEAN :
                            {
                                FRAMES.setObject(frame, sp, ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm constant */)));
                                sp += 1;
                                bci += 6;
                                break;
                            }
                            case Instructions.LOAD_NULL :
                            {
                                FRAMES.setObject(frame, sp, null);
                                sp += 1;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_ARGUMENT :
                            case Instructions.LOAD_ARGUMENT$LONG :
                            case Instructions.LOAD_ARGUMENT$BOOLEAN :
                            {
                                FRAMES.setObject(frame, sp, frame.getArguments()[BYTES.getShort(bc, bci + 2 /* imm index */)]);
                                sp += 1;
                                bci += 4;
                                break;
                            }
                            case Instructions.LOAD_EXCEPTION :
                            {
                                FRAMES.setObject(frame, sp, FRAMES.getObject(frame, $root.maxLocals + BYTES.getShort(bc, bci + 2 /* imm exceptionSp */)));
                                sp += 1;
                                bci += 4;
                                break;
                            }
                            case Instructions.LOAD_LOCAL :
                            case Instructions.LOAD_LOCAL$LONG :
                            case Instructions.LOAD_LOCAL$LONG$UNBOXED :
                            case Instructions.LOAD_LOCAL$BOOLEAN :
                            case Instructions.LOAD_LOCAL$BOOLEAN$UNBOXED :
                            case Instructions.LOAD_LOCAL$GENERIC :
                            {
                                doLoadLocal(frame, bc, bci, sp);
                                sp += 1;
                                bci += 6;
                                break;
                            }
                            case Instructions.LOAD_LOCAL_MAT :
                            case Instructions.LOAD_LOCAL_MAT$LONG :
                            case Instructions.LOAD_LOCAL_MAT$LONG$UNBOXED :
                            case Instructions.LOAD_LOCAL_MAT$BOOLEAN :
                            case Instructions.LOAD_LOCAL_MAT$BOOLEAN$UNBOXED :
                            case Instructions.LOAD_LOCAL_MAT$GENERIC :
                            {
                                doLoadLocalMat(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 1)), bc, bci, sp);
                                bci += 8;
                                break;
                            }
                            case Instructions.STORE_LOCAL_MAT :
                            case Instructions.STORE_LOCAL_MAT$LONG :
                            case Instructions.STORE_LOCAL_MAT$LONG$LONG :
                            case Instructions.STORE_LOCAL_MAT$BOOLEAN :
                            case Instructions.STORE_LOCAL_MAT$BOOLEAN$BOOLEAN :
                            case Instructions.STORE_LOCAL_MAT$GENERIC :
                            {
                                doStoreLocalMat(frame, ((VirtualFrame) FRAMES.uncheckedGetObject(frame, sp - 2)), bc, bci, sp);
                                sp -= 2;
                                bci += 12;
                                break;
                            }
                            case Instructions.TAG_ENTER :
                            {
                                doTagEnter(frame, bc, bci, sp);
                                bci += 6;
                                break;
                            }
                            case Instructions.TAG_LEAVE :
                            case Instructions.TAG_LEAVE$LONG :
                            case Instructions.TAG_LEAVE$LONG$UNBOXED :
                            case Instructions.TAG_LEAVE$BOOLEAN :
                            case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                            case Instructions.TAG_LEAVE$GENERIC :
                            {
                                doTagLeave(frame, bc, bci, sp);
                                bci += 10;
                                break;
                            }
                            case Instructions.TAG_LEAVE_VOID :
                            {
                                doTagLeaveVoid(frame, bc, bci, sp);
                                bci += 6;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_0 :
                            {
                                FRAMES.setObject(frame, sp, EMPTY_ARRAY);
                                sp += 1;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_1 :
                            {
                                FRAMES.setObject(frame, sp - 1, readVariadic(frame, sp, 1));
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_2 :
                            {
                                FRAMES.setObject(frame, sp - 2, readVariadic(frame, sp, 2));
                                sp -= 1;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_3 :
                            {
                                FRAMES.setObject(frame, sp - 3, readVariadic(frame, sp, 3));
                                sp -= 2;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_4 :
                            {
                                FRAMES.setObject(frame, sp - 4, readVariadic(frame, sp, 4));
                                sp -= 3;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_5 :
                            {
                                FRAMES.setObject(frame, sp - 5, readVariadic(frame, sp, 5));
                                sp -= 4;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_6 :
                            {
                                FRAMES.setObject(frame, sp - 6, readVariadic(frame, sp, 6));
                                sp -= 5;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_7 :
                            {
                                FRAMES.setObject(frame, sp - 7, readVariadic(frame, sp, 7));
                                sp -= 6;
                                bci += 2;
                                break;
                            }
                            case Instructions.LOAD_VARIADIC_8 :
                            {
                                FRAMES.setObject(frame, sp - 8, readVariadic(frame, sp, 8));
                                sp -= 7;
                                bci += 2;
                                break;
                            }
                            case Instructions.MERGE_VARIADIC :
                            {
                                FRAMES.setObject(frame, sp - 1, mergeVariadic((Object[]) FRAMES.uncheckedGetObject(frame, sp - 1)));
                                bci += 2;
                                break;
                            }
                            case Instructions.CONSTANT_NULL :
                            {
                                FRAMES.setObject(frame, sp, null);
                                sp += 1;
                                bci += 2;
                                break;
                            }
                            case Instructions.CLEAR_LOCAL :
                            {
                                FRAMES.clear(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */));
                                bci += 4;
                                break;
                            }
                            case Instructions.SL_ALWAYS_HALT_ :
                            {
                                doSLAlwaysHalt_(frame, bc, bci, sp);
                                bci += 6;
                                break;
                            }
                            case Instructions.SL_LOAD_ARGUMENT_ :
                            case Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ :
                            {
                                doSLLoadArgument_(frame, bc, bci, sp);
                                sp += 1;
                                bci += 10;
                                break;
                            }
                            case Instructions.BUILTIN_ :
                            {
                                doBuiltin_(frame, bc, bci, sp);
                                sp += 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_INVOKE_ :
                            {
                                doSLInvoke_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 6;
                                break;
                            }
                            case Instructions.SL_ADD_ :
                            case Instructions.SL_ADD$LONG_ :
                            case Instructions.SL_ADD$LONG$UNBOXED_ :
                            {
                                doSLAdd_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_DIV_ :
                            case Instructions.SL_DIV$LONG_ :
                            case Instructions.SL_DIV$LONG$UNBOXED_ :
                            {
                                doSLDiv_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_EQUAL_ :
                            case Instructions.SL_EQUAL$LONG_ :
                            case Instructions.SL_EQUAL$LONG$UNBOXED_ :
                            case Instructions.SL_EQUAL$BOOLEAN_ :
                            case Instructions.SL_EQUAL$BOOLEAN$UNBOXED_ :
                            case Instructions.SL_EQUAL$UNBOXED_ :
                            {
                                doSLEqual_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_LESS_OR_EQUAL_ :
                            case Instructions.SL_LESS_OR_EQUAL$LONG_ :
                            case Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_ :
                            case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ :
                            case Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ :
                            {
                                doSLLessOrEqual_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_LESS_THAN_ :
                            case Instructions.SL_LESS_THAN$LONG_ :
                            case Instructions.SL_LESS_THAN$LONG$UNBOXED_ :
                            case Instructions.SL_LESS_THAN$UNBOXED_ :
                            {
                                doSLLessThan_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_LOGICAL_NOT_ :
                            case Instructions.SL_LOGICAL_NOT$BOOLEAN_ :
                            case Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ :
                            case Instructions.SL_LOGICAL_NOT$UNBOXED_ :
                            {
                                doSLLogicalNot_(frame, bc, bci, sp);
                                bci += 10;
                                break;
                            }
                            case Instructions.SL_MUL_ :
                            case Instructions.SL_MUL$LONG_ :
                            case Instructions.SL_MUL$LONG$UNBOXED_ :
                            {
                                doSLMul_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_READ_PROPERTY_ :
                            {
                                doSLReadProperty_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 6;
                                break;
                            }
                            case Instructions.SL_SUB_ :
                            case Instructions.SL_SUB$LONG_ :
                            case Instructions.SL_SUB$LONG$UNBOXED_ :
                            {
                                doSLSub_(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 14;
                                break;
                            }
                            case Instructions.SL_WRITE_PROPERTY_ :
                            {
                                doSLWriteProperty_(frame, bc, bci, sp);
                                sp -= 2;
                                bci += 6;
                                break;
                            }
                            case Instructions.SL_UNBOX_ :
                            case Instructions.SL_UNBOX$FROM_BOOLEAN_ :
                            case Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_ :
                            case Instructions.SL_UNBOX$FROM_LONG_ :
                            case Instructions.SL_UNBOX$FROM_LONG$UNBOXED_ :
                            {
                                doSLUnbox_(frame, bc, bci, sp);
                                bci += 10;
                                break;
                            }
                            case Instructions.SL_FUNCTION_LITERAL_ :
                            {
                                doSLFunctionLiteral_(frame, bc, bci, sp);
                                bci += 6;
                                break;
                            }
                            case Instructions.SL_TO_BOOLEAN_ :
                            case Instructions.SL_TO_BOOLEAN$BOOLEAN_ :
                            case Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ :
                            case Instructions.SL_TO_BOOLEAN$UNBOXED_ :
                            {
                                doSLToBoolean_(frame, bc, bci, sp);
                                bci += 10;
                                break;
                            }
                            case Instructions.SL_AND_ :
                            {
                                if (!(boolean) FRAMES.uncheckedGetObject(frame, sp - 1)) {
                                    bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                    break;
                                } else {
                                    FRAMES.clear(frame, sp - 1);
                                    sp -= 1;
                                    bci += 10;
                                    break;
                                }
                            }
                            case Instructions.SL_OR_ :
                            {
                                if ((boolean) FRAMES.uncheckedGetObject(frame, sp - 1)) {
                                    bci = BYTES.getIntUnaligned(bc, bci + 2 /* imm branch_target */);
                                    break;
                                } else {
                                    FRAMES.clear(frame, sp - 1);
                                    sp -= 1;
                                    bci += 10;
                                    break;
                                }
                            }
                            case Instructions.MERGE_CONDITIONAL :
                            case Instructions.MERGE_CONDITIONAL$LONG :
                            case Instructions.MERGE_CONDITIONAL$LONG$UNBOXED :
                            case Instructions.MERGE_CONDITIONAL$BOOLEAN :
                            case Instructions.MERGE_CONDITIONAL$BOOLEAN$UNBOXED :
                            case Instructions.MERGE_CONDITIONAL$GENERIC :
                            {
                                doMergeConditional(frame, bc, bci, sp);
                                sp -= 1;
                                bci += 10;
                                break;
                            }
                            case Instructions.INVALIDATE0 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                            case Instructions.INVALIDATE1 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                            case Instructions.INVALIDATE2 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                            case Instructions.INVALIDATE3 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                            case Instructions.INVALIDATE4 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                            case Instructions.INVALIDATE5 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                            case Instructions.INVALIDATE6 :
                            {
                                return (((long) sp) << 32) | (bci & 0xFFFFFFFFL);
                            }
                        }
                    } catch (Throwable throwable) {
                        FRAMES.setInt(frame, BCI_INDEX, bci);
                        throwable = resolveThrowable($root, frame, bci, throwable);
                        op = -EXCEPTION_HANDLER_LENGTH;
                        while ((op = resolveHandler(bci, op + EXCEPTION_HANDLER_LENGTH, this.handlers)) != -1) {
                            try {
                                switch (this.handlers[op + EXCEPTION_HANDLER_OFFSET_KIND]) {
                                    case HANDLER_TAG_EXCEPTIONAL :
                                        long result = doTagExceptional($root, frame, bc, bci, throwable, this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI], this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_SP]);
                                        temp = (int) (result >>> 32);
                                        bci = (int) (result & 0xFFFFFFFFL);
                                        if (sp < (int) temp + $root.maxLocals) {
                                            // The instrumentation pushed a value on the stack.
                                            assert sp == (int) temp + $root.maxLocals - 1;
                                            sp++;
                                        }
                                        break;
                                    default :
                                        if (throwable instanceof java.lang.ThreadDeath) {
                                            continue;
                                        }
                                        assert throwable instanceof AbstractTruffleException;
                                        bci = this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
                                        temp = this.handlers[op + EXCEPTION_HANDLER_OFFSET_HANDLER_SP];
                                        FRAMES.setObject(frame, ((int) temp) - 1 + $root.maxLocals, throwable);
                                        break;
                                }
                            } catch (Throwable t) {
                                if (t != throwable) {
                                    throwable = resolveThrowable($root, frame, bci, t);
                                }
                                continue;
                            }
                            temp = temp + $root.maxLocals;
                            assert sp >= temp - 1;
                            while (sp > temp) {
                                FRAMES.clear(frame, --sp);
                            }
                            sp = (int) temp;
                            continue loop;
                        }
                        if (uncachedExecuteCount <= 1) {
                            if (uncachedExecuteCount != Integer.MIN_VALUE) {
                                CompilerDirectives.transferToInterpreterAndInvalidate();
                                $root.transitionToCached(frame, bci);
                            }
                        } else {
                            uncachedExecuteCount--;
                            this.uncachedExecuteCount_ = uncachedExecuteCount;
                        }
                        throw sneakyThrow(throwable);
                    }
                }
            } finally {
                encapsulatingNode.set(prev);
            }
        }

        private void doStoreLocal(Frame frame, byte[] bc, int bci, int sp) {
            Object local = FRAMES.requireObject(frame, sp - 1);
            FRAMES.setObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */), local);
            FRAMES.clear(frame, sp - 1);
        }

        private void doLoadLocal(Frame frame, byte[] bc, int bci, int sp) {
            FRAMES.setObject(frame, sp, FRAMES.requireObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
        }

        private void doLoadLocalMat(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            FRAMES.setObject(stackFrame, sp - 1, FRAMES.requireObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */)));
        }

        private void doStoreLocalMat(Frame stackFrame, Frame frame, byte[] bc, int bci, int sp) {
            Object local = FRAMES.requireObject(stackFrame, sp - 1);
            FRAMES.setObject(frame, BYTES.getShort(bc, bci + 2 /* imm localOffset */), local);
            FRAMES.clear(stackFrame, sp - 1);
            FRAMES.clear(stackFrame, sp - 2);
        }

        @InliningCutoff
        private void doTagEnter(VirtualFrame frame, byte[] bc, int bci, int sp) {
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onEnter(frame);
        }

        private void doTagLeave(VirtualFrame frame, byte[] bc, int bci, int sp) {
            Object returnValue;
            try {
                returnValue = FRAMES.expectObject(frame, sp - 1);
            } catch (UnexpectedResultException ex) {
                doTagLeave(frame, bc, bci, sp);
                return;
            }
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, returnValue);
        }

        @InliningCutoff
        private void doTagLeaveVoid(VirtualFrame frame, byte[] bc, int bci, int sp) {
            TagNode tagNode = ACCESS.uncheckedCast(ACCESS.readObject(tagRoot.tagNodes, BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */)), TagNode.class);
            tagNode.findProbe().onReturnValue(frame, null);
        }

        private void doSLAlwaysHalt_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            SLAlwaysHalt_Node.UNCACHED.executeUncached(frame, this, bc, bci, sp);
        }

        private void doSLLoadArgument_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLLoadArgument_Node.UNCACHED.executeUncached(frame, ACCESS.uncheckedCast(ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm index */)), Integer.class), this, bc, bci, sp);
            FRAMES.setObject(frame, sp, result);
        }

        private void doBuiltin_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = Builtin_Node.UNCACHED.executeUncached(frame, ACCESS.uncheckedCast(ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 2 /* imm builtin */)), SLBuiltinNode.class), ACCESS.uncheckedCast(ACCESS.readObject(constants, BYTES.getIntUnaligned(bc, bci + 6 /* imm argumentCount */)), Integer.class), this, bc, bci, sp);
            FRAMES.setObject(frame, sp, result);
        }

        private void doSLInvoke_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLInvoke_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), (Object[]) FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLAdd_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLAdd_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLDiv_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLDiv_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLEqual_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            boolean result = SLEqual_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessOrEqual_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLLessOrEqual_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLessThan_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            boolean result = SLLessThan_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLLogicalNot_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            boolean result = SLLogicalNot_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLMul_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLMul_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLReadProperty_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLReadProperty_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLSub_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLSub_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 2, result);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLWriteProperty_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLWriteProperty_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 3), FRAMES.uncheckedGetObject(frame, sp - 2), FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 3, result);
            FRAMES.clear(frame, sp - 2);
            FRAMES.clear(frame, sp - 1);
        }

        private void doSLUnbox_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            Object result = SLUnbox_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLFunctionLiteral_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            SLFunction result = SLFunctionLiteral_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        private void doSLToBoolean_(VirtualFrame frame, byte[] bc, int bci, int sp) {
            FRAMES.setInt(frame, BCI_INDEX, bci);
            boolean result = SLToBoolean_Node.UNCACHED.executeUncached(frame, FRAMES.uncheckedGetObject(frame, sp - 1), this, bc, bci, sp);
            FRAMES.setObject(frame, sp - 1, result);
        }

        @Override
        public void setUncachedThreshold(int threshold) {
            CompilerAsserts.neverPartOfCompilation();
            if (threshold < 0 && threshold != Integer.MIN_VALUE) {
                throw new IllegalArgumentException("threshold cannot be a negative value other than Integer.MIN_VALUE");
            }
            uncachedExecuteCount_ = threshold;
        }

        @Override
        public BytecodeTier getTier() {
            return BytecodeTier.UNCACHED;
        }

        @InliningCutoff
        private Throwable resolveThrowable(SLBytecodeRootNodeGen $root, VirtualFrame frame, int bci, Throwable throwable) {
            if (throwable instanceof AbstractTruffleException ate) {
                return ate;
            } else if (throwable instanceof ControlFlowException cfe) {
                throw cfe;
            } else if (throwable instanceof java.lang.ThreadDeath cfe) {
                return cfe;
            } else {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                throw sneakyThrow(throwable);
            }
        }

        private long doTagExceptional(SLBytecodeRootNodeGen $root, VirtualFrame frame, byte[] bc, int bci, Throwable exception, int nodeId, int handlerSp) throws Throwable {
            boolean wasOnReturnExecuted;
            int nextBci;
            int nextSp;
            switch (readValidBytecode(bc, bci)) {
                case Instructions.TAG_LEAVE :
                case Instructions.TAG_LEAVE$LONG :
                case Instructions.TAG_LEAVE$LONG$UNBOXED :
                case Instructions.TAG_LEAVE$BOOLEAN :
                case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                case Instructions.TAG_LEAVE$GENERIC :
                    wasOnReturnExecuted = BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */) == nodeId;
                    break;
                case Instructions.TAG_LEAVE_VOID :
                    wasOnReturnExecuted = BYTES.getIntUnaligned(bc, bci + 2 /* imm tag */) == nodeId;
                    break;
                default :
                    wasOnReturnExecuted = false;
                    break;
            }
            TagNode node = this.tagRoot.tagNodes[nodeId];
            Object result = node.findProbe().onReturnExceptionalOrUnwind(frame, exception, wasOnReturnExecuted);
            if (result == null) {
                throw exception;
            } else if (result == ProbeNode.UNWIND_ACTION_REENTER) {
                // Reenter by jumping to the begin bci.
                return (((long) handlerSp) << 32) | (node.enterBci & 0xFFFFFFFFL);
            } else {
                // We jump to the return address which is at sp + 1.
                int targetSp;
                int targetBci;
                switch (readValidBytecode(bc, node.returnBci)) {
                    case Instructions.TAG_LEAVE :
                    case Instructions.TAG_LEAVE$LONG :
                    case Instructions.TAG_LEAVE$BOOLEAN :
                    case Instructions.TAG_LEAVE$GENERIC :
                        targetBci = node.returnBci + 10;
                        targetSp = handlerSp + 1 ;
                        FRAMES.setObject(frame, targetSp - 1 + $root.maxLocals, result);
                        break;
                    case Instructions.TAG_LEAVE$LONG$UNBOXED :
                        targetBci = node.returnBci + 10;
                        targetSp = handlerSp + 1 ;
                        try {
                            FRAMES.setLong(frame, targetSp - 1 + $root.maxLocals, SLBytecodeRootNodeGen.expectLong(result));
                        } catch (UnexpectedResultException e) {
                            FRAMES.setObject(frame, targetSp - 1 + $root.maxLocals, e.getResult());
                        }
                        break;
                    case Instructions.TAG_LEAVE$BOOLEAN$UNBOXED :
                        targetBci = node.returnBci + 10;
                        targetSp = handlerSp + 1 ;
                        try {
                            FRAMES.setBoolean(frame, targetSp - 1 + $root.maxLocals, SLBytecodeRootNodeGen.expectBoolean(result));
                        } catch (UnexpectedResultException e) {
                            FRAMES.setObject(frame, targetSp - 1 + $root.maxLocals, e.getResult());
                        }
                        break;
                    case Instructions.TAG_LEAVE_VOID :
                        targetBci = node.returnBci + 6;
                        targetSp = handlerSp ;
                        // discard return value
                        break;
                    default :
                        throw CompilerDirectives.shouldNotReachHere();
                }
                assert targetBci < bc.length : "returnBci must be reachable";
                return (((long) targetSp) << 32) | (targetBci & 0xFFFFFFFFL);
            }
        }

        @Override
        byte[] getLocalTags() {
            return null;
        }

        @Override
        AbstractBytecodeNode toCached(int numLocals) {
            return new CachedBytecodeNode(this.bytecodes, this.constants, this.handlers, this.locals, this.sourceInfo, this.sources, this.numNodes, this.tagRoot, numLocals);
        }

        @Override
        AbstractBytecodeNode update(byte[] bytecodes_, Object[] constants_, int[] handlers_, int[] locals_, int[] sourceInfo_, List<Source> sources_, int numNodes_, TagRootNode tagRoot_) {
            assert bytecodes_ != null || sourceInfo_ != null;
            byte[] bytecodes__;
            Object[] constants__;
            int[] handlers__;
            int[] locals__;
            int[] sourceInfo__;
            List<Source> sources__;
            int numNodes__;
            TagRootNode tagRoot__;
            if (bytecodes_ != null) {
                bytecodes__ = bytecodes_;
                constants__ = constants_;
                handlers__ = handlers_;
                numNodes__ = numNodes_;
                locals__ = locals_;
                tagRoot__ = tagRoot_;
            } else {
                bytecodes__ = this.bytecodes;
                constants__ = this.constants;
                handlers__ = this.handlers;
                numNodes__ = this.numNodes;
                locals__ = this.locals;
                tagRoot__ = this.tagRoot;
            }
            if (sourceInfo_ != null) {
                sourceInfo__ = sourceInfo_;
                sources__ = sources_;
            } else {
                sourceInfo__ = this.sourceInfo;
                sources__ = this.sources;
            }
            return new UncachedBytecodeNode(bytecodes__, constants__, handlers__, locals__, sourceInfo__, sources__, numNodes__, tagRoot__, this.uncachedExecuteCount_);
        }

        @Override
        AbstractBytecodeNode cloneUninitialized() {
            return new UncachedBytecodeNode(Arrays.copyOf(this.bytecodes, this.bytecodes.length), this.constants, this.handlers, this.locals, this.sourceInfo, this.sources, this.numNodes, tagRoot != null ? (TagRootNode) tagRoot.deepCopy() : null);
        }

        @Override
        Node[] getCachedNodes() {
            return null;
        }

        @Override
        int[] getBranchProfiles() {
            return null;
        }

        @Override
        @TruffleBoundary
        protected int findBytecodeIndex(FrameInstance frameInstance) {
            return frameInstance.getFrame(FrameAccess.READ_ONLY).getInt(BCI_INDEX);
        }

        @Override
        protected int findBytecodeIndex(Frame frame, Node node) {
            return frame.getInt(BCI_INDEX);
        }

        int findBytecodeIndexOfOperationNode(Node operationNode) {
            return -1;
        }

        @Override
        public String toString() {
            return String.format("BytecodeNode [name=%s, sources=%s, tier=uncached]", ((RootNode) getParent()).getQualifiedName(), this.sourceInfo != null);
        }

        private static void doPop(Frame frame, byte[] bc, int bci, int sp) {
            FRAMES.clear(frame, sp - 1);
        }

        private static void doMergeConditional(Frame frame, byte[] bc, int bci, int sp) {
            Object value = FRAMES.requireObject(frame, sp - 1);
            FRAMES.setObject(frame, sp - 2, value);
            FRAMES.clear(frame, sp - 1);
        }

        @ExplodeLoop
        private static int resolveHandler(int bci, int handler, int[] localHandlers) {
            for (int i = handler; i < localHandlers.length; i += EXCEPTION_HANDLER_LENGTH) {
                if (localHandlers[i + EXCEPTION_HANDLER_OFFSET_START_BCI] > bci) {
                    continue;
                }
                if (localHandlers[i + EXCEPTION_HANDLER_OFFSET_END_BCI] <= bci) {
                    continue;
                }
                return i;
            }
            return -1;
        }

    }
    /**
     * Builder class to generate bytecode. An interpreter can invoke this class with its {@link com.oracle.truffle.api.bytecode.BytecodeParser} to generate bytecode.
     */
    public static final class Builder extends BytecodeBuilder {

        private static final byte UNINITIALIZED = -1;
        private static final String[] OPERATION_NAMES = new String[] {null, "Block", "Root", "IfThen", "IfThenElse", "Conditional", "While", "TryCatch", "FinallyTry", "FinallyTryCatch", "FinallyHandler", "Label", "Branch", "LoadConstant", "LoadNull", "LoadArgument", "LoadException", "LoadLocal", "LoadLocalMaterialized", "StoreLocal", "StoreLocalMaterialized", "Return", "Source", "SourceSection", "Tag", "SLAlwaysHalt", "SLLoadArgument", "Builtin", "SLInvoke", "SLAdd", "SLDiv", "SLEqual", "SLLessOrEqual", "SLLessThan", "SLLogicalNot", "SLMul", "SLReadProperty", "SLSub", "SLWriteProperty", "SLUnbox", "SLFunctionLiteral", "SLToBoolean", "SLAnd", "SLOr"};
        private static final Class<?>[] TAGS_ROOT_TAG = new Class<?>[]{RootTag.class};
        private static final Class<?>[] TAGS_ALWAYS_HALT = new Class<?>[]{AlwaysHalt.class};

        private int operationSequenceNumber;
        private OperationStackEntry[] operationStack;
        private int operationSp;
        private int rootOperationSp;
        private int numLocals;
        private int numLabels;
        private int numNodes;
        private int numHandlers;
        private int numConditionalBranches;
        private byte[] bc;
        private int bci;
        private int currentStackHeight;
        private int maxStackHeight;
        private int[] sourceInfo;
        private int sourceInfoIndex;
        private int[] handlerTable;
        private int handlerTableSize;
        private int[] locals;
        private int localsTableIndex;
        private HashMap<BytecodeLabel, ArrayList<Integer>> unresolvedLabels;
        private ConstantPool constantPool;
        private boolean reachable = true;
        private int maxLocals;
        private List<TagNode> tagRoots;
        private List<TagNode> tagNodes;
        private SavedState savedState;
        private final SLLanguage language;
        private final BytecodeRootNodesImpl nodes;
        private final CharSequence reparseReason;
        private final boolean parseBytecodes;
        private final int tags;
        private final int instrumentations;
        private final boolean parseSources;
        private final ArrayList<SLBytecodeRootNodeGen> builtNodes;
        private int numRoots;
        private final ArrayList<Source> sources;
        private SerializationState serialization;

        /**
         * Constructor for initial parses.
         */
        private Builder(SLLanguage language, BytecodeRootNodesImpl nodes, BytecodeConfig config) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.language = language;
            this.nodes = nodes;
            this.reparseReason = null;
            long encoding = BytecodeConfigEncoderImpl.decode(config);
            this.tags = (int)((encoding >> 32) & 0xFFFF_FFFF);
            this.instrumentations = (int)((encoding >> 1) & 0x7FFF_FFFF);
            this.parseSources = (encoding & 0x1) != 0;
            this.parseBytecodes = true;
            this.sources = parseSources ? new ArrayList<>(4) : null;
            this.builtNodes = new ArrayList<>();
            this.operationStack = new OperationStackEntry[8];
            this.rootOperationSp = -1;
        }

        /**
         * Constructor for reparsing.
         */
        private Builder(BytecodeRootNodesImpl nodes, boolean parseBytecodes, int tags, int instrumentations, boolean parseSources, CharSequence reparseReason) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.language = nodes.getLanguage();
            this.nodes = nodes;
            this.reparseReason = reparseReason;
            this.parseBytecodes = parseBytecodes;
            this.tags = tags;
            this.instrumentations = instrumentations;
            this.parseSources = parseSources;
            this.sources = parseSources ? new ArrayList<>(4) : null;
            this.builtNodes = new ArrayList<>();
            this.operationStack = new OperationStackEntry[8];
            this.rootOperationSp = -1;
        }

        /**
         * Creates a new local. Uses default values for the local's metadata.
         */
        public BytecodeLocal createLocal() {
            return createLocal(null, null);
        }

        /**
         * Creates a new local. Uses the given {@code name} and {@code info} in its local metadata.
         *
         * @param name the name assigned to the local's slot.
         * @param info the info assigned to the local's slot.
         * @see BytecodeNode#getLocalNames
         * @see BytecodeNode#getLocalInfos
         */
        public BytecodeLocal createLocal(Object name, Object info) {
            if (serialization != null) {
                try {
                    int nameId;
                    if (name != null) {
                        nameId = serialization.serializeObject(name);
                    } else {
                        nameId = -1;
                    }
                    int infoId;
                    if (info != null) {
                        infoId = serialization.serializeObject(info);
                    } else {
                        infoId = -1;
                    }
                    serialization.buffer.writeShort(SerializationState.CODE_$CREATE_LOCAL);
                    serialization.buffer.writeInt(nameId);
                    serialization.buffer.writeInt(infoId);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return new SerializationLocal(serialization.depth, serialization.localCount++);
            }
            ScopeData scope = getCurrentScope();
            short localIndex = allocateBytecodeLocal() /* unique global index */;
            short frameIndex = safeCastShort(USER_LOCALS_START_INDEX + scope.frameOffset + scope.numLocals) /* location in frame */;
            int tableIndex = doEmitLocal(localIndex, frameIndex, name, info) /* index in global table */;
            scope.registerLocal(tableIndex);
            BytecodeLocalImpl local = new BytecodeLocalImpl(frameIndex, localIndex, ((RootData) operationStack[this.rootOperationSp].data).index, scope);
            return local;
        }

        /**
         * Creates a new label. The result should be {@link #emitLabel emitted} and can be {@link #emitBranch branched to}.
         */
        public BytecodeLabel createLabel() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_$CREATE_LABEL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return new SerializationLabel(serialization.depth, serialization.labelCount++);
            }
            if (operationSp == 0 || (operationStack[operationSp - 1].operation != Operations.BLOCK && operationStack[operationSp - 1].operation != Operations.ROOT)) {
                throw failState("Labels must be created inside either Block or Root operations.");
            }
            BytecodeLabel result = new BytecodeLabelImpl(numLabels++, UNINITIALIZED, operationStack[operationSp - 1].sequenceNumber);
            operationStack[operationSp - 1].addDeclaredLabel(result);
            return result;
        }

        /**
         * Begins a built-in SourceSection operation with an unavailable source section.
         *
         * @see #beginSourceSection(int, int)
         * @see #endSourceSectionUnavailable()
         */
        public void beginSourceSectionUnavailable() {
            beginSourceSection(-1, -1);
        }

        /**
         * Ends a built-in SourceSection operation with an unavailable source section.
         *
         * @see #endSourceSection()
         * @see #beginSourceSectionUnavailable()
         */
        public void endSourceSectionUnavailable() {
            endSourceSection();
        }

        private void registerUnresolvedLabel(BytecodeLabel label, int immediateBci) {
            ArrayList<Integer> locations = unresolvedLabels.computeIfAbsent(label, k -> new ArrayList<>());
            locations.add(immediateBci);
        }

        private void resolveUnresolvedLabel(BytecodeLabel label, int stackHeight) {
            BytecodeLabelImpl impl = (BytecodeLabelImpl) label;
            assert !impl.isDefined();
            impl.bci = bci;
            List<Integer> sites = unresolvedLabels.remove(impl);
            if (sites != null) {
                for (Integer site : sites) {
                    BYTES.putInt(bc, site, impl.bci);
                }
            }
        }

        /**
         * Begins a built-in Block operation.
         * <p>
         * Signature: Block(body...) -> void/Object
         * <p>
         * Block is a grouping operation that executes each child in its body sequentially, producing the result of the last child (if any).
         * This operation can be used to group multiple operations together in a single operation.
         * The result of a Block is the result produced by the last child (or void, if no value is produced).
         * <p>
         * A corresponding call to {@link #endBlock} is required to end the operation.
         */
        public void beginBlock() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_BLOCK);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            ScopeData parentScope = getCurrentScope();
            beforeChild();
            BlockData operationData = new BlockData(this.currentStackHeight);
            beginOperation(Operations.BLOCK, operationData);
            operationData.frameOffset = parentScope.frameOffset + parentScope.numLocals;
        }

        /**
         * Ends a built-in Block operation.
         * <p>
         * Signature: Block(body...) -> void/Object
         *
         * @see #beginBlock
         */
        public void endBlock() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_BLOCK);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.BLOCK);
            if (!(operation.data instanceof BlockData operationData)) {
                throw assertionFailed("Data class BlockData expected, but was " + operation.data);
            }
            if (operationData.numLocals > 0) {
                maxLocals = Math.max(maxLocals, operationData.frameOffset + operationData.numLocals);
                for (int index = 0; index < operationData.numLocals; index++) {
                    locals[operationData.locals[index] + LOCALS_OFFSET_END_BCI] = bci;
                    doEmitInstructionS(Instructions.CLEAR_LOCAL, 0, safeCastShort(locals[operationData.locals[index] + LOCALS_OFFSET_FRAME_INDEX]));
                }
            }
            operationData.valid = false;
            afterChild(operationData.producedValue, operationData.childBci);
        }

        /**
         * Begins a new root node.
         * <p>
         * Signature: Root(body...)
         * <p>
         * Each Root operation defines one function (i.e., a {@link SLBytecodeRootNode}).
         * It takes one or more children, which define the body of the function that executes when it is invoked.
         * If control falls through to the end of the body without returning, instructions are inserted to implicitly return {@code null}.
         * <p>
         * A root operation is typically the outermost one. That is, a {@link BytecodeParser} should invoke {@link #beginRoot} first before using other builder methods to generate bytecode.
         * The parser should invoke {@link #endRoot} to finish generating the {@link SLBytecodeRootNode}.
         * <p>
         * A parser *can* nest this operation in Source and SourceSection operations in order to provide a {@link Node#getSourceSection source location} for the entire root node.
         * The result of {@link Node#getSourceSection} on the generated root is undefined if there is no enclosing SourceSection operation.
         * <p>
         * This method can also be called inside of another root operation. Bytecode generation for the outer root node suspends until generation for the inner root node finishes.
         * The inner root node is not lexically nested in the first (you can invoke the inner root node independently), but the inner root *can* manipulate the outer root's locals using
         * materialized local accesses if the outer frame is provided to it.
         * Multiple root nodes can be obtained from the {@link BytecodeNodes} object in the order of their {@link #beginRoot} calls.
         *
         */
        public void beginRoot() {
            if (serialization != null) {
                try {
                    SerializationRootNode node = new SerializationRootNode(FrameDescriptor.newBuilder(), serialization.depth, checkOverflowShort(serialization.rootCount++, "Root node count"));
                    serialization.rootStack.push(node);
                    serialization.builtNodes.add(node);
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_ROOT);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            if (bc != null) {
                savedState = new SavedState(operationSequenceNumber, operationStack, operationSp, rootOperationSp, numLocals, numLabels, numNodes, numHandlers, numConditionalBranches, bc, bci, currentStackHeight, maxStackHeight, sourceInfo, sourceInfoIndex, handlerTable, handlerTableSize, locals, localsTableIndex, unresolvedLabels, constantPool, reachable, maxLocals, tagRoots, tagNodes, savedState);
            }
            operationSequenceNumber = 0;
            rootOperationSp = operationSp;
            reachable = true;
            tagRoots = null;
            tagNodes = null;
            numLocals = 0;
            maxLocals = numLocals;
            numLabels = 0;
            numNodes = 0;
            numHandlers = 0;
            numConditionalBranches = 0;
            constantPool = new ConstantPool();
            bc = new byte[32];
            bci = 0;
            currentStackHeight = 0;
            maxStackHeight = 0;
            handlerTable = new int[2 * EXCEPTION_HANDLER_LENGTH];
            handlerTableSize = 0;
            locals = null;
            localsTableIndex = 0;
            unresolvedLabels = new HashMap<>();
            if (parseSources) {
                sourceInfo = new int[3 * SOURCE_INFO_LENGTH];
                sourceInfoIndex = 0;
            }
            RootData operationData = new RootData(safeCastShort(numRoots++));
            if (reparseReason == null) {
                builtNodes.add(null);
                if (builtNodes.size() > Short.MAX_VALUE) {
                    throw BytecodeEncodingException.create("Root node count exceeded maximum value.");
                }
            }
            operationData.frameOffset = numLocals;
            beginOperation(Operations.ROOT, operationData);
            beginTag(TAGS_ROOT_TAG);
            beginBlock();
        }

        /**
         * Finishes generating bytecode for the current root node.
         * <p>
         * Signature: Root(body...)
         *
         * @returns the root node with generated bytecode.
         */
        public SLBytecodeRootNode endRoot() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_ROOT);
                    SerializationRootNode result = serialization.rootStack.pop();
                    serialization.buffer.writeInt(result.contextDepth);
                    serialization.buffer.writeInt(result.rootIndex);
                    return result;
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
            }
            if (!(operationStack[operationSp - 1].data instanceof BlockData blockOperation)) {
                throw assertionFailed("Data class BlockData expected, but was " + operationStack[operationSp - 1].data);
            }
            if (!blockOperation.producedValue) {
                emitLoadNull();
            }
            endBlock();
            if (!(operationStack[rootOperationSp].data instanceof RootData operationData)) {
                throw assertionFailed("Data class RootData expected, but was " + operationStack[rootOperationSp].data);
            }
            endTag(TAGS_ROOT_TAG);
            doEmitInstruction(Instructions.RETURN, -1);
            endOperation(Operations.ROOT);
            if (operationData.numLocals > 0) {
                maxLocals = Math.max(maxLocals, operationData.frameOffset + operationData.numLocals);
                for (int index = 0; index < operationData.numLocals; index++) {
                    locals[operationData.locals[index] + LOCALS_OFFSET_END_BCI] = bci;
                }
            }
            operationData.valid = false;
            byte[] bytecodes_ = null;
            Object[] constants_ = null;
            int[] handlers_ = null;
            int[] locals_ = null;
            int[] sourceInfo_ = null;
            List<Source> sources_ = null;
            int numNodes_ = 0;
            TagRootNode tagRoot_ = null;
            doEmitRoot();
            if (parseSources) {
                sourceInfo_ = Arrays.copyOf(sourceInfo, sourceInfoIndex);
                sources_ = sources;
            }
            if (parseBytecodes) {
                bytecodes_ = Arrays.copyOf(bc, bci);
                constants_ = constantPool.toArray();
                handlers_ = Arrays.copyOf(handlerTable, handlerTableSize);
                sources_ = sources;
                numNodes_ = numNodes;
                locals_ = locals == null ? EMPTY_INT_ARRAY : Arrays.copyOf(locals, localsTableIndex);
            }
            if (tags != 0 && this.tagNodes != null) {
                TagNode[] tagNodes_ = this.tagNodes.toArray(TagNode[]::new);
                TagNode tagTree_;
                assert !this.tagRoots.isEmpty();
                if (this.tagRoots.size() == 1) {
                    tagTree_ = this.tagRoots.get(0);
                } else {
                    tagTree_ = new TagNode(0, -1);
                    tagTree_.children = tagTree_.insert(this.tagRoots.toArray(TagNode[]::new));
                }
                tagRoot_ = new TagRootNode(tagTree_, tagNodes_);
            }
            SLBytecodeRootNodeGen result;
            if (reparseReason != null) {
                result = builtNodes.get(operationData.index);
                if (parseBytecodes) {
                    AbstractBytecodeNode oldBytecodeNode = result.bytecode;
                    assert result.maxLocals == maxLocals + USER_LOCALS_START_INDEX;
                    assert result.nodes == this.nodes;
                    assert constants_.length == oldBytecodeNode.constants.length;
                    assert result.getFrameDescriptor().getNumberOfSlots() == maxStackHeight + maxLocals + USER_LOCALS_START_INDEX;
                }
                result.updateBytecode(bytecodes_, constants_, handlers_, locals_, sourceInfo_, sources_, numNodes_, tagRoot_, this.reparseReason);
                assert result.buildIndex == operationData.index;
            } else {
                com.oracle.truffle.api.frame.FrameDescriptor.Builder frameDescriptorBuilder = FrameDescriptor.newBuilder();
                frameDescriptorBuilder.addSlots(maxStackHeight + maxLocals + USER_LOCALS_START_INDEX, FrameSlotKind.Illegal);
                result = new SLBytecodeRootNodeGen(language, frameDescriptorBuilder, nodes, maxLocals + USER_LOCALS_START_INDEX, numLocals, operationData.index, bytecodes_, constants_, handlers_, locals_, sourceInfo_, sources_, numNodes_, tagRoot_);
                assert operationData.index <= numRoots;
                builtNodes.set(operationData.index, result);
            }
            rootOperationSp = -1;
            if (savedState == null) {
                // invariant: bc is null when no root node is being built
                bc = null;
            } else {
                this.operationSequenceNumber = savedState.operationSequenceNumber;
                this.operationStack = savedState.operationStack;
                this.operationSp = savedState.operationSp;
                this.rootOperationSp = savedState.rootOperationSp;
                this.numLocals = savedState.numLocals;
                this.numLabels = savedState.numLabels;
                this.numNodes = savedState.numNodes;
                this.numHandlers = savedState.numHandlers;
                this.numConditionalBranches = savedState.numConditionalBranches;
                this.bc = savedState.bc;
                this.bci = savedState.bci;
                this.currentStackHeight = savedState.currentStackHeight;
                this.maxStackHeight = savedState.maxStackHeight;
                this.sourceInfo = savedState.sourceInfo;
                this.sourceInfoIndex = savedState.sourceInfoIndex;
                this.handlerTable = savedState.handlerTable;
                this.handlerTableSize = savedState.handlerTableSize;
                this.locals = savedState.locals;
                this.localsTableIndex = savedState.localsTableIndex;
                this.unresolvedLabels = savedState.unresolvedLabels;
                this.constantPool = savedState.constantPool;
                this.reachable = savedState.reachable;
                this.maxLocals = savedState.maxLocals;
                this.tagRoots = savedState.tagRoots;
                this.tagNodes = savedState.tagNodes;
                this.savedState = savedState.savedState;
            }
            return result;
        }

        /**
         * Begins a built-in IfThen operation.
         * <p>
         * Signature: IfThen(condition, thens) -> void
         * <p>
         * IfThen implements an if-then statement. It evaluates {@code condition}, which must produce a boolean. If the value is {@code true}, it executes {@code thens}.
         * This is a void operation; {@code thens} can also be void.
         * <p>
         * A corresponding call to {@link #endIfThen} is required to end the operation.
         */
        public void beginIfThen() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_IF_THEN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            IfThenData operationData = new IfThenData(this.reachable);
            beginOperation(Operations.IFTHEN, operationData);
        }

        /**
         * Ends a built-in IfThen operation.
         * <p>
         * Signature: IfThen(condition, thens) -> void
         *
         * @see #beginIfThen
         */
        public void endIfThen() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_IF_THEN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.IFTHEN);
            if (operation.childCount != 2) {
                throw failState("Operation IfThen expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            updateReachable();
            afterChild(false, -1);
        }

        /**
         * Begins a built-in IfThenElse operation.
         * <p>
         * Signature: IfThenElse(condition, thens, elses) -> void
         * <p>
         * IfThenElse implements an if-then-else statement. It evaluates {@code condition}, which must produce a boolean. If the value is {@code true}, it executes {@code thens}; otherwise, it executes {@code elses}.
         * This is a void operation; both {@code thens} and {@code elses} can also be void.
         * <p>
         * A corresponding call to {@link #endIfThenElse} is required to end the operation.
         */
        public void beginIfThenElse() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_IF_THEN_ELSE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            IfThenElseData operationData = new IfThenElseData(this.reachable, this.reachable);
            beginOperation(Operations.IFTHENELSE, operationData);
        }

        /**
         * Ends a built-in IfThenElse operation.
         * <p>
         * Signature: IfThenElse(condition, thens, elses) -> void
         *
         * @see #beginIfThenElse
         */
        public void endIfThenElse() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_IF_THEN_ELSE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.IFTHENELSE);
            if (operation.childCount != 3) {
                throw failState("Operation IfThenElse expected exactly 3 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof IfThenElseData operationData)) {
                throw assertionFailed("Data class IfThenElseData expected, but was " + operation.data);
            }
            markReachable(operationData.thenReachable || operationData.elseReachable);
            afterChild(false, -1);
        }

        /**
         * Begins a built-in Conditional operation.
         * <p>
         * Signature: Conditional(condition, thens, elses) -> Object
         * <p>
         * Conditional implements a conditional expression (e.g., {@code condition ? thens : elses} in Java). It has the same semantics as IfThenElse, except it produces the value of the conditionally-executed child.
         * <p>
         * A corresponding call to {@link #endConditional} is required to end the operation.
         */
        public void beginConditional() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_CONDITIONAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            ConditionalData operationData = new ConditionalData(this.reachable, this.reachable);
            beginOperation(Operations.CONDITIONAL, operationData);
        }

        /**
         * Ends a built-in Conditional operation.
         * <p>
         * Signature: Conditional(condition, thens, elses) -> Object
         *
         * @see #beginConditional
         */
        public void endConditional() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_CONDITIONAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.CONDITIONAL);
            if (operation.childCount != 3) {
                throw failState("Operation Conditional expected exactly 3 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof ConditionalData operationData)) {
                throw assertionFailed("Data class ConditionalData expected, but was " + operation.data);
            }
            markReachable(operationData.thenReachable || operationData.elseReachable);
            doEmitInstructionII(Instructions.MERGE_CONDITIONAL, -1, operationData.thenReachable ? operationData.child0Bci : -1, operationData.elseReachable ? operationData.child1Bci : -1);
            afterChild(true, bci - 10);
        }

        /**
         * Begins a built-in While operation.
         * <p>
         * Signature: While(condition, body) -> void
         * <p>
         * While implements a while loop. It evaluates {@code condition}, which must produce a boolean. If the value is {@code true}, it executes {@code body} and repeats.
         * This is a void operation; {@code body} can also be void.
         * <p>
         * A corresponding call to {@link #endWhile} is required to end the operation.
         */
        public void beginWhile() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_WHILE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            WhileData operationData = new WhileData(bci, this.reachable);
            beginOperation(Operations.WHILE, operationData);
        }

        /**
         * Ends a built-in While operation.
         * <p>
         * Signature: While(condition, body) -> void
         *
         * @see #beginWhile
         */
        public void endWhile() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_WHILE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.WHILE);
            if (operation.childCount != 2) {
                throw failState("Operation While expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            updateReachable();
            afterChild(false, -1);
        }

        /**
         * Begins a built-in TryCatch operation.
         * <p>
         * Signature: TryCatch(try, catch) -> void
         * <p>
         * TryCatch implements an exception handler. It executes {@code try}, and if a Truffle exception is thrown, it executes {@code catch}.
         * The exception can be accessed within the {@code catch} operation using LoadException.
         * Unlike a Java try-catch, this operation does not filter the exception based on type.
         * This is a void operation; both {@code try} and {@code catch} can also be void.
         * <p>
         * A corresponding call to {@link #endTryCatch} is required to end the operation.
         */
        public void beginTryCatch() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_TRY_CATCH);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            TryCatchData operationData = new TryCatchData(++numHandlers, safeCastShort(currentStackHeight), bci, this.reachable, this.reachable, this.reachable);
            beginOperation(Operations.TRYCATCH, operationData);
        }

        /**
         * Ends a built-in TryCatch operation.
         * <p>
         * Signature: TryCatch(try, catch) -> void
         *
         * @see #beginTryCatch
         */
        public void endTryCatch() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_TRY_CATCH);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.TRYCATCH);
            if (operation.childCount != 2) {
                throw failState("Operation TryCatch expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof TryCatchData operationData)) {
                throw assertionFailed("Data class TryCatchData expected, but was " + operation.data);
            }
            markReachable(operationData.tryReachable || operationData.catchReachable);
            afterChild(false, -1);
        }

        /**
         * Begins a built-in FinallyTry operation.
         * <p>
         * Signature: FinallyTry(try) -> void
         * <p>
         * FinallyTry implements a finally handler. It runs the given {@code finallyParser} to parse a {@code finally} operation.
         * FinallyTry executes {@code try}, and after execution finishes it always executes {@code finally}.
         * If {@code try} finishes normally, {@code finally} executes and control continues after the FinallyTry operation.
         * If {@code try} finishes exceptionally, {@code finally} executes and then rethrows the exception.
         * If {@code try} finishes with a control flow operation, {@code finally} executes and then the control flow operation continues (i.e., a Branch will branch, a Return will return).
         * This is a void operation; both {@code finally} and {@code try} can also be void.
         * <p>
         * A corresponding call to {@link #endFinallyTry} is required to end the operation.
         *
         * @param finallyParser a runnable that uses the builder to parse the finally operation (must be idempotent).
         */
        public void beginFinallyTry(Runnable finallyParser) {
            if (serialization != null) {
                try {
                    short finallyParserIndex = serializeFinallyParser(finallyParser);
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_FINALLY_TRY);
                    serialization.buffer.writeShort(serialization.depth);
                    serialization.buffer.writeShort(finallyParserIndex);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            FinallyTryData operationData = new FinallyTryData(++numHandlers, safeCastShort(currentStackHeight), finallyParser, bci, this.reachable, this.reachable, false);
            beginOperation(Operations.FINALLYTRY, operationData);
        }

        /**
         * Ends a built-in FinallyTry operation.
         * <p>
         * Signature: FinallyTry(try) -> void
         *
         * @see #beginFinallyTry
         */
        public void endFinallyTry() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_FINALLY_TRY);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.FINALLYTRY);
            if (operation.childCount != 1) {
                throw failState("Operation FinallyTry expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof FinallyTryData operationData)) {
                throw assertionFailed("Data class FinallyTryData expected, but was " + operation.data);
            }
            int handlerSp = currentStackHeight + 1 /* reserve space for the exception */;
            updateMaxStackHeight(handlerSp);
            int exHandlerIndex = UNINITIALIZED;
            if (operationData.operationReachable) {
                // register exception table entry
                exHandlerIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, handlerSp);
            }
            // emit handler for normal completion case
            doEmitFinallyHandler(operationData, operationSp);
            // the operation was popped, so manually update reachability. try is reachable if neither it nor the finally handler exited early.
            operationData.tryReachable = operationData.tryReachable && this.reachable;
            if (this.reachable) {
                operationData.endBranchFixupBci = bci + 2;
                doEmitInstructionI(Instructions.BRANCH, 0, UNINITIALIZED);
            }
            if (operationData.operationReachable) {
                // update exception table; force handler code to be reachable
                this.reachable = true;
                patchHandlerTable(operationData.extraTableEntriesStart, operationData.extraTableEntriesEnd, operationData.handlerId, bci, handlerSp);
                if (exHandlerIndex != UNINITIALIZED) {
                    handlerTable[exHandlerIndex + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI] = bci;
                }
            }
            // emit handler for exceptional case
            currentStackHeight = handlerSp;
            doEmitFinallyHandler(operationData, operationSp);
            doEmitInstruction(Instructions.THROW, -1);
            if (operationData.endBranchFixupBci != UNINITIALIZED) {
                BYTES.putInt(bc, operationData.endBranchFixupBci, bci);
            }
            markReachable(operationData.tryReachable);
            afterChild(false, -1);
        }

        /**
         * Begins a built-in FinallyTryCatch operation.
         * <p>
         * Signature: FinallyTryCatch(try, catch) -> void
         * <p>
         * FinallyTryCatch implements a finally handler with different behaviour for thrown exceptions. It runs the given {@code finallyParser} to parse a {@code finally} operation.
         * FinallyTryCatch executes {@code try} and then one of the handlers.
         * If {@code try} finishes normally, {@code finally} executes and control continues after the FinallyTryCatch operation.
         * If {@code try} finishes exceptionally, {@code catch} executes. The exception can be accessed using LoadException, and it is rethrown afterwards.
         * If {@code try} finishes with a control flow operation, {@code finally} executes and then the control flow operation continues (i.e., a Branch will branch, a Return will return).
         * This is a void operation; any of {@code finally}, {@code try}, or {@code catch} can be void.
         * <p>
         * A corresponding call to {@link #endFinallyTryCatch} is required to end the operation.
         *
         * @param finallyParser a runnable that uses the builder to parse the finally operation (must be idempotent).
         */
        public void beginFinallyTryCatch(Runnable finallyParser) {
            if (serialization != null) {
                try {
                    short finallyParserIndex = serializeFinallyParser(finallyParser);
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_FINALLY_TRY_CATCH);
                    serialization.buffer.writeShort(serialization.depth);
                    serialization.buffer.writeShort(finallyParserIndex);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            FinallyTryData operationData = new FinallyTryData(++numHandlers, safeCastShort(currentStackHeight), finallyParser, bci, this.reachable, this.reachable, this.reachable);
            beginOperation(Operations.FINALLYTRYCATCH, operationData);
        }

        /**
         * Ends a built-in FinallyTryCatch operation.
         * <p>
         * Signature: FinallyTryCatch(try, catch) -> void
         *
         * @see #beginFinallyTryCatch
         */
        public void endFinallyTryCatch() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_FINALLY_TRY_CATCH);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.FINALLYTRYCATCH);
            if (operation.childCount != 2) {
                throw failState("Operation FinallyTryCatch expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof FinallyTryData operationData)) {
                throw assertionFailed("Data class FinallyTryData expected, but was " + operation.data);
            }
            markReachable(operationData.tryReachable || operationData.catchReachable);
            afterChild(false, -1);
        }

        /**
         * Begins a built-in FinallyHandler operation.
         * <p>
         * Signature: FinallyHandler(body...) -> void
         * <p>
         * FinallyHandler is an internal operation that has no stack effect. All finally parsers execute within a FinallyHandler operation.
         * Executing the parser emits new operations, but these operations should not affect the outer operation's child count/value validation.
         * To accomplish this, FinallyHandler "hides" these operations by popping any produced values and omitting calls to beforeChild/afterChild.
         * When walking the operation stack, we skip over operations above finallyOperationSp since they do not logically enclose the handler.
         * <p>
         * A corresponding call to {@link #endFinallyHandler} is required to end the operation.
         *
         * @param finallyOperationSp the operation stack pointer for the finally operation that created the FinallyHandler.
         */
        private void beginFinallyHandler(short finallyOperationSp) {
            validateRootOperationBegin();
            FinallyHandlerData operationData = new FinallyHandlerData(finallyOperationSp);
            beginOperation(Operations.FINALLYHANDLER, operationData);
        }

        /**
         * Ends a built-in FinallyHandler operation.
         * <p>
         * Signature: FinallyHandler(body...) -> void
         *
         * @see #beginFinallyHandler
         */
        private void endFinallyHandler() {
            endOperation(Operations.FINALLYHANDLER);
        }

        /**
         * Emits a built-in Label operation.
         * <p>
         * Signature: Label() -> void
         * <p>
         * Label assigns {@code label} the current location in the bytecode (so that it can be used as the target of a Branch).
         * This is a void operation.
         * <p>
         * Each {@link BytecodeLabel} must be defined exactly once. It should be defined directly inside the same operation in which it is created (using {@link #createLabel}).
         *
         * @param label the label to define.
         */
        public void emitLabel(BytecodeLabel label) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_LABEL);
                    serialization.buffer.writeShort(safeCastShort(((SerializationLabel) label).contextDepth));
                    serialization.buffer.writeShort(safeCastShort(((SerializationLabel) label).labelIndex));
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            BytecodeLabelImpl labelImpl = (BytecodeLabelImpl) label;
            if (labelImpl.isDefined()) {
                throw failState("BytecodeLabel already emitted. Each label must be emitted exactly once.");
            }
            if (labelImpl.declaringOp != operationStack[operationSp - 1].sequenceNumber) {
                throw failState("BytecodeLabel must be emitted inside the same operation it was created in.");
            }
            if (operationStack[operationSp - 1].data instanceof BlockData blockData) {
                assert this.currentStackHeight == blockData.startStackHeight;
            } else {
                assert operationStack[operationSp - 1].data instanceof RootData;
                assert this.currentStackHeight == 0;
            }
            resolveUnresolvedLabel(labelImpl, currentStackHeight);
            markReachable(true);
            afterChild(false, -1);
        }

        /**
         * Emits a built-in Branch operation.
         * <p>
         * Signature: Branch() -> void
         * <p>
         * Branch performs a branch to {@code label}.
         * This operation only supports unconditional forward branches; use IfThen and While to perform other kinds of branches.
         *
         * @param label the label to branch to.
         */
        public void emitBranch(BytecodeLabel label) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_BRANCH);
                    serialization.buffer.writeShort(safeCastShort(((SerializationLabel) label).contextDepth));
                    serialization.buffer.writeShort(safeCastShort(((SerializationLabel) label).labelIndex));
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            BytecodeLabelImpl labelImpl = (BytecodeLabelImpl) label;
            int declaringOperationSp = UNINITIALIZED;
            for (int i = operationSp - 1; i >= rootOperationSp; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                if (operationStack[i].sequenceNumber == labelImpl.declaringOp) {
                    declaringOperationSp = i;
                    break;
                }
            }
            if (declaringOperationSp == UNINITIALIZED) {
                throw failState("Branch must be targeting a label that is declared in an enclosing operation of the current root. Jumps into other operations are not permitted.");
            }
            if (labelImpl.isDefined()) {
                throw failState("Backward branches are unsupported. Use a While operation to model backward control flow.");
            }
            int targetStackHeight;
            if (operationStack[declaringOperationSp].data instanceof BlockData blockData) {
                targetStackHeight = blockData.startStackHeight;
            } else {
                assert operationStack[declaringOperationSp].data instanceof RootData;
                targetStackHeight = 0;
            }
            beforeEmitBranch(declaringOperationSp);
            // Pop any extra values off the stack before branching.
            int stackHeightBeforeBranch = currentStackHeight;
            while (targetStackHeight != currentStackHeight) {
                doEmitInstructionI(Instructions.POP, -1, -1);
            }
            // If the branch is not taken (e.g., control branches over it) the values are still on the stack.
            currentStackHeight = stackHeightBeforeBranch;
            if (this.reachable) {
                registerUnresolvedLabel(labelImpl, bci + 2);
            }
            doEmitInstructionI(Instructions.BRANCH, 0, UNINITIALIZED);
            markReachable(false);
            afterChild(false, bci - 6);
        }

        /**
         * Emits a built-in LoadConstant operation.
         * <p>
         * Signature: LoadConstant() -> Object
         * <p>
         * LoadConstant produces {@code constant}. The constant should be immutable, since it may be shared across multiple LoadConstant operations.
         *
         * @param constant the constant value to load.
         */
        public void emitLoadConstant(Object constant) {
            if (serialization != null) {
                try {
                    int constant_index = serialization.serializeObject(constant);
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_LOAD_CONSTANT);
                    serialization.buffer.writeInt(constant_index);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            if (constant == null) {
                throw failArgument("The constant parameter must not be null. Use emitLoadNull() instead for null values.");
            }
            beforeChild();
            doEmitInstructionI(Instructions.LOAD_CONSTANT, 1, constantPool.addConstant(constant));
            afterChild(true, bci - 6);
        }

        /**
         * Emits a built-in LoadNull operation.
         * <p>
         * Signature: LoadNull() -> Object
         * <p>
         * LoadNull produces a {@code null} value.
         */
        public void emitLoadNull() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_LOAD_NULL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            doEmitInstruction(Instructions.LOAD_NULL, 1);
            afterChild(true, bci - 2);
        }

        /**
         * Emits a built-in LoadArgument operation.
         * <p>
         * Signature: LoadArgument() -> Object
         * <p>
         * LoadArgument reads the argument at {@code index} from the frame.
         *
         * @param index the index of the argument to load (must fit into a short).
         */
        public void emitLoadArgument(int index) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_LOAD_ARGUMENT);
                    serialization.buffer.writeInt(index);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            doEmitInstructionS(Instructions.LOAD_ARGUMENT, 1, safeCastShort(index));
            afterChild(true, bci - 4);
        }

        /**
         * Emits a built-in LoadException operation.
         * <p>
         * Signature: LoadException() -> Object
         * <p>
         * LoadException reads the current exception from the frame.
         * This operation is only permitted inside the {@code catch} operation of TryCatch and FinallyTryCatch operations.
         */
        public void emitLoadException() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_LOAD_EXCEPTION);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            short exceptionStackHeight = UNINITIALIZED;
            loop: for (int i = operationSp - 1; i >= rootOperationSp; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                switch (operationStack[i].operation) {
                    case Operations.TRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                            throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 1) {
                            exceptionStackHeight = operationData.stackHeight;
                            break loop;
                        }
                        break;
                    }
                    case Operations.FINALLYTRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 1) {
                            exceptionStackHeight = operationData.stackHeight;
                            break loop;
                        }
                        break;
                    }
                }
            }
            if (exceptionStackHeight == UNINITIALIZED) {
                throw failState("LoadException can only be used in the catch operation of a TryCatch/FinallyTryCatch operation in the current root.");
            }
            doEmitInstructionS(Instructions.LOAD_EXCEPTION, 1, exceptionStackHeight);
            afterChild(true, bci - 4);
        }

        private void validateLocalScope(BytecodeLocal local) {
            if (!((BytecodeLocalImpl) local).scope.valid) {
                throw failArgument("Local variable scope of this local no longer valid.");
            }
        }

        /**
         * Emits a built-in LoadLocal operation.
         * <p>
         * Signature: LoadLocal() -> Object
         * <p>
         * LoadLocal reads {@code local} from the current frame.
         * If a value has not been written to the local, LoadLocal produces the default value as defined in the {@link FrameDescriptor} ({@code null} by default).
         *
         * @param local the local to load.
         */
        public void emitLoadLocal(BytecodeLocal local) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_LOAD_LOCAL);
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).contextDepth));
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).localIndex));
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            validateLocalScope(local);
            doEmitInstructionSS(Instructions.LOAD_LOCAL, 1, ((BytecodeLocalImpl) local).frameIndex, ((BytecodeLocalImpl) local).localIndex);
            afterChild(true, bci - 6);
        }

        /**
         * Begins a built-in LoadLocalMaterialized operation.
         * <p>
         * Signature: LoadLocalMaterialized(frame) -> Object
         * <p>
         * LoadLocalMaterialized reads {@code local} from the frame produced by {@code frame}.
         * This operation can be used to read locals from materialized frames. The materialized frame must belong to the same root node or an enclosing root node.
         * <p>
         * A corresponding call to {@link #endLoadLocalMaterialized} is required to end the operation.
         *
         * @param local the local to load.
         */
        public void beginLoadLocalMaterialized(BytecodeLocal local) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_LOAD_LOCAL_MATERIALIZED);
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).contextDepth));
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).localIndex));
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            validateLocalScope(local);
            beforeChild();
            BytecodeLocalImpl operationData = (BytecodeLocalImpl)local;
            beginOperation(Operations.LOADLOCALMATERIALIZED, operationData);
        }

        /**
         * Ends a built-in LoadLocalMaterialized operation.
         * <p>
         * Signature: LoadLocalMaterialized(frame) -> Object
         *
         * @see #beginLoadLocalMaterialized
         */
        public void endLoadLocalMaterialized() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_LOAD_LOCAL_MATERIALIZED);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.LOADLOCALMATERIALIZED);
            if (operation.childCount != 1) {
                throw failState("Operation LoadLocalMaterialized expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof BytecodeLocalImpl operationData)) {
                throw assertionFailed("Data class BytecodeLocalImpl expected, but was " + operation.data);
            }
            doEmitInstructionSSS(Instructions.LOAD_LOCAL_MAT, 0, operationData.frameIndex, operationData.localIndex, operationData.rootIndex);
            afterChild(true, bci - 8);
        }

        /**
         * Begins a built-in StoreLocal operation.
         * <p>
         * Signature: StoreLocal(value) -> void
         * <p>
         * StoreLocal writes the value produced by {@code value} into the {@code local} in the current frame.
         * <p>
         * A corresponding call to {@link #endStoreLocal} is required to end the operation.
         *
         * @param local the local to store to.
         */
        public void beginStoreLocal(BytecodeLocal local) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_STORE_LOCAL);
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).contextDepth));
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).localIndex));
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            validateLocalScope(local);
            beforeChild();
            StoreLocalData operationData = new StoreLocalData((BytecodeLocalImpl)local);
            beginOperation(Operations.STORELOCAL, operationData);
        }

        /**
         * Ends a built-in StoreLocal operation.
         * <p>
         * Signature: StoreLocal(value) -> void
         *
         * @see #beginStoreLocal
         */
        public void endStoreLocal() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_STORE_LOCAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.STORELOCAL);
            if (operation.childCount != 1) {
                throw failState("Operation StoreLocal expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof StoreLocalData operationData)) {
                throw assertionFailed("Data class StoreLocalData expected, but was " + operation.data);
            }
            doEmitInstructionSSI(Instructions.STORE_LOCAL, -1, operationData.local.frameIndex, operationData.local.localIndex, operationData.childBci);
            afterChild(false, bci - 10);
        }

        /**
         * Begins a built-in StoreLocalMaterialized operation.
         * <p>
         * Signature: StoreLocalMaterialized(frame, value) -> void
         * <p>
         * StoreLocalMaterialized writes the value produced by {@code value} into the {@code local} in the frame produced by {@code frame}.
         * This operation can be used to store locals into materialized frames. The materialized frame must belong to the same root node or an enclosing root node.
         * <p>
         * A corresponding call to {@link #endStoreLocalMaterialized} is required to end the operation.
         *
         * @param local the local to store to.
         */
        public void beginStoreLocalMaterialized(BytecodeLocal local) {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_STORE_LOCAL_MATERIALIZED);
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).contextDepth));
                    serialization.buffer.writeShort(safeCastShort(((SerializationLocal) local).localIndex));
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            validateLocalScope(local);
            beforeChild();
            StoreLocalData operationData = new StoreLocalData((BytecodeLocalImpl)local);
            beginOperation(Operations.STORELOCALMATERIALIZED, operationData);
        }

        /**
         * Ends a built-in StoreLocalMaterialized operation.
         * <p>
         * Signature: StoreLocalMaterialized(frame, value) -> void
         *
         * @see #beginStoreLocalMaterialized
         */
        public void endStoreLocalMaterialized() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_STORE_LOCAL_MATERIALIZED);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.STORELOCALMATERIALIZED);
            if (operation.childCount != 2) {
                throw failState("Operation StoreLocalMaterialized expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof StoreLocalData operationData)) {
                throw assertionFailed("Data class StoreLocalData expected, but was " + operation.data);
            }
            doEmitInstructionSSSI(Instructions.STORE_LOCAL_MAT, -2, operationData.local.frameIndex, operationData.local.localIndex, operationData.local.rootIndex, operationData.childBci);
            afterChild(false, bci - 12);
        }

        /**
         * Begins a built-in Return operation.
         * <p>
         * Signature: Return(result) -> void
         * <p>
         * Return returns the value produced by {@code result}.
         * <p>
         * A corresponding call to {@link #endReturn} is required to end the operation.
         */
        public void beginReturn() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_RETURN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            ReturnOperationData operationData = new ReturnOperationData();
            beginOperation(Operations.RETURN, operationData);
        }

        /**
         * Ends a built-in Return operation.
         * <p>
         * Signature: Return(result) -> void
         *
         * @see #beginReturn
         */
        public void endReturn() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_RETURN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.RETURN);
            if (operation.childCount != 1) {
                throw failState("Operation Return expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof ReturnOperationData operationData)) {
                throw assertionFailed("Data class ReturnOperationData expected, but was " + operation.data);
            }
            beforeEmitReturn(operationData.childBci);
            doEmitInstruction(Instructions.RETURN, -1);
            markReachable(false);
            afterChild(false, bci - 2);
        }

        /**
         * Begins a built-in Source operation.
         * <p>
         * Signature: Source(body...) -> void/Object
         * <p>
         * Source associates the children in its {@code body} with {@code source}. Together with SourceSection, it encodes source locations for operations in the program.
         * <p>
         * A corresponding call to {@link #endSource} is required to end the operation.
         *
         * @param source the source object to associate with the enclosed operations.
         */
        public void beginSource(Source source) {
            if (!parseSources) {
                return;
            }
            if (serialization != null) {
                try {
                    int source_index = serialization.serializeObject(source);
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SOURCE);
                    serialization.buffer.writeInt(source_index);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            beforeChild();
            if (source.hasBytes()) {
                throw failArgument("Byte-based sources are not supported.");
            }
            int index = sources.indexOf(source);
            if (index == -1) {
                index = sources.size();
                sources.add(source);
            }
            SourceData operationData = new SourceData(index);
            beginOperation(Operations.SOURCE, operationData);
        }

        /**
         * Ends a built-in Source operation.
         * <p>
         * Signature: Source(body...) -> void/Object
         *
         * @see #beginSource
         */
        public void endSource() {
            if (!parseSources) {
                return;
            }
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SOURCE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SOURCE);
            if (!(operation.data instanceof SourceData operationData)) {
                throw assertionFailed("Data class SourceData expected, but was " + operation.data);
            }
            afterChild(operationData.producedValue, operationData.childBci);
        }

        /**
         * Begins a built-in SourceSection operation.
         * <p>
         * Signature: SourceSection(body...) -> void/Object
         * <p>
         * SourceSection associates the children in its {@code body} with the source section with the given character {@code index} and {@code length}.
         * To specify an {@link Source#createUnavailableSection() unavailable source section}, provide {@code -1} for both arguments.
         * This operation must be (directly or indirectly) enclosed within a Source operation.
         * <p>
         * A corresponding call to {@link #endSourceSection} is required to end the operation.
         *
         * @param index the starting character index of the source section, or -1 if the section is unavailable.
         * @param length the length (in characters) of the source section, or -1 if the section is unavailable.
         */
        public void beginSourceSection(int index, int length) {
            if (!parseSources) {
                return;
            }
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SOURCE_SECTION);
                    serialization.buffer.writeInt(index);
                    serialization.buffer.writeInt(length);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            beforeChild();
            int foundSourceIndex = -1;
            loop: for (int i = operationSp - 1; i >= 0; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                switch (operationStack[i].operation) {
                    case Operations.SOURCE :
                        if (!(operationStack[i].data instanceof SourceData sourceData)) {
                            throw assertionFailed("Data class SourceData expected, but was " + operationStack[i].data);
                        }
                        foundSourceIndex = sourceData.sourceIndex;
                        break loop;
                }
            }
            if (foundSourceIndex == -1) {
                throw failState("No enclosing Source operation found - each SourceSection must be enclosed in a Source operation.");
            }
            assert (index == -1 && length == -1) || (index >= 0 && length >= 0);
            int startBci;
            if (rootOperationSp == -1) {
                // not in a root yet
                startBci = 0;
            } else {
                startBci = bci;
            }
            SourceSectionData operationData = new SourceSectionData(foundSourceIndex, startBci, index, length);
            beginOperation(Operations.SOURCESECTION, operationData);
        }

        /**
         * Ends a built-in SourceSection operation.
         * <p>
         * Signature: SourceSection(body...) -> void/Object
         *
         * @see #beginSourceSection
         */
        public void endSourceSection() {
            if (!parseSources) {
                return;
            }
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SOURCE_SECTION);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SOURCESECTION);
            if (!(operation.data instanceof SourceSectionData operationData)) {
                throw assertionFailed("Data class SourceSectionData expected, but was " + operation.data);
            }
            doEmitSourceInfo(operationData.sourceIndex, operationData.startBci, bci, operationData.start, operationData.length);
            afterChild(operationData.producedValue, operationData.childBci);
        }

        /**
         * Begins a built-in Tag operation.
         * <p>
         * Signature: Tag(tagged) -> void/Object
         * <p>
         * Tag associates {@code tagged} with the given tags.
         * When the {@link BytecodeConfig} includes one or more of the given tags, the interpreter will automatically invoke instrumentation probes when entering/leaving {@code tagged}.
         * <p>
         * A corresponding call to {@link #endTag} is required to end the operation.
         *
         * @param newTags the tags to associate with the enclosed operations.
         */
        public void beginTag(Class<?>... newTags) {
            if (newTags.length == 0) {
                throw failArgument("The tags parameter for beginTag must not be empty. Please specify at least one tag.");
            }
            int encodedTags = encodeTags(newTags);
            if ((encodedTags & this.tags) == 0) {
                return;
            }
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_TAG);
                    serialization.buffer.writeInt(encodedTags);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            TagNode node = new TagNode(encodedTags & this.tags, bci);
            if (tagNodes == null) {
                tagNodes = new ArrayList<>();
            }
            int nodeId = tagNodes.size();
            tagNodes.add(node);
            beforeChild();
            TagOperationData operationData = new TagOperationData(nodeId, this.reachable, this.currentStackHeight, node);
            beginOperation(Operations.TAG, operationData);
            doEmitInstructionI(Instructions.TAG_ENTER, 0, nodeId);
        }

        /**
         * Ends a built-in Tag operation.
         * <p>
         * Signature: Tag(tagged) -> void/Object
         * <p>
         * The tags passed to this method should match the ones used in the corresponding {@link #beginTag} call.
         *
         * @param newTags the tags to associate with the enclosed operations.
         * @see #beginTag
         */
        public void endTag(Class<?>... newTags) {
            if (newTags.length == 0) {
                throw failArgument("The tags parameter for beginTag must not be empty. Please specify at least one tag.");
            }
            int encodedTags = encodeTags(newTags);
            if ((encodedTags & this.tags) == 0) {
                return;
            }
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_TAG);
                    serialization.buffer.writeInt(encodedTags);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.TAG);
            if (operation.childCount != 1) {
                throw failState("Operation Tag expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof TagOperationData operationData)) {
                throw assertionFailed("Data class TagOperationData expected, but was " + operation.data);
            }
            TagNode tagNode = operationData.node;
            if ((encodedTags & this.tags) != tagNode.tags) {
                throw new IllegalArgumentException("The tags provided to endTag do not match the tags provided to the corresponding beginTag call.");
            }
            // If this tag operation is nested in another, add it to the outer tag tree. Otherwise, it becomes a tag root.
            boolean outerTagFound = false;
            for (int i = operationSp - 1; i >= rootOperationSp; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                if (operationStack[i].data instanceof TagOperationData t) {
                    if (t.children == null) {
                        t.children = new ArrayList<>(3);
                    }
                    t.children.add(tagNode);
                    outerTagFound = true;
                    break;
                }
            }
            if (!outerTagFound) {
                if (tagRoots == null) {
                    tagRoots = new ArrayList<>(3);
                }
                tagRoots.add(tagNode);
            }
            TagNode[] children;
            List<TagNode> operationChildren = operationData.children;
            if (operationChildren == null) {
                children = TagNode.EMPTY_ARRAY;
            } else {
                children = new TagNode[operationChildren.size()];
                for (int i = 0; i < children.length; i++) {
                    children[i] = tagNode.insert(operationChildren.get(i));
                }
            }
            tagNode.children = children;
            tagNode.returnBci = bci;
            if (operationData.producedValue) {
                if (operationData.operationReachable) {
                    markReachable(true);
                    doEmitInstructionII(Instructions.TAG_LEAVE, 0, operationData.nodeId, operationData.childBci);
                    doCreateExceptionHandler(operationData.handlerStartBci, bci, HANDLER_TAG_EXCEPTIONAL, operationData.nodeId, operationData.startStackHeight);
                } else {
                    doEmitInstructionII(Instructions.TAG_LEAVE, 0, operationData.nodeId, operationData.childBci);
                }
                afterChild(true, bci - 10);
            } else {
                if (operationData.operationReachable) {
                    markReachable(true);
                    doEmitInstructionI(Instructions.TAG_LEAVE_VOID, 0, operationData.nodeId);
                    doCreateExceptionHandler(operationData.handlerStartBci, bci, HANDLER_TAG_EXCEPTIONAL, operationData.nodeId, operationData.startStackHeight);
                } else {
                    doEmitInstructionI(Instructions.TAG_LEAVE_VOID, 0, operationData.nodeId);
                }
                afterChild(false, -1);
            }
        }

        /**
         * Emits a custom {@link #com.oracle.truffle.sl.bytecode.SLBytecodeRootNode.SLAlwaysHalt SLAlwaysHalt} operation.
         * <p>
         * Signature: SLAlwaysHalt() -> void
         */
        public void emitSLAlwaysHalt() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_SL_ALWAYS_HALT);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beginTag(TAGS_ALWAYS_HALT);
            beforeChild();
            doEmitInstructionI(Instructions.SL_ALWAYS_HALT_, 0, allocateNode());
            afterChild(false, bci - 6);
            endTag(TAGS_ALWAYS_HALT);
        }

        /**
         * Emits a custom {@link #com.oracle.truffle.sl.bytecode.SLBytecodeRootNode.SLLoadArgument SLLoadArgument} operation.
         * <p>
         * Signature: SLLoadArgument() -> Object
         *
         * @param indexValue
         */
        public void emitSLLoadArgument(int indexValue) {
            if (serialization != null) {
                try {
                    int indexValue_index = serialization.serializeObject(indexValue);
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_SL_LOAD_ARGUMENT);
                    serialization.buffer.writeInt(indexValue_index);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            int indexIndex = constantPool.addConstant(indexValue);
            beforeChild();
            doEmitInstructionII(Instructions.SL_LOAD_ARGUMENT_, 1, indexIndex, allocateNode());
            afterChild(true, bci - 10);
        }

        /**
         * Emits a custom {@link #com.oracle.truffle.sl.bytecode.SLBytecodeRootNode.Builtin Builtin} operation.
         * <p>
         * Signature: Builtin() -> Object
         *
         * @param builtinValue
         * @param argumentCountValue
         */
        public void emitBuiltin(SLBuiltinNode builtinValue, int argumentCountValue) {
            if (serialization != null) {
                try {
                    int builtinValue_index = serialization.serializeObject(builtinValue);
                    int argumentCountValue_index = serialization.serializeObject(argumentCountValue);
                    serialization.buffer.writeShort(SerializationState.CODE_EMIT_BUILTIN);
                    serialization.buffer.writeInt(builtinValue_index);
                    serialization.buffer.writeInt(argumentCountValue_index);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            if (builtinValue == null) {
                throw failArgument("The builtinValue parameter must not be null. Use emitLoadNull() instead for null values.");
            }
            int builtinIndex = constantPool.addConstant(builtinValue);
            int argumentCountIndex = constantPool.addConstant(argumentCountValue);
            beforeChild();
            doEmitInstructionIII(Instructions.BUILTIN_, 1, builtinIndex, argumentCountIndex, allocateNode());
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.bytecode.SLBytecodeRootNode.SLInvoke SLInvoke} operation.
         * <p>
         * Signature: SLInvoke(function, arguments...) -> Object
         * <p>
         * A corresponding call to {@link #endSLInvoke} is required to end the operation.
         */
        public void beginSLInvoke() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_INVOKE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(EMPTY_INT_ARRAY, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLINVOKE, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.bytecode.SLBytecodeRootNode.SLInvoke SLInvoke} operation.
         * <p>
         * Signature: SLInvoke(function, arguments...) -> Object
         *
         * @see #beginSLInvoke
         */
        public void endSLInvoke() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_INVOKE);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLINVOKE);
            if (operation.childCount < 1) {
                throw failState("Operation SLInvoke expected at least 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            doEmitVariadic(operation.childCount - 1);
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            doEmitInstructionI(Instructions.SL_INVOKE_, -1, allocateNode());
            afterChild(true, bci - 6);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLAddNode SLAdd} operation.
         * <p>
         * Signature: SLAdd(left, right) -> Object
         * <p>
         * A corresponding call to {@link #endSLAdd} is required to end the operation.
         */
        public void beginSLAdd() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_ADD);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLADD, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLAddNode SLAdd} operation.
         * <p>
         * Signature: SLAdd(left, right) -> Object
         *
         * @see #beginSLAdd
         */
        public void endSLAdd() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_ADD);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLADD);
            if (operation.childCount != 2) {
                throw failState("Operation SLAdd expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_ADD_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLDivNode SLDiv} operation.
         * <p>
         * Signature: SLDiv(left, right) -> Object
         * <p>
         * A corresponding call to {@link #endSLDiv} is required to end the operation.
         */
        public void beginSLDiv() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_DIV);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLDIV, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLDivNode SLDiv} operation.
         * <p>
         * Signature: SLDiv(left, right) -> Object
         *
         * @see #beginSLDiv
         */
        public void endSLDiv() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_DIV);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLDIV);
            if (operation.childCount != 2) {
                throw failState("Operation SLDiv expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_DIV_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLEqualNode SLEqual} operation.
         * <p>
         * Signature: SLEqual(left, right) -> boolean
         * <p>
         * A corresponding call to {@link #endSLEqual} is required to end the operation.
         */
        public void beginSLEqual() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_EQUAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLEQUAL, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLEqualNode SLEqual} operation.
         * <p>
         * Signature: SLEqual(left, right) -> boolean
         *
         * @see #beginSLEqual
         */
        public void endSLEqual() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_EQUAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLEQUAL);
            if (operation.childCount != 2) {
                throw failState("Operation SLEqual expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_EQUAL_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLLessOrEqualNode SLLessOrEqual} operation.
         * <p>
         * Signature: SLLessOrEqual(left, right) -> Object
         * <p>
         * A corresponding call to {@link #endSLLessOrEqual} is required to end the operation.
         */
        public void beginSLLessOrEqual() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_LESS_OR_EQUAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLLESSOREQUAL, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLLessOrEqualNode SLLessOrEqual} operation.
         * <p>
         * Signature: SLLessOrEqual(left, right) -> Object
         *
         * @see #beginSLLessOrEqual
         */
        public void endSLLessOrEqual() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_LESS_OR_EQUAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLLESSOREQUAL);
            if (operation.childCount != 2) {
                throw failState("Operation SLLessOrEqual expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_LESS_OR_EQUAL_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLLessThanNode SLLessThan} operation.
         * <p>
         * Signature: SLLessThan(left, right) -> boolean
         * <p>
         * A corresponding call to {@link #endSLLessThan} is required to end the operation.
         */
        public void beginSLLessThan() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_LESS_THAN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLLESSTHAN, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLLessThanNode SLLessThan} operation.
         * <p>
         * Signature: SLLessThan(left, right) -> boolean
         *
         * @see #beginSLLessThan
         */
        public void endSLLessThan() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_LESS_THAN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLLESSTHAN);
            if (operation.childCount != 2) {
                throw failState("Operation SLLessThan expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_LESS_THAN_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLLogicalNotNode SLLogicalNot} operation.
         * <p>
         * Signature: SLLogicalNot(value) -> boolean
         * <p>
         * A corresponding call to {@link #endSLLogicalNot} is required to end the operation.
         */
        public void beginSLLogicalNot() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_LOGICAL_NOT);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLLOGICALNOT, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLLogicalNotNode SLLogicalNot} operation.
         * <p>
         * Signature: SLLogicalNot(value) -> boolean
         *
         * @see #beginSLLogicalNot
         */
        public void endSLLogicalNot() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_LOGICAL_NOT);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLLOGICALNOT);
            if (operation.childCount != 1) {
                throw failState("Operation SLLogicalNot expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            doEmitInstructionII(Instructions.SL_LOGICAL_NOT_, 0, allocateNode(), childBci0);
            afterChild(true, bci - 10);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLMulNode SLMul} operation.
         * <p>
         * Signature: SLMul(left, right) -> Object
         * <p>
         * A corresponding call to {@link #endSLMul} is required to end the operation.
         */
        public void beginSLMul() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_MUL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLMUL, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLMulNode SLMul} operation.
         * <p>
         * Signature: SLMul(left, right) -> Object
         *
         * @see #beginSLMul
         */
        public void endSLMul() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_MUL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLMUL);
            if (operation.childCount != 2) {
                throw failState("Operation SLMul expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_MUL_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLReadPropertyNode SLReadProperty} operation.
         * <p>
         * Signature: SLReadProperty(receiver, index|name) -> Object
         * <p>
         * A corresponding call to {@link #endSLReadProperty} is required to end the operation.
         */
        public void beginSLReadProperty() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_READ_PROPERTY);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(EMPTY_INT_ARRAY, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLREADPROPERTY, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLReadPropertyNode SLReadProperty} operation.
         * <p>
         * Signature: SLReadProperty(receiver, index|name) -> Object
         *
         * @see #beginSLReadProperty
         */
        public void endSLReadProperty() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_READ_PROPERTY);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLREADPROPERTY);
            if (operation.childCount != 2) {
                throw failState("Operation SLReadProperty expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            doEmitInstructionI(Instructions.SL_READ_PROPERTY_, -1, allocateNode());
            afterChild(true, bci - 6);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLSubNode SLSub} operation.
         * <p>
         * Signature: SLSub(left, right) -> Object
         * <p>
         * A corresponding call to {@link #endSLSub} is required to end the operation.
         */
        public void beginSLSub() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_SUB);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED, UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLSUB, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLSubNode SLSub} operation.
         * <p>
         * Signature: SLSub(left, right) -> Object
         *
         * @see #beginSLSub
         */
        public void endSLSub() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_SUB);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLSUB);
            if (operation.childCount != 2) {
                throw failState("Operation SLSub expected exactly 2 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            int childBci1 = operationData.childBcis[1];
            doEmitInstructionIII(Instructions.SL_SUB_, -1, allocateNode(), childBci0, childBci1);
            afterChild(true, bci - 14);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLWritePropertyNode SLWriteProperty} operation.
         * <p>
         * Signature: SLWriteProperty(receiver, index|name, value) -> Object
         * <p>
         * A corresponding call to {@link #endSLWriteProperty} is required to end the operation.
         */
        public void beginSLWriteProperty() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_WRITE_PROPERTY);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(EMPTY_INT_ARRAY, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLWRITEPROPERTY, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLWritePropertyNode SLWriteProperty} operation.
         * <p>
         * Signature: SLWriteProperty(receiver, index|name, value) -> Object
         *
         * @see #beginSLWriteProperty
         */
        public void endSLWriteProperty() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_WRITE_PROPERTY);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLWRITEPROPERTY);
            if (operation.childCount != 3) {
                throw failState("Operation SLWriteProperty expected exactly 3 children, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            doEmitInstructionI(Instructions.SL_WRITE_PROPERTY_, -2, allocateNode());
            afterChild(true, bci - 6);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.util.SLUnboxNode SLUnbox} operation.
         * <p>
         * Signature: SLUnbox(value) -> Object
         * <p>
         * A corresponding call to {@link #endSLUnbox} is required to end the operation.
         */
        public void beginSLUnbox() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_UNBOX);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLUNBOX, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.util.SLUnboxNode SLUnbox} operation.
         * <p>
         * Signature: SLUnbox(value) -> Object
         *
         * @see #beginSLUnbox
         */
        public void endSLUnbox() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_UNBOX);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLUNBOX);
            if (operation.childCount != 1) {
                throw failState("Operation SLUnbox expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            doEmitInstructionII(Instructions.SL_UNBOX_, 0, allocateNode(), childBci0);
            afterChild(true, bci - 10);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.expression.SLFunctionLiteralNode SLFunctionLiteral} operation.
         * <p>
         * Signature: SLFunctionLiteral(functionName) -> SLFunction
         * <p>
         * A corresponding call to {@link #endSLFunctionLiteral} is required to end the operation.
         */
        public void beginSLFunctionLiteral() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_FUNCTION_LITERAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(EMPTY_INT_ARRAY, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLFUNCTIONLITERAL, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.expression.SLFunctionLiteralNode SLFunctionLiteral} operation.
         * <p>
         * Signature: SLFunctionLiteral(functionName) -> SLFunction
         *
         * @see #beginSLFunctionLiteral
         */
        public void endSLFunctionLiteral() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_FUNCTION_LITERAL);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLFUNCTIONLITERAL);
            if (operation.childCount != 1) {
                throw failState("Operation SLFunctionLiteral expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            doEmitInstructionI(Instructions.SL_FUNCTION_LITERAL_, 0, allocateNode());
            afterChild(true, bci - 6);
        }

        /**
         * Begins a custom {@link #com.oracle.truffle.sl.nodes.util.SLToBooleanNode SLToBoolean} operation.
         * <p>
         * Signature: SLToBoolean(value) -> boolean
         * <p>
         * A corresponding call to {@link #endSLToBoolean} is required to end the operation.
         */
        public void beginSLToBoolean() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_TO_BOOLEAN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomOperationData operationData = new CustomOperationData(new int[] {UNINITIALIZED}, EMPTY_INT_ARRAY);
            beginOperation(Operations.SLTOBOOLEAN, operationData);
        }

        /**
         * Ends a custom {@link #com.oracle.truffle.sl.nodes.util.SLToBooleanNode SLToBoolean} operation.
         * <p>
         * Signature: SLToBoolean(value) -> boolean
         *
         * @see #beginSLToBoolean
         */
        public void endSLToBoolean() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_TO_BOOLEAN);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLTOBOOLEAN);
            if (operation.childCount != 1) {
                throw failState("Operation SLToBoolean expected exactly 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomOperationData operationData)) {
                throw assertionFailed("Data class CustomOperationData expected, but was " + operation.data);
            }
            int childBci0 = operationData.childBcis[0];
            doEmitInstructionII(Instructions.SL_TO_BOOLEAN_, 0, allocateNode(), childBci0);
            afterChild(true, bci - 10);
        }

        /**
         * Begins a custom SLAnd operation.
         * <p>
         * Signature: SLAnd(value) -> Object
         * <p>
         * A corresponding call to {@link #endSLAnd} is required to end the operation.
         */
        public void beginSLAnd() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_AND);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomShortCircuitOperationData operationData = new CustomShortCircuitOperationData();
            beginOperation(Operations.SLAND, operationData);
        }

        /**
         * Ends a custom SLAnd operation.
         * <p>
         * Signature: SLAnd(value) -> Object
         *
         * @see #beginSLAnd
         */
        public void endSLAnd() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_AND);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLAND);
            if (operation.childCount == 0) {
                throw failState("Operation SLAnd expected at least 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomShortCircuitOperationData operationData)) {
                throw assertionFailed("Data class CustomShortCircuitOperationData expected, but was " + operation.data);
            }
            int childBci = operationData.childBci;
            assert childBci != UNINITIALIZED;
            doEmitInstructionII(Instructions.SL_TO_BOOLEAN_, 0, allocateNode(), childBci);
            for (int site : operationData.branchFixupBcis) {
                BYTES.putInt(bc, site, bci);
            }
            afterChild(true, bci - 10);
        }

        /**
         * Begins a custom SLOr operation.
         * <p>
         * Signature: SLOr(value) -> Object
         * <p>
         * A corresponding call to {@link #endSLOr} is required to end the operation.
         */
        public void beginSLOr() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_BEGIN_SL_OR);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            validateRootOperationBegin();
            beforeChild();
            CustomShortCircuitOperationData operationData = new CustomShortCircuitOperationData();
            beginOperation(Operations.SLOR, operationData);
        }

        /**
         * Ends a custom SLOr operation.
         * <p>
         * Signature: SLOr(value) -> Object
         *
         * @see #beginSLOr
         */
        public void endSLOr() {
            if (serialization != null) {
                try {
                    serialization.buffer.writeShort(SerializationState.CODE_END_SL_OR);
                } catch (IOException ex) {
                    throw new IOError(ex);
                }
                return;
            }
            OperationStackEntry operation = endOperation(Operations.SLOR);
            if (operation.childCount == 0) {
                throw failState("Operation SLOr expected at least 1 child, but " + operation.childCount + " provided. This is probably a bug in the parser.");
            }
            if (!(operation.data instanceof CustomShortCircuitOperationData operationData)) {
                throw assertionFailed("Data class CustomShortCircuitOperationData expected, but was " + operation.data);
            }
            int childBci = operationData.childBci;
            assert childBci != UNINITIALIZED;
            doEmitInstructionII(Instructions.SL_TO_BOOLEAN_, 0, allocateNode(), childBci);
            for (int site : operationData.branchFixupBcis) {
                BYTES.putInt(bc, site, bci);
            }
            afterChild(true, bci - 10);
        }

        private void markReachable(boolean newReachable) {
            this.reachable = newReachable;
            try {
                for (int i = operationSp - 1; i >= rootOperationSp; i--) {
                    if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                        i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                        continue;
                    }
                    OperationStackEntry operation = operationStack[i];
                    switch (operation.operation) {
                        case Operations.ROOT :
                        {
                            if (!(operationStack[i].data instanceof RootData operationData)) {
                                throw assertionFailed("Data class RootData expected, but was " + operationStack[i].data);
                            }
                            operationData.reachable = newReachable;
                            return;
                        }
                        case Operations.IFTHEN :
                        {
                            if (!(operationStack[i].data instanceof IfThenData operationData)) {
                                throw assertionFailed("Data class IfThenData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                // Unreachable condition branch makes the if and parent block unreachable.
                                operationData.thenReachable = newReachable;
                                continue;
                            } else if (operation.childCount == 1) {
                                operationData.thenReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                        case Operations.IFTHENELSE :
                        {
                            if (!(operationStack[i].data instanceof IfThenElseData operationData)) {
                                throw assertionFailed("Data class IfThenElseData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                // Unreachable condition branch makes the if, then and parent block unreachable.
                                operationData.thenReachable = newReachable;
                                operationData.elseReachable = newReachable;
                                continue;
                            } else if (operation.childCount == 1) {
                                operationData.thenReachable = newReachable;
                            } else if (operation.childCount == 2) {
                                operationData.elseReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                        case Operations.CONDITIONAL :
                        {
                            if (!(operationStack[i].data instanceof ConditionalData operationData)) {
                                throw assertionFailed("Data class ConditionalData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                // Unreachable condition branch makes the if, then and parent block unreachable.
                                operationData.thenReachable = newReachable;
                                operationData.elseReachable = newReachable;
                                continue;
                            } else if (operation.childCount == 1) {
                                operationData.thenReachable = newReachable;
                            } else if (operation.childCount == 2) {
                                operationData.elseReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                        case Operations.WHILE :
                        {
                            if (!(operationStack[i].data instanceof WhileData operationData)) {
                                throw assertionFailed("Data class WhileData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                operationData.bodyReachable = newReachable;
                                continue;
                            } else if (operation.childCount == 1) {
                                operationData.bodyReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                        case Operations.TRYCATCH :
                        {
                            if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                                throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                operationData.tryReachable = newReachable;
                            } else if (operation.childCount == 1) {
                                operationData.catchReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                        case Operations.FINALLYTRY :
                        {
                            if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                                throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                operationData.tryReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                        case Operations.FINALLYTRYCATCH :
                        {
                            if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                                throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                            }
                            if (operation.childCount == 0) {
                                operationData.tryReachable = newReachable;
                            } else if (operation.childCount == 1) {
                                operationData.catchReachable = newReachable;
                            } else {
                                // Invalid child index, but we will fail in the end method.
                            }
                            return;
                        }
                    }
                }
            } finally {
                assert updateReachable() == this.reachable : "Inconsistent reachability detected.";
            }
        }

        /**
         * Updates the reachable field from the current operation. Typically invoked when the operation ended or the child is changing.
         */
        private boolean updateReachable() {
            boolean oldReachable = reachable;
            for (int i = operationSp - 1; i >= rootOperationSp; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                OperationStackEntry operation = operationStack[i];
                switch (operation.operation) {
                    case Operations.ROOT :
                    {
                        if (!(operationStack[i].data instanceof RootData operationData)) {
                            throw assertionFailed("Data class RootData expected, but was " + operationStack[i].data);
                        }
                        this.reachable = operationData.reachable;
                        return oldReachable;
                    }
                    case Operations.IFTHEN :
                    {
                        if (!(operationStack[i].data instanceof IfThenData operationData)) {
                            throw assertionFailed("Data class IfThenData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            continue;
                        } else if (operation.childCount == 1) {
                            this.reachable = operationData.thenReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                    case Operations.IFTHENELSE :
                    {
                        if (!(operationStack[i].data instanceof IfThenElseData operationData)) {
                            throw assertionFailed("Data class IfThenElseData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            // Unreachable condition branch makes the if, then and parent block unreachable.
                            continue;
                        } else if (operation.childCount == 1) {
                            this.reachable = operationData.thenReachable;
                        } else if (operation.childCount == 2) {
                            this.reachable = operationData.elseReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                    case Operations.CONDITIONAL :
                    {
                        if (!(operationStack[i].data instanceof ConditionalData operationData)) {
                            throw assertionFailed("Data class ConditionalData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            // Unreachable condition branch makes the if, then and parent block unreachable.
                            continue;
                        } else if (operation.childCount == 1) {
                            this.reachable = operationData.thenReachable;
                        } else if (operation.childCount == 2) {
                            this.reachable = operationData.elseReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                    case Operations.WHILE :
                    {
                        if (!(operationStack[i].data instanceof WhileData operationData)) {
                            throw assertionFailed("Data class WhileData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            continue;
                        } else if (operation.childCount == 1) {
                            this.reachable = operationData.bodyReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                    case Operations.TRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                            throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            this.reachable = operationData.tryReachable;
                        } else if (operation.childCount == 1) {
                            this.reachable = operationData.catchReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                    case Operations.FINALLYTRY :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            this.reachable = operationData.tryReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                    case Operations.FINALLYTRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operation.childCount == 0) {
                            this.reachable = operationData.tryReachable;
                        } else if (operation.childCount == 2) {
                            this.reachable = operationData.catchReachable;
                        } else {
                            // Invalid child index, but we will fail in the end method.
                        }
                        return oldReachable;
                    }
                }
            }
            return oldReachable;
        }

        private void beginOperation(int id, Object data) {
            if (operationSp == operationStack.length) {
                operationStack = Arrays.copyOf(operationStack, operationStack.length * 2);
            }
            operationStack[operationSp++] = new OperationStackEntry(id, data, operationSequenceNumber++);
        }

        private OperationStackEntry endOperation(int id) {
            if (operationSp == 0) {
                throw failState("Unexpected operation end - there are no operations on the stack. Did you forget a beginRoot()?");
            }
            OperationStackEntry entry = operationStack[operationSp - 1];
            if (entry.operation != id) {
                throw failState("Unexpected operation end, expected end" + OPERATION_NAMES[entry.operation] + ", but got end" +  OPERATION_NAMES[id]);
            }
            if (entry.declaredLabels != null) {
                for (BytecodeLabel label : entry.declaredLabels) {
                    BytecodeLabelImpl impl = (BytecodeLabelImpl) label;
                    if (!impl.isDefined()) {
                        throw failState("Operation " + OPERATION_NAMES[id] + " ended without emitting one or more declared labels.");
                    }
                }
            }
            operationStack[operationSp - 1] = null;
            operationSp -= 1;
            return entry;
        }

        private void validateRootOperationBegin() {
            if (rootOperationSp == -1) {
                throw failState("Unexpected operation emit - no root operation present. Did you forget a beginRoot()?");
            }
        }

        private void beforeChild() {
            if (operationSp == 0) {
                return;
            }
            int childIndex = operationStack[operationSp - 1].childCount;
            switch (operationStack[operationSp - 1].operation) {
                case Operations.BLOCK :
                {
                    if (!(operationStack[operationSp - 1].data instanceof BlockData operationData)) {
                        throw assertionFailed("Data class BlockData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (operationData.producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, operationData.childBci);
                    }
                    break;
                }
                case Operations.ROOT :
                {
                    if (!(operationStack[operationSp - 1].data instanceof RootData operationData)) {
                        throw assertionFailed("Data class RootData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (operationData.producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, operationData.childBci);
                    }
                    break;
                }
                case Operations.SOURCE :
                {
                    if (!(operationStack[operationSp - 1].data instanceof SourceData operationData)) {
                        throw assertionFailed("Data class SourceData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (operationData.producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, operationData.childBci);
                    }
                    break;
                }
                case Operations.SOURCESECTION :
                {
                    if (!(operationStack[operationSp - 1].data instanceof SourceSectionData operationData)) {
                        throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (operationData.producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, operationData.childBci);
                    }
                    break;
                }
                case Operations.SLAND :
                {
                    if (!(operationStack[operationSp - 1].data instanceof CustomShortCircuitOperationData operationData)) {
                        throw assertionFailed("Data class CustomShortCircuitOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex != 0) {
                        int converterBci = bci;
                        int childBci = operationData.childBci;
                        assert childBci != UNINITIALIZED;
                        doEmitInstructionII(Instructions.SL_TO_BOOLEAN_, 0, allocateNode(), childBci);
                        if (this.reachable) {
                            operationData.branchFixupBcis.add(bci + 2);
                        }
                        doEmitInstructionII(Instructions.SL_AND_, -1, UNINITIALIZED, allocateBranchProfile());
                    }
                    break;
                }
                case Operations.SLOR :
                {
                    if (!(operationStack[operationSp - 1].data instanceof CustomShortCircuitOperationData operationData)) {
                        throw assertionFailed("Data class CustomShortCircuitOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex != 0) {
                        int converterBci = bci;
                        int childBci = operationData.childBci;
                        assert childBci != UNINITIALIZED;
                        doEmitInstructionII(Instructions.SL_TO_BOOLEAN_, 0, allocateNode(), childBci);
                        if (this.reachable) {
                            operationData.branchFixupBcis.add(bci + 2);
                        }
                        doEmitInstructionII(Instructions.SL_OR_, -1, UNINITIALIZED, allocateBranchProfile());
                    }
                    break;
                }
                case Operations.IFTHEN :
                case Operations.IFTHENELSE :
                case Operations.CONDITIONAL :
                case Operations.FINALLYTRY :
                    if (childIndex >= 1) {
                        updateReachable();
                    }
                    break;
                case Operations.TRYCATCH :
                {
                    if (!(operationStack[operationSp - 1].data instanceof TryCatchData operationData)) {
                        throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 1) {
                        updateReachable();
                        // The exception dispatch logic pushes the exception onto the stack.
                        currentStackHeight = currentStackHeight + 1;
                        updateMaxStackHeight(currentStackHeight);
                    }
                    break;
                }
                case Operations.FINALLYTRYCATCH :
                {
                    if (!(operationStack[operationSp - 1].data instanceof FinallyTryData operationData)) {
                        throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 1) {
                        updateReachable();
                        // The exception dispatch logic pushes the exception onto the stack.
                        currentStackHeight = currentStackHeight + 1;
                        updateMaxStackHeight(currentStackHeight);
                    }
                    break;
                }
                case Operations.WHILE :
                case Operations.FINALLYHANDLER :
                case Operations.LOADLOCALMATERIALIZED :
                case Operations.STORELOCAL :
                case Operations.STORELOCALMATERIALIZED :
                case Operations.RETURN :
                case Operations.TAG :
                case Operations.SLINVOKE :
                case Operations.SLADD :
                case Operations.SLDIV :
                case Operations.SLEQUAL :
                case Operations.SLLESSOREQUAL :
                case Operations.SLLESSTHAN :
                case Operations.SLLOGICALNOT :
                case Operations.SLMUL :
                case Operations.SLREADPROPERTY :
                case Operations.SLSUB :
                case Operations.SLWRITEPROPERTY :
                case Operations.SLUNBOX :
                case Operations.SLFUNCTIONLITERAL :
                case Operations.SLTOBOOLEAN :
                    break;
                default :
                    throw assertionFailed("beforeChild should not be called on an operation with no children.");
            }
        }

        private void afterChild(boolean producedValue, int childBci) {
            if (operationSp == 0) {
                return;
            }
            int childIndex = operationStack[operationSp - 1].childCount;
            switch (operationStack[operationSp - 1].operation) {
                case Operations.BLOCK :
                {
                    if (!(operationStack[operationSp - 1].data instanceof BlockData operationData)) {
                        throw assertionFailed("Data class BlockData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.producedValue = producedValue;
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.ROOT :
                {
                    if (!(operationStack[operationSp - 1].data instanceof RootData operationData)) {
                        throw assertionFailed("Data class RootData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.producedValue = producedValue;
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.SOURCE :
                {
                    if (!(operationStack[operationSp - 1].data instanceof SourceData operationData)) {
                        throw assertionFailed("Data class SourceData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.producedValue = producedValue;
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.SOURCESECTION :
                {
                    if (!(operationStack[operationSp - 1].data instanceof SourceSectionData operationData)) {
                        throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.producedValue = producedValue;
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.TAG :
                {
                    if (!(operationStack[operationSp - 1].data instanceof TagOperationData operationData)) {
                        throw assertionFailed("Data class TagOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.producedValue = producedValue;
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.IFTHEN :
                {
                    if ((childIndex == 0) && !producedValue) {
                        throw failState("Operation IfThen expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    } else if ((childIndex == 1) && producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    if (!(operationStack[operationSp - 1].data instanceof IfThenData operationData)) {
                        throw assertionFailed("Data class IfThenData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        if (reachable) {
                            operationData.falseBranchFixupBci = bci + 2;
                        }
                        doEmitInstructionIII(Instructions.BRANCH_FALSE, -1, UNINITIALIZED, allocateBranchProfile(), childBci);
                    } else {
                        int toUpdate = operationData.falseBranchFixupBci;
                        if (toUpdate != UNINITIALIZED) {
                            BYTES.putInt(bc, toUpdate, bci);
                        }
                    }
                    break;
                }
                case Operations.IFTHENELSE :
                {
                    if ((childIndex == 0) && !producedValue) {
                        throw failState("Operation IfThenElse expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    } else if ((childIndex == 1 || childIndex == 2) && producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    if (!(operationStack[operationSp - 1].data instanceof IfThenElseData operationData)) {
                        throw assertionFailed("Data class IfThenElseData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        if (reachable) {
                            operationData.falseBranchFixupBci = bci + 2;
                        }
                        doEmitInstructionIII(Instructions.BRANCH_FALSE, -1, UNINITIALIZED, allocateBranchProfile(), childBci);
                    } else if (childIndex == 1) {
                        if (reachable) {
                            operationData.endBranchFixupBci = bci + 2;
                        }
                        doEmitInstructionI(Instructions.BRANCH, 0, UNINITIALIZED);
                        int toUpdate = operationData.falseBranchFixupBci;
                        if (toUpdate != UNINITIALIZED) {
                            BYTES.putInt(bc, toUpdate, bci);
                        }
                    } else {
                        int toUpdate = operationData.endBranchFixupBci;
                        if (toUpdate != UNINITIALIZED) {
                            BYTES.putInt(bc, toUpdate, bci);
                        }
                    }
                    break;
                }
                case Operations.CONDITIONAL :
                {
                    if (!producedValue) {
                        throw failState("Operation Conditional expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof ConditionalData operationData)) {
                        throw assertionFailed("Data class ConditionalData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        doEmitInstruction(Instructions.DUP, 1);
                        if (reachable) {
                            operationData.falseBranchFixupBci = bci + 2;
                        }
                        doEmitInstructionIII(Instructions.BRANCH_FALSE, -1, UNINITIALIZED, allocateBranchProfile(), childBci);
                    } else if (childIndex == 1) {
                        operationData.child0Bci = childBci;
                        if (reachable) {
                            operationData.endBranchFixupBci = bci + 2;
                            doEmitInstructionI(Instructions.BRANCH, 0, UNINITIALIZED);
                        }
                        currentStackHeight -= 1;
                        int toUpdate = operationData.falseBranchFixupBci;
                        if (toUpdate != UNINITIALIZED) {
                            BYTES.putInt(bc, toUpdate, bci);
                        }
                    } else {
                        operationData.child1Bci = childBci;
                        int toUpdate = operationData.endBranchFixupBci;
                        if (toUpdate != UNINITIALIZED) {
                            BYTES.putInt(bc, toUpdate, bci);
                        }
                    }
                    break;
                }
                case Operations.WHILE :
                {
                    if ((childIndex == 0) && !producedValue) {
                        throw failState("Operation While expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    } else if ((childIndex == 1) && producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    if (!(operationStack[operationSp - 1].data instanceof WhileData operationData)) {
                        throw assertionFailed("Data class WhileData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        if (reachable) {
                            operationData.endBranchFixupBci = bci + 2;
                        }
                        doEmitInstructionIII(Instructions.BRANCH_FALSE, -1, UNINITIALIZED, allocateBranchProfile(), childBci);
                    } else {
                        int toUpdate = operationData.endBranchFixupBci;
                        if (toUpdate != UNINITIALIZED) {
                            doEmitInstructionII(Instructions.BRANCH_BACKWARD, 0, operationData.whileStartBci, BYTES.getInt(bc, toUpdate + 4 /* loop branch profile */));
                            BYTES.putInt(bc, toUpdate, bci);
                        }
                    }
                    break;
                }
                case Operations.TRYCATCH :
                {
                    if (producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    if (!(operationStack[operationSp - 1].data instanceof TryCatchData operationData)) {
                        throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        if (operationData.operationReachable) {
                            int tryEndBci = bci;
                            if (operationData.tryReachable) {
                                operationData.endBranchFixupBci = bci + 2;
                                doEmitInstructionI(Instructions.BRANCH, 0, UNINITIALIZED);
                            }
                            int handlerSp = currentStackHeight + 1;
                            patchHandlerTable(operationData.extraTableEntriesStart, operationData.extraTableEntriesEnd, operationData.handlerId, bci, handlerSp);
                            doCreateExceptionHandler(operationData.tryStartBci, tryEndBci, HANDLER_CUSTOM, bci, handlerSp);
                        }
                    } else if (childIndex == 1) {
                        // pop the exception
                        doEmitInstructionI(Instructions.POP, -1, -1);
                        if (operationData.endBranchFixupBci != UNINITIALIZED) {
                            BYTES.putInt(bc, operationData.endBranchFixupBci, bci);
                        }
                    }
                    break;
                }
                case Operations.FINALLYTRY :
                {
                    if (producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    break;
                }
                case Operations.FINALLYTRYCATCH :
                {
                    if (producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    if (!(operationStack[operationSp - 1].data instanceof FinallyTryData operationData)) {
                        throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        int handlerSp = currentStackHeight + 1 /* reserve space for the exception */;
                        updateMaxStackHeight(handlerSp);
                        int exHandlerIndex = UNINITIALIZED;
                        if (operationData.operationReachable) {
                            // register exception table entry
                            exHandlerIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, handlerSp);
                        }
                        // emit handler for normal completion case
                        doEmitFinallyHandler(operationData, operationSp - 1);
                        // the operation was popped, so manually update reachability. try is reachable if neither it nor the finally handler exited early.
                        operationData.tryReachable = operationData.tryReachable && this.reachable;
                        if (this.reachable) {
                            operationData.endBranchFixupBci = bci + 2;
                            doEmitInstructionI(Instructions.BRANCH, 0, UNINITIALIZED);
                        }
                        if (operationData.operationReachable) {
                            // update exception table; force handler code to be reachable
                            this.reachable = true;
                            patchHandlerTable(operationData.extraTableEntriesStart, operationData.extraTableEntriesEnd, operationData.handlerId, bci, handlerSp);
                            if (exHandlerIndex != UNINITIALIZED) {
                                handlerTable[exHandlerIndex + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI] = bci;
                            }
                        }
                    } else {
                        // pop the exception
                        doEmitInstructionI(Instructions.POP, -1, -1);
                        if (operationData.endBranchFixupBci != UNINITIALIZED) {
                            BYTES.putInt(bc, operationData.endBranchFixupBci, bci);
                        }
                    }
                    break;
                }
                case Operations.FINALLYHANDLER :
                {
                    if (producedValue) {
                        doEmitInstructionI(Instructions.POP, -1, childBci);
                    }
                    break;
                }
                case Operations.LOADLOCALMATERIALIZED :
                {
                    if (!producedValue) {
                        throw failState("Operation LoadLocalMaterialized expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    break;
                }
                case Operations.STORELOCAL :
                {
                    if (!producedValue) {
                        throw failState("Operation StoreLocal expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof StoreLocalData operationData)) {
                        throw assertionFailed("Data class StoreLocalData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.STORELOCALMATERIALIZED :
                {
                    if (!producedValue) {
                        throw failState("Operation StoreLocalMaterialized expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof StoreLocalData operationData)) {
                        throw assertionFailed("Data class StoreLocalData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.RETURN :
                {
                    if (!producedValue) {
                        throw failState("Operation Return expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof ReturnOperationData operationData)) {
                        throw assertionFailed("Data class ReturnOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.producedValue = producedValue;
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.SLINVOKE :
                {
                    if (!producedValue) {
                        throw failState("Operation SLInvoke expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    break;
                }
                case Operations.SLADD :
                {
                    if (!producedValue) {
                        throw failState("Operation SLAdd expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLDIV :
                {
                    if (!producedValue) {
                        throw failState("Operation SLDiv expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLEQUAL :
                {
                    if (!producedValue) {
                        throw failState("Operation SLEqual expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLLESSOREQUAL :
                {
                    if (!producedValue) {
                        throw failState("Operation SLLessOrEqual expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLLESSTHAN :
                {
                    if (!producedValue) {
                        throw failState("Operation SLLessThan expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLLOGICALNOT :
                {
                    if (!producedValue) {
                        throw failState("Operation SLLogicalNot expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    }
                    break;
                }
                case Operations.SLMUL :
                {
                    if (!producedValue) {
                        throw failState("Operation SLMul expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLREADPROPERTY :
                {
                    if (!producedValue) {
                        throw failState("Operation SLReadProperty expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    break;
                }
                case Operations.SLSUB :
                {
                    if (!producedValue) {
                        throw failState("Operation SLSub expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    } else if (childIndex == 1) {
                        operationData.childBcis[1] = childBci;
                    }
                    break;
                }
                case Operations.SLWRITEPROPERTY :
                {
                    if (!producedValue) {
                        throw failState("Operation SLWriteProperty expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    break;
                }
                case Operations.SLUNBOX :
                {
                    if (!producedValue) {
                        throw failState("Operation SLUnbox expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    }
                    break;
                }
                case Operations.SLFUNCTIONLITERAL :
                {
                    if (!producedValue) {
                        throw failState("Operation SLFunctionLiteral expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    break;
                }
                case Operations.SLTOBOOLEAN :
                {
                    if (!producedValue) {
                        throw failState("Operation SLToBoolean expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomOperationData operationData)) {
                        throw assertionFailed("Data class CustomOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    if (childIndex == 0) {
                        operationData.childBcis[0] = childBci;
                    }
                    break;
                }
                case Operations.SLAND :
                {
                    if (!producedValue) {
                        throw failState("Operation SLAnd expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomShortCircuitOperationData operationData)) {
                        throw assertionFailed("Data class CustomShortCircuitOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.childBci = childBci;
                    break;
                }
                case Operations.SLOR :
                {
                    if (!producedValue) {
                        throw failState("Operation SLOr expected a value-producing child at position " + childIndex + ", but a void one was provided.");
                    }
                    if (!(operationStack[operationSp - 1].data instanceof CustomShortCircuitOperationData operationData)) {
                        throw assertionFailed("Data class CustomShortCircuitOperationData expected, but was " + operationStack[operationSp - 1].data);
                    }
                    operationData.childBci = childBci;
                    break;
                }
            }
            operationStack[operationSp - 1].childCount = childIndex + 1;
        }

        private void updateMaxStackHeight(int stackHeight) {
            maxStackHeight = Math.max(maxStackHeight, stackHeight);
            if (maxStackHeight > Short.MAX_VALUE) {
                throw BytecodeEncodingException.create("Maximum stack height exceeded.");
            }
        }

        private void ensureBytecodeCapacity(int size) {
            if (size > bc.length) {
                bc = Arrays.copyOf(bc, Math.max(size, bc.length * 2));
            }
        }

        private void doEmitVariadic(int count) {
            currentStackHeight -= count - 1;
            if (!reachable) {
                return;
            }
            if (count <= 8) {
                doEmitInstruction(safeCastShort(Instructions.LOAD_VARIADIC_0 + count), 0);
            } else {
                updateMaxStackHeight(currentStackHeight + count);
                int elementCount = count + 1;
                doEmitInstruction(Instructions.CONSTANT_NULL, 0);
                while (elementCount > 8) {
                    doEmitInstruction(Instructions.LOAD_VARIADIC_8, 0);
                    elementCount -= 7;
                }
                if (elementCount > 0) {
                    doEmitInstruction(safeCastShort(Instructions.LOAD_VARIADIC_0 + elementCount), 0);
                }
                doEmitInstruction(Instructions.MERGE_VARIADIC, 0);
            }
            if (count == 0) {
                // pushed empty array
                updateMaxStackHeight(currentStackHeight);
            }
        }

        private void doEmitFinallyHandler(FinallyTryData finallyTryData, int finallyOperationSp) {
            assert finallyTryData.finallyHandlerSp == UNINITIALIZED;
            try {
                finallyTryData.finallyHandlerSp = operationSp;
                beginFinallyHandler(safeCastShort(finallyOperationSp));
                finallyTryData.finallyParser.run();
                endFinallyHandler();
            } finally {
                finallyTryData.finallyHandlerSp = UNINITIALIZED;
            }
        }

        private int doCreateExceptionHandler(int startBci, int endBci, int handlerKind, int handlerBci, int handlerSp) {
            assert startBci <= endBci;
            // Don't create empty handler ranges.
            if (startBci == endBci) {
                return UNINITIALIZED;
            }
            // If the previous entry is for the same handler and the ranges are contiguous, combine them.
            if (handlerTableSize > 0) {
                int previousEntry = handlerTableSize - EXCEPTION_HANDLER_LENGTH;
                int previousEndBci = handlerTable[previousEntry + EXCEPTION_HANDLER_OFFSET_END_BCI];
                int previousKind = handlerTable[previousEntry + EXCEPTION_HANDLER_OFFSET_KIND];
                int previousHandlerBci = handlerTable[previousEntry + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
                if (previousEndBci == startBci && previousKind == handlerKind && previousHandlerBci == handlerBci) {
                    handlerTable[previousEntry + EXCEPTION_HANDLER_OFFSET_END_BCI] = endBci;
                    return UNINITIALIZED;
                }
            }
            if (handlerTable.length <= handlerTableSize + EXCEPTION_HANDLER_LENGTH) {
                handlerTable = Arrays.copyOf(handlerTable, handlerTable.length * 2);
            }
            int result = handlerTableSize;
            handlerTable[handlerTableSize + EXCEPTION_HANDLER_OFFSET_START_BCI] = startBci;
            handlerTable[handlerTableSize + EXCEPTION_HANDLER_OFFSET_END_BCI] = endBci;
            handlerTable[handlerTableSize + EXCEPTION_HANDLER_OFFSET_KIND] = handlerKind;
            handlerTable[handlerTableSize + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI] = handlerBci;
            handlerTable[handlerTableSize + EXCEPTION_HANDLER_OFFSET_HANDLER_SP] = handlerSp;
            handlerTableSize += EXCEPTION_HANDLER_LENGTH;
            return result;
        }

        private void doEmitSourceInfo(int sourceIndex, int startBci, int endBci, int start, int length) {
            assert parseSources;
            if (rootOperationSp == -1) {
                return;
            }
            int index = sourceInfoIndex;
            int prevIndex = index - SOURCE_INFO_LENGTH;
            if (prevIndex >= 0
                 && (sourceInfo[prevIndex + SOURCE_INFO_OFFSET_SOURCE]) == sourceIndex
                 && (sourceInfo[prevIndex + SOURCE_INFO_OFFSET_START]) == start
                 && (sourceInfo[prevIndex + SOURCE_INFO_OFFSET_LENGTH]) == length) {
                if ((sourceInfo[prevIndex + SOURCE_INFO_OFFSET_START_BCI]) == startBci
                     && (sourceInfo[prevIndex + SOURCE_INFO_OFFSET_END_BCI]) == endBci) {
                    // duplicate entry
                    return;
                } else if ((sourceInfo[prevIndex + SOURCE_INFO_OFFSET_END_BCI]) == startBci) {
                    // contiguous entry
                    sourceInfo[prevIndex + SOURCE_INFO_OFFSET_END_BCI] = endBci;
                    return;
                }
            }
            if (index >= sourceInfo.length) {
                sourceInfo = Arrays.copyOf(sourceInfo, sourceInfo.length * 2);
            }
            sourceInfo[index + SOURCE_INFO_OFFSET_START_BCI] = startBci;
            sourceInfo[index + SOURCE_INFO_OFFSET_END_BCI] = endBci;
            sourceInfo[index + SOURCE_INFO_OFFSET_SOURCE] = sourceIndex;
            sourceInfo[index + SOURCE_INFO_OFFSET_START] = start;
            sourceInfo[index + SOURCE_INFO_OFFSET_LENGTH] = length;
            sourceInfoIndex = index + SOURCE_INFO_LENGTH;
        }

        private void finish() {
            if (operationSp != 0) {
                throw failState("Unexpected parser end - there are still operations on the stack. Did you forget to end them?");
            }
            if (reparseReason == null) {
                nodes.setNodes(builtNodes.toArray(new SLBytecodeRootNodeGen[0]));
            }
            assert nodes.validate();
        }

        /**
         * Walks the operation stack, emitting instructions for any operations that need to complete before the branch (and fixing up bytecode ranges to exclude these instructions).
         */
        private void beforeEmitBranch(int declaringOperationSp) {
            /**
             * Emit "exit" instructions for any pending operations, and close any bytecode ranges that should not apply to the emitted instructions.
             */
            boolean needsRewind = false;
            for (int i = operationSp - 1; i >= declaringOperationSp + 1; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                switch (operationStack[i].operation) {
                    case Operations.TAG :
                    {
                        if (!(operationStack[i].data instanceof TagOperationData operationData)) {
                            throw assertionFailed("Data class TagOperationData expected, but was " + operationStack[i].data);
                        }
                        if (reachable) {
                            doEmitInstructionI(Instructions.TAG_LEAVE_VOID, 0, operationData.nodeId);
                            doCreateExceptionHandler(operationData.handlerStartBci, bci, HANDLER_TAG_EXCEPTIONAL, operationData.nodeId, operationData.startStackHeight);
                            needsRewind = true;
                        }
                        break;
                    }
                    case Operations.FINALLYTRY :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 0 /* still in try */) {
                            if (reachable) {
                                int handlerTableIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, UNINITIALIZED /* stack height */);
                                if (handlerTableIndex != UNINITIALIZED) {
                                    if (operationData.extraTableEntriesStart == UNINITIALIZED) {
                                        operationData.extraTableEntriesStart = handlerTableIndex;
                                    }
                                    operationData.extraTableEntriesEnd = handlerTableIndex + EXCEPTION_HANDLER_LENGTH;
                                }
                                needsRewind = true;
                            }
                            doEmitFinallyHandler(operationData, i);
                        }
                        break;
                    }
                    case Operations.FINALLYTRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 0 /* still in try */) {
                            if (reachable) {
                                int handlerTableIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, UNINITIALIZED /* stack height */);
                                if (handlerTableIndex != UNINITIALIZED) {
                                    if (operationData.extraTableEntriesStart == UNINITIALIZED) {
                                        operationData.extraTableEntriesStart = handlerTableIndex;
                                    }
                                    operationData.extraTableEntriesEnd = handlerTableIndex + EXCEPTION_HANDLER_LENGTH;
                                }
                                needsRewind = true;
                            }
                            doEmitFinallyHandler(operationData, i);
                        }
                        break;
                    }
                    case Operations.TRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                            throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 0 /* still in try */ && reachable) {
                            int handlerTableIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, UNINITIALIZED /* stack height */);
                            if (handlerTableIndex != UNINITIALIZED) {
                                if (operationData.extraTableEntriesStart == UNINITIALIZED) {
                                    operationData.extraTableEntriesStart = handlerTableIndex;
                                }
                                operationData.extraTableEntriesEnd = handlerTableIndex + EXCEPTION_HANDLER_LENGTH;
                            }
                            needsRewind = true;
                        }
                        break;
                    }
                    case Operations.SOURCESECTION :
                    {
                        if (!(operationStack[i].data instanceof SourceSectionData operationData)) {
                            throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[i].data);
                        }
                        doEmitSourceInfo(operationData.sourceIndex, operationData.startBci, bci, operationData.start, operationData.length);
                        needsRewind = true;
                        break;
                    }
                    case Operations.BLOCK :
                    {
                        if (!(operationStack[i].data instanceof BlockData operationData)) {
                            throw assertionFailed("Data class BlockData expected, but was " + operationStack[i].data);
                        }
                        for (int j = 0; j < operationData.numLocals; j++) {
                            locals[operationData.locals[j] + LOCALS_OFFSET_END_BCI] = bci;
                            doEmitInstructionS(Instructions.CLEAR_LOCAL, 0, safeCastShort(locals[operationData.locals[j] + LOCALS_OFFSET_FRAME_INDEX]));
                            needsRewind = true;
                        }
                        break;
                    }
                }
            }
            /**
             * Now that all "exit" instructions have been emitted, reopen bytecode ranges.
             */
            if (needsRewind) {
                for (int i = declaringOperationSp + 1; i < operationSp; i++) {
                    if (operationStack[i].operation == Operations.FINALLYTRY || operationStack[i].operation == Operations.FINALLYTRYCATCH) {
                        int finallyHandlerSp = ((FinallyTryData) operationStack[i].data).finallyHandlerSp;
                        if (finallyHandlerSp != UNINITIALIZED) {
                            i = finallyHandlerSp - 1;
                            continue;
                        }
                    }
                    switch (operationStack[i].operation) {
                        case Operations.TAG :
                        {
                            if (!(operationStack[i].data instanceof TagOperationData operationData)) {
                                throw assertionFailed("Data class TagOperationData expected, but was " + operationStack[i].data);
                            }
                            operationData.handlerStartBci = bci;
                            break;
                        }
                        case Operations.FINALLYTRY :
                        case Operations.FINALLYTRYCATCH :
                            if (operationStack[i].childCount == 0 /* still in try */) {
                                if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                                    throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                                }
                                operationData.tryStartBci = bci;
                            }
                            break;
                        case Operations.TRYCATCH :
                            if (operationStack[i].childCount == 0 /* still in try */) {
                                if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                                    throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                                }
                                operationData.tryStartBci = bci;
                            }
                            break;
                        case Operations.SOURCESECTION :
                        {
                            if (!(operationStack[i].data instanceof SourceSectionData operationData)) {
                                throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[i].data);
                            }
                            operationData.startBci = bci;
                            break;
                        }
                        case Operations.BLOCK :
                        {
                            if (!(operationStack[i].data instanceof BlockData operationData)) {
                                throw assertionFailed("Data class BlockData expected, but was " + operationStack[i].data);
                            }
                            for (int j = 0; j < operationData.numLocals; j++) {
                                int prevTableIndex = operationData.locals[j];
                                // Create a new table entry with a new bytecode range and the same metadata.
                                int localIndex = locals[prevTableIndex + LOCALS_OFFSET_LOCAL_INDEX];
                                int frameIndex = locals[prevTableIndex + LOCALS_OFFSET_FRAME_INDEX];
                                int nameIndex = locals[prevTableIndex + LOCALS_OFFSET_NAME];
                                int infoIndex = locals[prevTableIndex + LOCALS_OFFSET_INFO];
                                operationData.locals[j] = doEmitLocal(localIndex, frameIndex, nameIndex, infoIndex);
                            }
                        }
                    }
                }
            }
        }

        /**
         * Walks the operation stack, emitting instructions for any operations that need to complete before the return (and fixing up bytecode ranges to exclude these instructions).
         */
        private void beforeEmitReturn(int parentBci) {
            /**
             * Emit "exit" instructions for any pending operations, and close any bytecode ranges that should not apply to the emitted instructions.
             */
            int childBci = parentBci;
            boolean needsRewind = false;
            for (int i = operationSp - 1; i >= rootOperationSp + 1; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                switch (operationStack[i].operation) {
                    case Operations.TAG :
                    {
                        if (!(operationStack[i].data instanceof TagOperationData operationData)) {
                            throw assertionFailed("Data class TagOperationData expected, but was " + operationStack[i].data);
                        }
                        if (reachable) {
                            doEmitInstructionII(Instructions.TAG_LEAVE, 0, operationData.nodeId, childBci);
                            childBci = bci - 10;
                            doCreateExceptionHandler(operationData.handlerStartBci, bci, HANDLER_TAG_EXCEPTIONAL, operationData.nodeId, operationData.startStackHeight);
                            needsRewind = true;
                        }
                        break;
                    }
                    case Operations.FINALLYTRY :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 0 /* still in try */) {
                            if (reachable) {
                                int handlerTableIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, UNINITIALIZED /* stack height */);
                                if (handlerTableIndex != UNINITIALIZED) {
                                    if (operationData.extraTableEntriesStart == UNINITIALIZED) {
                                        operationData.extraTableEntriesStart = handlerTableIndex;
                                    }
                                    operationData.extraTableEntriesEnd = handlerTableIndex + EXCEPTION_HANDLER_LENGTH;
                                }
                                needsRewind = true;
                            }
                            doEmitFinallyHandler(operationData, i);
                        }
                        break;
                    }
                    case Operations.FINALLYTRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                            throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 0 /* still in try */) {
                            if (reachable) {
                                int handlerTableIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, UNINITIALIZED /* stack height */);
                                if (handlerTableIndex != UNINITIALIZED) {
                                    if (operationData.extraTableEntriesStart == UNINITIALIZED) {
                                        operationData.extraTableEntriesStart = handlerTableIndex;
                                    }
                                    operationData.extraTableEntriesEnd = handlerTableIndex + EXCEPTION_HANDLER_LENGTH;
                                }
                                needsRewind = true;
                            }
                            doEmitFinallyHandler(operationData, i);
                        }
                        break;
                    }
                    case Operations.TRYCATCH :
                    {
                        if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                            throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                        }
                        if (operationStack[i].childCount == 0 /* still in try */ && reachable) {
                            int handlerTableIndex = doCreateExceptionHandler(operationData.tryStartBci, bci, HANDLER_CUSTOM, -operationData.handlerId, UNINITIALIZED /* stack height */);
                            if (handlerTableIndex != UNINITIALIZED) {
                                if (operationData.extraTableEntriesStart == UNINITIALIZED) {
                                    operationData.extraTableEntriesStart = handlerTableIndex;
                                }
                                operationData.extraTableEntriesEnd = handlerTableIndex + EXCEPTION_HANDLER_LENGTH;
                            }
                            needsRewind = true;
                        }
                        break;
                    }
                    case Operations.SOURCESECTION :
                    {
                        if (!(operationStack[i].data instanceof SourceSectionData operationData)) {
                            throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[i].data);
                        }
                        doEmitSourceInfo(operationData.sourceIndex, operationData.startBci, bci, operationData.start, operationData.length);
                        needsRewind = true;
                        break;
                    }
                    case Operations.BLOCK :
                    {
                        if (!(operationStack[i].data instanceof BlockData operationData)) {
                            throw assertionFailed("Data class BlockData expected, but was " + operationStack[i].data);
                        }
                        for (int j = 0; j < operationData.numLocals; j++) {
                            locals[operationData.locals[j] + LOCALS_OFFSET_END_BCI] = bci;
                            needsRewind = true;
                        }
                        break;
                    }
                }
            }
            /**
             * Now that all "exit" instructions have been emitted, reopen bytecode ranges.
             */
            if (needsRewind) {
                for (int i = rootOperationSp + 1; i < operationSp; i++) {
                    if (operationStack[i].operation == Operations.FINALLYTRY || operationStack[i].operation == Operations.FINALLYTRYCATCH) {
                        int finallyHandlerSp = ((FinallyTryData) operationStack[i].data).finallyHandlerSp;
                        if (finallyHandlerSp != UNINITIALIZED) {
                            i = finallyHandlerSp - 1;
                            continue;
                        }
                    }
                    switch (operationStack[i].operation) {
                        case Operations.TAG :
                        {
                            if (!(operationStack[i].data instanceof TagOperationData operationData)) {
                                throw assertionFailed("Data class TagOperationData expected, but was " + operationStack[i].data);
                            }
                            operationData.handlerStartBci = bci;
                            break;
                        }
                        case Operations.FINALLYTRY :
                        case Operations.FINALLYTRYCATCH :
                            if (operationStack[i].childCount == 0 /* still in try */) {
                                if (!(operationStack[i].data instanceof FinallyTryData operationData)) {
                                    throw assertionFailed("Data class FinallyTryData expected, but was " + operationStack[i].data);
                                }
                                operationData.tryStartBci = bci;
                            }
                            break;
                        case Operations.TRYCATCH :
                            if (operationStack[i].childCount == 0 /* still in try */) {
                                if (!(operationStack[i].data instanceof TryCatchData operationData)) {
                                    throw assertionFailed("Data class TryCatchData expected, but was " + operationStack[i].data);
                                }
                                operationData.tryStartBci = bci;
                            }
                            break;
                        case Operations.SOURCESECTION :
                        {
                            if (!(operationStack[i].data instanceof SourceSectionData operationData)) {
                                throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[i].data);
                            }
                            operationData.startBci = bci;
                            break;
                        }
                        case Operations.BLOCK :
                        {
                            if (!(operationStack[i].data instanceof BlockData operationData)) {
                                throw assertionFailed("Data class BlockData expected, but was " + operationStack[i].data);
                            }
                            for (int j = 0; j < operationData.numLocals; j++) {
                                int prevTableIndex = operationData.locals[j];
                                int endBci = locals[prevTableIndex + LOCALS_OFFSET_END_BCI];
                                if (endBci == bci) {
                                    // No need to split. Reuse the existing entry.
                                    locals[prevTableIndex + LOCALS_OFFSET_END_BCI] = UNINITIALIZED;
                                    continue;
                                }
                                // Create a new table entry with a new bytecode range and the same metadata.
                                int localIndex = locals[prevTableIndex + LOCALS_OFFSET_LOCAL_INDEX];
                                int frameIndex = locals[prevTableIndex + LOCALS_OFFSET_FRAME_INDEX];
                                int nameIndex = locals[prevTableIndex + LOCALS_OFFSET_NAME];
                                int infoIndex = locals[prevTableIndex + LOCALS_OFFSET_INFO];
                                operationData.locals[j] = doEmitLocal(localIndex, frameIndex, nameIndex, infoIndex);
                            }
                        }
                    }
                }
            }
        }

        /**
         * Iterates the handler table, searching for unresolved entries corresponding to the given handlerId.
         * Patches them with the handlerBci and handlerSp now that those values are known.
         */
        private void patchHandlerTable(int tableStart, int tableEnd, int handlerId, int handlerBci, int handlerSp) {
            for (int i = tableStart; i < tableEnd; i += EXCEPTION_HANDLER_LENGTH) {
                if (handlerTable[i + EXCEPTION_HANDLER_OFFSET_KIND] != HANDLER_CUSTOM) {
                    continue;
                }
                if (handlerTable[i + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI] != -handlerId) {
                    continue;
                }
                handlerTable[i + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI] = handlerBci;
                handlerTable[i + EXCEPTION_HANDLER_OFFSET_HANDLER_SP] = handlerSp;
            }
        }

        private void doEmitRoot() {
            if (!parseSources) {
                // Nothing to do here without sources
                return;
            }
            for (int i = operationSp - 1; i >= 0; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                switch (operationStack[i].operation) {
                    case Operations.SOURCESECTION :
                        if (!(operationStack[i].data instanceof SourceSectionData operationData)) {
                            throw assertionFailed("Data class SourceSectionData expected, but was " + operationStack[i].data);
                        }
                        doEmitSourceInfo(operationData.sourceIndex, 0, bci, operationData.start, operationData.length);
                        break;
                }
            }
        }

        private int allocateNode() {
            if (!reachable) {
                return -1;
            }
            return checkOverflowInt(numNodes++, "Node counter");
        }

        private short allocateBytecodeLocal() {
            return checkOverflowShort((short) numLocals++, "Number of locals");
        }

        private int allocateBranchProfile() {
            if (!reachable) {
                return -1;
            }
            return checkOverflowInt(numConditionalBranches++, "Number of branch profiles");
        }

        private ScopeData getCurrentScope() {
            for (int i = operationSp - 1; i >= rootOperationSp; i--) {
                if (operationStack[i].operation == Operations.FINALLYHANDLER) {
                    i = ((FinallyHandlerData) operationStack[i].data).finallyOperationSp;
                    continue;
                }
                if (operationStack[i].data instanceof ScopeData e) {
                    return e;
                }
            }
            throw failState("Invalid scope for local variable.");
        }

        private int doEmitLocal(int localIndex, int frameIndex, Object name, Object info) {
            int nameIndex = -1;
            if (name != null) {
                nameIndex = constantPool.addConstant(name);
            }
            int infoIndex = -1;
            if (info != null) {
                infoIndex = constantPool.addConstant(info);
            }
            return doEmitLocal(localIndex, frameIndex, nameIndex, infoIndex);
        }

        private int doEmitLocal(int localIndex, int frameIndex, int nameIndex, int infoIndex) {
            int tableIndex = allocateLocalsTableEntry();
            assert frameIndex - USER_LOCALS_START_INDEX >= 0;
            locals[tableIndex + LOCALS_OFFSET_START_BCI] = bci;
            // will be patched later at the end of the block
            locals[tableIndex + LOCALS_OFFSET_END_BCI] = -1;
            locals[tableIndex + LOCALS_OFFSET_LOCAL_INDEX] = localIndex;
            locals[tableIndex + LOCALS_OFFSET_FRAME_INDEX] = frameIndex;
            locals[tableIndex + LOCALS_OFFSET_NAME] = nameIndex;
            locals[tableIndex + LOCALS_OFFSET_INFO] = infoIndex;
            return tableIndex;
        }

        private int allocateLocalsTableEntry() {
            int result = localsTableIndex;
            if (locals == null) {
                assert result == 0;
                locals = new int[LOCALS_LENGTH * 8];
            } else if (result + LOCALS_LENGTH > locals.length) {
                locals = Arrays.copyOf(locals, Math.max(result + LOCALS_LENGTH, locals.length * 2));
            }
            localsTableIndex += LOCALS_LENGTH;
            return result;
        }

        private void serialize(DataOutput buffer, BytecodeSerializer callback, List<SLBytecodeRootNode> existingNodes) throws IOException {
            this.serialization = new SerializationState(buffer, callback);
            try {
                // 1. Serialize the root nodes and their constants.
                nodes.getParserImpl().parse(this);
                // 2. Serialize the fields stored on each root node. If existingNodes is provided, serialize those fields instead of the new root nodes' fields.
                List<SLBytecodeRootNode> nodesToSerialize = existingNodes != null ? existingNodes : serialization.builtNodes;
                int[][] nodeFields = new int[nodesToSerialize.size()][];
                for (int i = 0; i < nodeFields.length; i ++) {
                    SLBytecodeRootNode node = nodesToSerialize.get(i);
                    int[] fields = nodeFields[i] = new int[2];
                    fields[0] = serialization.serializeObject(node.tsName);
                    fields[1] = serialization.serializeObject(node.parameterCount);
                }
                serialization.buffer.writeShort(SerializationState.CODE_$END);
                // 3. Encode the constant pool indices for each root node's fields.
                for (int i = 0; i < nodeFields.length; i++) {
                    int[] fields = nodeFields[i];
                    serialization.buffer.writeInt(fields[0]);
                    serialization.buffer.writeInt(fields[1]);
                }
            } finally {
                this.serialization = null;
            }
        }

        private short serializeFinallyParser(Runnable finallyParser) throws IOException {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            SerializationState outerSerialization = serialization;
            try {
                serialization = new SerializationState(new DataOutputStream(baos), serialization);
                finallyParser.run();
                serialization.buffer.writeShort(SerializationState.CODE_$END_FINALLY_PARSER);
            } finally {
                serialization = outerSerialization;
            }
            byte[] bytes = baos.toByteArray();
            serialization.buffer.writeShort(SerializationState.CODE_$CREATE_FINALLY_PARSER);
            serialization.buffer.writeInt(bytes.length);
            serialization.buffer.write(bytes);
            return safeCastShort(serialization.finallyParserCount++);
        }

        @SuppressWarnings("hiding")
        private void deserialize(Supplier<DataInput> bufferSupplier, BytecodeDeserializer callback, DeserializationState outerContext) {
            try {
                DeserializationState context = new DeserializationState(outerContext);
                DataInput buffer = bufferSupplier.get();
                while (true) {
                    short code = buffer.readShort();
                    switch (code) {
                        case SerializationState.CODE_$CREATE_LABEL :
                        {
                            context.labels.add(createLabel());
                            break;
                        }
                        case SerializationState.CODE_$CREATE_LOCAL :
                        {
                            int nameId = buffer.readInt();
                            Object name = null;
                            if (nameId != -1) {
                                name = context.consts.get(nameId);
                            }
                            int infoId = buffer.readInt();
                            Object info = null;
                            if (infoId != -1) {
                                info = context.consts.get(infoId);
                            }
                            context.locals.add(createLocal(name, info));
                            break;
                        }
                        case SerializationState.CODE_$CREATE_NULL :
                        {
                            context.consts.add(null);
                            break;
                        }
                        case SerializationState.CODE_$CREATE_OBJECT :
                        {
                            context.consts.add(Objects.requireNonNull(callback.deserialize(context, buffer)));
                            break;
                        }
                        case SerializationState.CODE_$CREATE_FINALLY_PARSER :
                        {
                            byte[] finallyParserBytes = new byte[buffer.readInt()];
                            buffer.readFully(finallyParserBytes);
                            context.finallyParsers.add(() -> deserialize(() -> SerializationUtils.createDataInput(ByteBuffer.wrap(finallyParserBytes)), callback, context));
                            break;
                        }
                        case SerializationState.CODE_$END_FINALLY_PARSER :
                        {
                            return;
                        }
                        case SerializationState.CODE_$END :
                        {
                            for (int i = 0; i < this.builtNodes.size(); i++) {
                                SLBytecodeRootNodeGen node = this.builtNodes.get(i);
                                node.tsName = (TruffleString) context.consts.get(buffer.readInt());
                                node.parameterCount = (int) context.consts.get(buffer.readInt());
                            }
                            return;
                        }
                        case SerializationState.CODE_BEGIN_BLOCK :
                        {
                            beginBlock();
                            break;
                        }
                        case SerializationState.CODE_END_BLOCK :
                        {
                            endBlock();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_ROOT :
                        {
                            context.builtNodes.add(null);
                            beginRoot();
                            break;
                        }
                        case SerializationState.CODE_END_ROOT :
                        {
                            SLBytecodeRootNodeGen node = (SLBytecodeRootNodeGen) endRoot();
                            int serializedContextDepth = buffer.readInt();
                            if (context.depth != serializedContextDepth) {
                                throw new AssertionError("Invalid context depth. Expected " + context.depth + " but got " + serializedContextDepth);
                            }
                            context.builtNodes.set(buffer.readInt(), node);
                            break;
                        }
                        case SerializationState.CODE_BEGIN_IF_THEN :
                        {
                            beginIfThen();
                            break;
                        }
                        case SerializationState.CODE_END_IF_THEN :
                        {
                            endIfThen();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_IF_THEN_ELSE :
                        {
                            beginIfThenElse();
                            break;
                        }
                        case SerializationState.CODE_END_IF_THEN_ELSE :
                        {
                            endIfThenElse();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_CONDITIONAL :
                        {
                            beginConditional();
                            break;
                        }
                        case SerializationState.CODE_END_CONDITIONAL :
                        {
                            endConditional();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_WHILE :
                        {
                            beginWhile();
                            break;
                        }
                        case SerializationState.CODE_END_WHILE :
                        {
                            endWhile();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_TRY_CATCH :
                        {
                            beginTryCatch();
                            break;
                        }
                        case SerializationState.CODE_END_TRY_CATCH :
                        {
                            endTryCatch();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_FINALLY_TRY :
                        {
                            Runnable finallyParser = context.getContext(buffer.readShort()).finallyParsers.get(buffer.readShort());
                            beginFinallyTry(finallyParser);
                            break;
                        }
                        case SerializationState.CODE_END_FINALLY_TRY :
                        {
                            endFinallyTry();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_FINALLY_TRY_CATCH :
                        {
                            Runnable finallyParser = context.getContext(buffer.readShort()).finallyParsers.get(buffer.readShort());
                            beginFinallyTryCatch(finallyParser);
                            break;
                        }
                        case SerializationState.CODE_END_FINALLY_TRY_CATCH :
                        {
                            endFinallyTryCatch();
                            break;
                        }
                        case SerializationState.CODE_EMIT_LABEL :
                        {
                            BytecodeLabel label = context.getContext(buffer.readShort()).labels.get(buffer.readShort());
                            emitLabel(label);
                            break;
                        }
                        case SerializationState.CODE_EMIT_BRANCH :
                        {
                            BytecodeLabel label = context.getContext(buffer.readShort()).labels.get(buffer.readShort());
                            emitBranch(label);
                            break;
                        }
                        case SerializationState.CODE_EMIT_LOAD_CONSTANT :
                        {
                            Object constant = context.consts.get(buffer.readInt());
                            emitLoadConstant(constant);
                            break;
                        }
                        case SerializationState.CODE_EMIT_LOAD_NULL :
                        {
                            emitLoadNull();
                            break;
                        }
                        case SerializationState.CODE_EMIT_LOAD_ARGUMENT :
                        {
                            int index = buffer.readInt();
                            emitLoadArgument(index);
                            break;
                        }
                        case SerializationState.CODE_EMIT_LOAD_EXCEPTION :
                        {
                            emitLoadException();
                            break;
                        }
                        case SerializationState.CODE_EMIT_LOAD_LOCAL :
                        {
                            BytecodeLocal local = context.getContext(buffer.readShort()).locals.get(buffer.readShort());
                            emitLoadLocal(local);
                            break;
                        }
                        case SerializationState.CODE_BEGIN_LOAD_LOCAL_MATERIALIZED :
                        {
                            BytecodeLocal local = context.getContext(buffer.readShort()).locals.get(buffer.readShort());
                            beginLoadLocalMaterialized(local);
                            break;
                        }
                        case SerializationState.CODE_END_LOAD_LOCAL_MATERIALIZED :
                        {
                            endLoadLocalMaterialized();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_STORE_LOCAL :
                        {
                            BytecodeLocal local = context.getContext(buffer.readShort()).locals.get(buffer.readShort());
                            beginStoreLocal(local);
                            break;
                        }
                        case SerializationState.CODE_END_STORE_LOCAL :
                        {
                            endStoreLocal();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_STORE_LOCAL_MATERIALIZED :
                        {
                            BytecodeLocal local = context.getContext(buffer.readShort()).locals.get(buffer.readShort());
                            beginStoreLocalMaterialized(local);
                            break;
                        }
                        case SerializationState.CODE_END_STORE_LOCAL_MATERIALIZED :
                        {
                            endStoreLocalMaterialized();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_RETURN :
                        {
                            beginReturn();
                            break;
                        }
                        case SerializationState.CODE_END_RETURN :
                        {
                            endReturn();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SOURCE :
                        {
                            Source source = (Source) context.consts.get(buffer.readInt());
                            beginSource(source);
                            break;
                        }
                        case SerializationState.CODE_END_SOURCE :
                        {
                            endSource();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SOURCE_SECTION :
                        {
                            int index = buffer.readInt();
                            int length = buffer.readInt();
                            beginSourceSection(index, length);
                            break;
                        }
                        case SerializationState.CODE_END_SOURCE_SECTION :
                        {
                            endSourceSection();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_TAG :
                        {
                            Class<?>[] newTags = TAG_MASK_TO_TAGS.computeIfAbsent(buffer.readInt(), (v) -> mapTagMaskToTagsArray(v));
                            beginTag(newTags);
                            break;
                        }
                        case SerializationState.CODE_END_TAG :
                        {
                            Class<?>[] newTags = TAG_MASK_TO_TAGS.computeIfAbsent(buffer.readInt(), (v) -> mapTagMaskToTagsArray(v));
                            endTag(newTags);
                            break;
                        }
                        case SerializationState.CODE_EMIT_SL_ALWAYS_HALT :
                        {
                            emitSLAlwaysHalt();
                            break;
                        }
                        case SerializationState.CODE_EMIT_SL_LOAD_ARGUMENT :
                        {
                            int indexValue = (int) context.consts.get(buffer.readInt());
                            emitSLLoadArgument(indexValue);
                            break;
                        }
                        case SerializationState.CODE_EMIT_BUILTIN :
                        {
                            SLBuiltinNode builtinValue = (SLBuiltinNode) context.consts.get(buffer.readInt());
                            int argumentCountValue = (int) context.consts.get(buffer.readInt());
                            emitBuiltin(builtinValue, argumentCountValue);
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_INVOKE :
                        {
                            beginSLInvoke();
                            break;
                        }
                        case SerializationState.CODE_END_SL_INVOKE :
                        {
                            endSLInvoke();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_ADD :
                        {
                            beginSLAdd();
                            break;
                        }
                        case SerializationState.CODE_END_SL_ADD :
                        {
                            endSLAdd();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_DIV :
                        {
                            beginSLDiv();
                            break;
                        }
                        case SerializationState.CODE_END_SL_DIV :
                        {
                            endSLDiv();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_EQUAL :
                        {
                            beginSLEqual();
                            break;
                        }
                        case SerializationState.CODE_END_SL_EQUAL :
                        {
                            endSLEqual();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_LESS_OR_EQUAL :
                        {
                            beginSLLessOrEqual();
                            break;
                        }
                        case SerializationState.CODE_END_SL_LESS_OR_EQUAL :
                        {
                            endSLLessOrEqual();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_LESS_THAN :
                        {
                            beginSLLessThan();
                            break;
                        }
                        case SerializationState.CODE_END_SL_LESS_THAN :
                        {
                            endSLLessThan();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_LOGICAL_NOT :
                        {
                            beginSLLogicalNot();
                            break;
                        }
                        case SerializationState.CODE_END_SL_LOGICAL_NOT :
                        {
                            endSLLogicalNot();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_MUL :
                        {
                            beginSLMul();
                            break;
                        }
                        case SerializationState.CODE_END_SL_MUL :
                        {
                            endSLMul();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_READ_PROPERTY :
                        {
                            beginSLReadProperty();
                            break;
                        }
                        case SerializationState.CODE_END_SL_READ_PROPERTY :
                        {
                            endSLReadProperty();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_SUB :
                        {
                            beginSLSub();
                            break;
                        }
                        case SerializationState.CODE_END_SL_SUB :
                        {
                            endSLSub();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_WRITE_PROPERTY :
                        {
                            beginSLWriteProperty();
                            break;
                        }
                        case SerializationState.CODE_END_SL_WRITE_PROPERTY :
                        {
                            endSLWriteProperty();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_UNBOX :
                        {
                            beginSLUnbox();
                            break;
                        }
                        case SerializationState.CODE_END_SL_UNBOX :
                        {
                            endSLUnbox();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_FUNCTION_LITERAL :
                        {
                            beginSLFunctionLiteral();
                            break;
                        }
                        case SerializationState.CODE_END_SL_FUNCTION_LITERAL :
                        {
                            endSLFunctionLiteral();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_TO_BOOLEAN :
                        {
                            beginSLToBoolean();
                            break;
                        }
                        case SerializationState.CODE_END_SL_TO_BOOLEAN :
                        {
                            endSLToBoolean();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_AND :
                        {
                            beginSLAnd();
                            break;
                        }
                        case SerializationState.CODE_END_SL_AND :
                        {
                            endSLAnd();
                            break;
                        }
                        case SerializationState.CODE_BEGIN_SL_OR :
                        {
                            beginSLOr();
                            break;
                        }
                        case SerializationState.CODE_END_SL_OR :
                        {
                            endSLOr();
                            break;
                        }
                        default :
                        {
                            throw new AssertionError("Unknown operation code " + code);
                        }
                    }
                }
            } catch (IOException ex) {
                throw new IOError(ex);
            }
        }

        @Override
        public String toString() {
            StringBuilder b = new StringBuilder();
            b.append(SLBytecodeRootNodeGen.class.getSimpleName());
            b.append('.');
            b.append(com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder.class.getSimpleName());
            b.append("[");
            b.append("at=");
            for (int i = 0; i < operationSp; i++) {
                b.append("(");
                b.append(operationStack[i].toString(this));
            }
            for (int i = 0; i < operationSp; i++) {
                b.append(")");
            }
            b.append(", mode=");
            if (serialization != null) {
                b.append("serializing");
            } else if (reparseReason != null) {
                b.append("reparsing");
            } else {
                b.append("default");
            }
            b.append(", bytecodeIndex=").append(bci);
            b.append(", stackPointer=").append(currentStackHeight);
            b.append(", bytecodes=").append(parseBytecodes);
            b.append(", sources=").append(parseSources);
            b.append(", tags=");
            String sepTag = "";
            if ((tags & CLASS_TO_TAG_MASK.get(CallTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(CallTag.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(StatementTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(StatementTag.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(RootTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(RootTag.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(RootBodyTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(RootBodyTag.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(ExpressionTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(ExpressionTag.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(AlwaysHalt.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(AlwaysHalt.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(ReadVariableTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(ReadVariableTag.class));
                sepTag = ",";
            }
            if ((tags & CLASS_TO_TAG_MASK.get(WriteVariableTag.class)) != 0) {
                b.append(sepTag);
                b.append(Tag.getIdentifier(WriteVariableTag.class));
                sepTag = ",";
            }
            b.append("]");
            return b.toString();
        }

        private RuntimeException failState(String message) {
            throw new IllegalStateException("Invalid builder usage: " + message + " Operation stack: " + dumpAt());
        }

        private RuntimeException failArgument(String message) {
            throw new IllegalArgumentException("Invalid builder operation argument: " + message + " Operation stack: " + dumpAt());
        }

        private String dumpAt() {
            try {
                StringBuilder b = new StringBuilder();
                for (int i = 0; i < operationSp; i++) {
                    b.append("(");
                    b.append(operationStack[i].toString(this));
                }
                for (int i = 0; i < operationSp; i++) {
                    b.append(")");
                }
                return b.toString();
            } catch (Exception e) {
                return "<invalid-location>";
            }
        }

        private boolean doEmitInstruction(short instruction, int stackEffect) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 2);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionS(short instruction, int stackEffect, short data0) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 4);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putShort(bc, bci + 2 /* imm localOffset */, data0);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionI(short instruction, int stackEffect, int data0) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 6);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putInt(bc, bci + 2 /* imm branch_target */, data0);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionSS(short instruction, int stackEffect, short data0, short data1) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 6);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putShort(bc, bci + 2 /* imm localOffset */, data0);
            BYTES.putShort(bc, bci + 4 /* imm localIndex */, data1);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionSSS(short instruction, int stackEffect, short data0, short data1, short data2) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 8);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putShort(bc, bci + 2 /* imm localOffset */, data0);
            BYTES.putShort(bc, bci + 4 /* imm localIndex */, data1);
            BYTES.putShort(bc, bci + 6 /* imm rootIndex */, data2);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionII(short instruction, int stackEffect, int data0, int data1) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 10);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putInt(bc, bci + 2 /* imm child0 */, data0);
            BYTES.putInt(bc, bci + 6 /* imm child1 */, data1);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionSSI(short instruction, int stackEffect, short data0, short data1, int data2) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 10);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putShort(bc, bci + 2 /* imm localOffset */, data0);
            BYTES.putShort(bc, bci + 4 /* imm localIndex */, data1);
            BYTES.putInt(bc, bci + 6 /* imm child0 */, data2);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionSSSI(short instruction, int stackEffect, short data0, short data1, short data2, int data3) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 12);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putShort(bc, bci + 2 /* imm localOffset */, data0);
            BYTES.putShort(bc, bci + 4 /* imm localIndex */, data1);
            BYTES.putShort(bc, bci + 6 /* imm rootIndex */, data2);
            BYTES.putInt(bc, bci + 8 /* imm child0 */, data3);
            bci = newBci;
            return true;
        }

        private boolean doEmitInstructionIII(short instruction, int stackEffect, int data0, int data1, int data2) {
            if (stackEffect != 0) {
                currentStackHeight += stackEffect;
                assert currentStackHeight >= 0;
            }
            if (stackEffect > 0) {
                updateMaxStackHeight(currentStackHeight);
            }
            if (!reachable) {
                return false;
            }
            int newBci = checkBci(bci + 14);
            if (newBci > bc.length) {
                ensureBytecodeCapacity(newBci);
            }
            BYTES.putShort(bc, bci + 0, instruction);
            BYTES.putInt(bc, bci + 2 /* imm builtin */, data0);
            BYTES.putInt(bc, bci + 6 /* imm argumentCount */, data1);
            BYTES.putInt(bc, bci + 10 /* imm node */, data2);
            bci = newBci;
            return true;
        }

        private static short safeCastShort(int num) {
            if (Short.MIN_VALUE <= num && num <= Short.MAX_VALUE) {
                return (short) num;
            }
            throw BytecodeEncodingException.create("Value " + num + " cannot be encoded as a short.");
        }

        private static short checkOverflowShort(short num, String valueName) {
            if (num < 0) {
                throw BytecodeEncodingException.create(valueName + " overflowed.");
            }
            return num;
        }

        private static int checkOverflowInt(int num, String valueName) {
            if (num < 0) {
                throw BytecodeEncodingException.create(valueName + " overflowed.");
            }
            return num;
        }

        private static int checkBci(int newBci) {
            return checkOverflowInt(newBci, "Bytecode index");
        }

        private static class SavedState {

            private int operationSequenceNumber;
            private OperationStackEntry[] operationStack;
            private int operationSp;
            private int rootOperationSp;
            private int numLocals;
            private int numLabels;
            private int numNodes;
            private int numHandlers;
            private int numConditionalBranches;
            private byte[] bc;
            private int bci;
            private int currentStackHeight;
            private int maxStackHeight;
            private int[] sourceInfo;
            private int sourceInfoIndex;
            private int[] handlerTable;
            private int handlerTableSize;
            private int[] locals;
            private int localsTableIndex;
            private HashMap<BytecodeLabel, ArrayList<Integer>> unresolvedLabels;
            private ConstantPool constantPool;
            private boolean reachable = true;
            private int maxLocals;
            private List<TagNode> tagRoots;
            private List<TagNode> tagNodes;
            private SavedState savedState;

            SavedState(int operationSequenceNumber, OperationStackEntry[] operationStack, int operationSp, int rootOperationSp, int numLocals, int numLabels, int numNodes, int numHandlers, int numConditionalBranches, byte[] bc, int bci, int currentStackHeight, int maxStackHeight, int[] sourceInfo, int sourceInfoIndex, int[] handlerTable, int handlerTableSize, int[] locals, int localsTableIndex, HashMap<BytecodeLabel, ArrayList<Integer>> unresolvedLabels, ConstantPool constantPool, boolean reachable, int maxLocals, List<TagNode> tagRoots, List<TagNode> tagNodes, SavedState savedState) {
                this.operationSequenceNumber = operationSequenceNumber;
                this.operationStack = operationStack;
                this.operationSp = operationSp;
                this.rootOperationSp = rootOperationSp;
                this.numLocals = numLocals;
                this.numLabels = numLabels;
                this.numNodes = numNodes;
                this.numHandlers = numHandlers;
                this.numConditionalBranches = numConditionalBranches;
                this.bc = bc;
                this.bci = bci;
                this.currentStackHeight = currentStackHeight;
                this.maxStackHeight = maxStackHeight;
                this.sourceInfo = sourceInfo;
                this.sourceInfoIndex = sourceInfoIndex;
                this.handlerTable = handlerTable;
                this.handlerTableSize = handlerTableSize;
                this.locals = locals;
                this.localsTableIndex = localsTableIndex;
                this.unresolvedLabels = unresolvedLabels;
                this.constantPool = constantPool;
                this.reachable = reachable;
                this.maxLocals = maxLocals;
                this.tagRoots = tagRoots;
                this.tagNodes = tagNodes;
                this.savedState = savedState;
            }

        }
        private static class OperationStackEntry {

            private final int operation;
            private final Object data;
            private final int sequenceNumber;
            private int childCount = 0;
            private ArrayList<BytecodeLabel> declaredLabels = null;

            OperationStackEntry(int operation, Object data, int sequenceNumber) {
                this.operation = operation;
                this.data = data;
                this.sequenceNumber = sequenceNumber;
            }

            public void addDeclaredLabel(BytecodeLabel label) {
                if (declaredLabels == null) {
                    declaredLabels = new ArrayList<>(8);
                }
                declaredLabels.add(label);
            }

            @Override
            public String toString() {
                return "(" + toString(null) + ")";
            }

            private String toString(com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder builder) {
                StringBuilder b = new StringBuilder();
                b.append(OPERATION_NAMES[operation]);
                switch (operation) {
                    case Operations.BLOCK :
                    {
                        BlockData operationData = (BlockData) data;
                        if (operationData.numLocals > 0) {
                            b.append(" locals=");
                            b.append(operationData.numLocals);
                        }
                    }
                    break;
                    case Operations.ROOT :
                    {
                        RootData operationData = (RootData) data;
                        if (operationData.numLocals > 0) {
                            b.append(" locals=");
                            b.append(operationData.numLocals);
                        }
                    }
                    break;
                    case Operations.STORELOCAL :
                    {
                        b.append(" ");
                        StoreLocalData operationData = (StoreLocalData) data;
                        b.append(operationData.local.frameIndex);
                    }
                    break;
                    case Operations.STORELOCALMATERIALIZED :
                    {
                        b.append(" ");
                        StoreLocalData operationData = (StoreLocalData) data;
                        b.append(operationData.local.frameIndex);
                    }
                    break;
                    case Operations.SOURCE :
                    {
                        b.append(" ");
                        SourceData operationData = (SourceData) data;
                        b.append(operationData.sourceIndex);
                        if (builder != null) {
                            b.append(":");
                            b.append(builder.sources.get(operationData.sourceIndex).getName());
                        }
                    }
                    break;
                    case Operations.SOURCESECTION :
                    {
                        b.append(" ");
                        SourceSectionData operationData = (SourceSectionData) data;
                        b.append(operationData.start);
                        b.append(":");
                        b.append(operationData.length);
                    }
                    break;
                    case Operations.TAG :
                    {
                        b.append(" ");
                        TagOperationData operationData = (TagOperationData) data;
                        b.append(operationData.node);
                    }
                    break;
                }
                return b.toString();
            }

        }
        private static class ConstantPool {

            private final ArrayList<Object> constants;
            private final HashMap<Object, Integer> map;

            ConstantPool() {
                constants = new ArrayList<>();
                map = new HashMap<>();
            }

            private int addConstant(Object constant) {
                if (map.containsKey(constant)) {
                    return map.get(constant);
                }
                int index = constants.size();
                constants.add(constant);
                map.put(constant, index);
                return index;
            }

            /**
             * Allocates a slot for a constant which will be manually added to the constant pool later.
             */
            private short allocateSlot() {
                short index = safeCastShort(constants.size());
                constants.add(null);
                return index;
            }

            private Object[] toArray() {
                return constants.toArray();
            }

        }
        private static final class BytecodeLocalImpl extends BytecodeLocal {

            private final short frameIndex;
            private final short localIndex;
            private final short rootIndex;
            private final ScopeData scope;

            BytecodeLocalImpl(short frameIndex, short localIndex, short rootIndex, ScopeData scope) {
                super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
                this.frameIndex = frameIndex;
                this.localIndex = localIndex;
                this.rootIndex = rootIndex;
                this.scope = scope;
            }

            @Override
            public int getLocalOffset() {
                return frameIndex - USER_LOCALS_START_INDEX;
            }

        }
        private static final class BytecodeLabelImpl extends BytecodeLabel {

            private final int id;
            int bci;
            private final int declaringOp;

            BytecodeLabelImpl(int id, int bci, int declaringOp) {
                super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
                this.id = id;
                this.bci = bci;
                this.declaringOp = declaringOp;
            }

            public boolean isDefined() {
                return bci != -1;
            }

            @Override
            public boolean equals(Object other) {
                if (!(other instanceof BytecodeLabelImpl)) {
                    return false;
                }
                return this.id == ((BytecodeLabelImpl) other).id;
            }

            @Override
            public int hashCode() {
                return this.id;
            }

        }
        private abstract static class ScopeData {

            int frameOffset;
            /**
             * The indices of this scope's locals in the global locals table. Used to patch in the end bci at the end of the scope.
             */
            int[] locals = null;
            /**
             * The number of locals allocated in the frame for this scope.
             */
            int numLocals = 0;
            boolean valid = true;

            public void registerLocal(int tableIndex) {
                int localTableIndex = numLocals++;
                if (locals == null) {
                    locals = new int[8];
                } else if (localTableIndex >= locals.length) {
                    locals = Arrays.copyOf(locals, locals.length * 2);
                }
                locals[localTableIndex] = tableIndex;
            }

        }
        private static final class BlockData extends ScopeData {

            final int startStackHeight;
            boolean producedValue;
            int childBci;

            BlockData(int startStackHeight) {
                this.startStackHeight = startStackHeight;
                this.producedValue = false;
                this.childBci = UNINITIALIZED;
            }

        }
        private static final class RootData extends ScopeData {

            final short index;
            boolean producedValue;
            int childBci;
            boolean reachable;

            RootData(short index) {
                this.index = index;
                this.producedValue = false;
                this.childBci = UNINITIALIZED;
                this.reachable = true;
            }

        }
        private static final class IfThenData {

            boolean thenReachable;
            int falseBranchFixupBci;

            IfThenData(boolean thenReachable) {
                this.thenReachable = thenReachable;
                this.falseBranchFixupBci = UNINITIALIZED;
            }

        }
        private static final class IfThenElseData {

            boolean thenReachable;
            boolean elseReachable;
            int falseBranchFixupBci;
            int endBranchFixupBci;

            IfThenElseData(boolean thenReachable, boolean elseReachable) {
                this.thenReachable = thenReachable;
                this.elseReachable = elseReachable;
                this.falseBranchFixupBci = UNINITIALIZED;
                this.endBranchFixupBci = UNINITIALIZED;
            }

        }
        private static final class ConditionalData {

            boolean thenReachable;
            boolean elseReachable;
            int falseBranchFixupBci;
            int endBranchFixupBci;
            int child0Bci;
            int child1Bci;

            ConditionalData(boolean thenReachable, boolean elseReachable) {
                this.thenReachable = thenReachable;
                this.elseReachable = elseReachable;
                this.falseBranchFixupBci = UNINITIALIZED;
                this.endBranchFixupBci = UNINITIALIZED;
                this.child0Bci = UNINITIALIZED;
                this.child1Bci = UNINITIALIZED;
            }

        }
        private static final class WhileData {

            final int whileStartBci;
            boolean bodyReachable;
            int endBranchFixupBci;

            WhileData(int whileStartBci, boolean bodyReachable) {
                this.whileStartBci = whileStartBci;
                this.bodyReachable = bodyReachable;
                this.endBranchFixupBci = UNINITIALIZED;
            }

        }
        private static final class TryCatchData {

            final int handlerId;
            final short stackHeight;
            int tryStartBci;
            final boolean operationReachable;
            boolean tryReachable;
            boolean catchReachable;
            int endBranchFixupBci;
            int extraTableEntriesStart;
            int extraTableEntriesEnd;

            TryCatchData(int handlerId, short stackHeight, int tryStartBci, boolean operationReachable, boolean tryReachable, boolean catchReachable) {
                this.handlerId = handlerId;
                this.stackHeight = stackHeight;
                this.tryStartBci = tryStartBci;
                this.operationReachable = operationReachable;
                this.tryReachable = tryReachable;
                this.catchReachable = catchReachable;
                this.endBranchFixupBci = UNINITIALIZED;
                this.extraTableEntriesStart = UNINITIALIZED;
                this.extraTableEntriesEnd = UNINITIALIZED;
            }

        }
        private static final class FinallyTryData {

            final int handlerId;
            final short stackHeight;
            final Runnable finallyParser;
            int tryStartBci;
            final boolean operationReachable;
            boolean tryReachable;
            boolean catchReachable;
            int endBranchFixupBci;
            int extraTableEntriesStart;
            int extraTableEntriesEnd;
            /**
             * The index of the finally handler operation on the operation stack.
             * This value is uninitialized unless a finally handler is being emitted, and allows us to
             * walk the operation stack from bottom to top.
             */
            int finallyHandlerSp;

            FinallyTryData(int handlerId, short stackHeight, Runnable finallyParser, int tryStartBci, boolean operationReachable, boolean tryReachable, boolean catchReachable) {
                this.handlerId = handlerId;
                this.stackHeight = stackHeight;
                this.finallyParser = finallyParser;
                this.tryStartBci = tryStartBci;
                this.operationReachable = operationReachable;
                this.tryReachable = tryReachable;
                this.catchReachable = catchReachable;
                this.endBranchFixupBci = UNINITIALIZED;
                this.extraTableEntriesStart = UNINITIALIZED;
                this.extraTableEntriesEnd = UNINITIALIZED;
                this.finallyHandlerSp = UNINITIALIZED;
            }

        }
        private static final class FinallyHandlerData {

            /**
             * The index of the finally operation (FinallyTry/FinallyTryCatch) on the operation stack.
             * This index should only be used to skip over the handler when walking the operation stack.
             * It should *not* be used to access the finally operation data, because a FinallyHandler is
             * sometimes emitted after the finally operation has already been popped.
             */
            final int finallyOperationSp;

            FinallyHandlerData(int finallyOperationSp) {
                this.finallyOperationSp = finallyOperationSp;
            }

        }
        private static final class StoreLocalData {

            BytecodeLocalImpl local;
            int childBci;

            StoreLocalData(BytecodeLocalImpl local) {
                this.local = local;
                this.childBci = UNINITIALIZED;
            }

        }
        private static final class ReturnOperationData {

            boolean producedValue;
            int childBci;

            ReturnOperationData() {
                this.producedValue = false;
                this.childBci = UNINITIALIZED;
            }

        }
        private static final class SourceData {

            final int sourceIndex;
            boolean producedValue;
            int childBci;

            SourceData(int sourceIndex) {
                this.sourceIndex = sourceIndex;
                this.producedValue = false;
                this.childBci = UNINITIALIZED;
            }

        }
        private static final class SourceSectionData {

            final int sourceIndex;
            int startBci;
            final int start;
            final int length;
            boolean producedValue;
            int childBci;

            SourceSectionData(int sourceIndex, int startBci, int start, int length) {
                this.sourceIndex = sourceIndex;
                this.startBci = startBci;
                this.start = start;
                this.length = length;
                this.producedValue = false;
                this.childBci = UNINITIALIZED;
            }

        }
        private static final class TagOperationData {

            final int nodeId;
            final boolean operationReachable;
            final int startStackHeight;
            final TagNode node;
            int handlerStartBci;
            boolean producedValue;
            int childBci;
            List<TagNode> children;

            TagOperationData(int nodeId, boolean operationReachable, int startStackHeight, TagNode node) {
                this.nodeId = nodeId;
                this.operationReachable = operationReachable;
                this.startStackHeight = startStackHeight;
                this.node = node;
                this.handlerStartBci = node.enterBci;
                this.producedValue = false;
                this.childBci = UNINITIALIZED;
                this.children = null;
            }

        }
        private static final class CustomOperationData {

            final int[] childBcis;
            final int[] constants;
            final Object[] locals;

            CustomOperationData(int[] childBcis, int[] constants, Object... locals) {
                this.childBcis = childBcis;
                this.constants = constants;
                this.locals = locals;
            }

        }
        private static final class CustomShortCircuitOperationData {

            int childBci;
            List<Integer> branchFixupBcis;

            CustomShortCircuitOperationData() {
                this.childBci = UNINITIALIZED;
                this.branchFixupBcis = new ArrayList<>(4);
            }

        }
        private static final class SerializationRootNode extends SLBytecodeRootNode {

            private final int contextDepth;
            private final int rootIndex;

            private SerializationRootNode(com.oracle.truffle.api.frame.FrameDescriptor.Builder builder, int contextDepth, int rootIndex) {
                super(null, builder.build());
                this.contextDepth = contextDepth;
                this.rootIndex = rootIndex;
            }

            @Override
            public Object execute(VirtualFrame frame) {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected boolean isInstrumentable() {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected void prepareForInstrumentation(Set<Class<?>> materializedTags) {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected boolean isCloneUninitializedSupported() {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected RootNode cloneUninitialized() {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected int findBytecodeIndex(Node node, Frame frame) {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected boolean isCaptureFramesForTrace(boolean compiled) {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            public SourceSection getSourceSection() {
                throw new IllegalStateException("method should not be called");
            }

            @Override
            protected Object translateStackTraceElement(TruffleStackTraceElement stackTraceElement) {
                throw new IllegalStateException("method should not be called");
            }

        }
        private static final class SerializationLocal extends BytecodeLocal {

            private final int contextDepth;
            private final int localIndex;

            SerializationLocal(int contextDepth, int localIndex) {
                super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
                this.contextDepth = contextDepth;
                this.localIndex = localIndex;
            }

            @Override
            public int getLocalOffset() {
                throw new IllegalStateException();
            }

        }
        private static final class SerializationLabel extends BytecodeLabel {

            private final int contextDepth;
            private final int labelIndex;

            SerializationLabel(int contextDepth, int labelIndex) {
                super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
                this.contextDepth = contextDepth;
                this.labelIndex = labelIndex;
            }

        }
        private static class SerializationState implements SerializerContext {

            private static final short CODE_$CREATE_LABEL = -2;
            private static final short CODE_$CREATE_LOCAL = -3;
            private static final short CODE_$CREATE_OBJECT = -4;
            private static final short CODE_$CREATE_NULL = -5;
            private static final short CODE_$CREATE_FINALLY_PARSER = -6;
            private static final short CODE_$END_FINALLY_PARSER = -7;
            private static final short CODE_$END = -8;
            private static final short CODE_BEGIN_BLOCK = 1 << 1;
            private static final short CODE_END_BLOCK = (1 << 1) | 0b1;
            private static final short CODE_BEGIN_ROOT = 2 << 1;
            private static final short CODE_END_ROOT = (2 << 1) | 0b1;
            private static final short CODE_BEGIN_IF_THEN = 3 << 1;
            private static final short CODE_END_IF_THEN = (3 << 1) | 0b1;
            private static final short CODE_BEGIN_IF_THEN_ELSE = 4 << 1;
            private static final short CODE_END_IF_THEN_ELSE = (4 << 1) | 0b1;
            private static final short CODE_BEGIN_CONDITIONAL = 5 << 1;
            private static final short CODE_END_CONDITIONAL = (5 << 1) | 0b1;
            private static final short CODE_BEGIN_WHILE = 6 << 1;
            private static final short CODE_END_WHILE = (6 << 1) | 0b1;
            private static final short CODE_BEGIN_TRY_CATCH = 7 << 1;
            private static final short CODE_END_TRY_CATCH = (7 << 1) | 0b1;
            private static final short CODE_BEGIN_FINALLY_TRY = 8 << 1;
            private static final short CODE_END_FINALLY_TRY = (8 << 1) | 0b1;
            private static final short CODE_BEGIN_FINALLY_TRY_CATCH = 9 << 1;
            private static final short CODE_END_FINALLY_TRY_CATCH = (9 << 1) | 0b1;
            private static final short CODE_EMIT_LABEL = 11 << 1;
            private static final short CODE_EMIT_BRANCH = 12 << 1;
            private static final short CODE_EMIT_LOAD_CONSTANT = 13 << 1;
            private static final short CODE_EMIT_LOAD_NULL = 14 << 1;
            private static final short CODE_EMIT_LOAD_ARGUMENT = 15 << 1;
            private static final short CODE_EMIT_LOAD_EXCEPTION = 16 << 1;
            private static final short CODE_EMIT_LOAD_LOCAL = 17 << 1;
            private static final short CODE_BEGIN_LOAD_LOCAL_MATERIALIZED = 18 << 1;
            private static final short CODE_END_LOAD_LOCAL_MATERIALIZED = (18 << 1) | 0b1;
            private static final short CODE_BEGIN_STORE_LOCAL = 19 << 1;
            private static final short CODE_END_STORE_LOCAL = (19 << 1) | 0b1;
            private static final short CODE_BEGIN_STORE_LOCAL_MATERIALIZED = 20 << 1;
            private static final short CODE_END_STORE_LOCAL_MATERIALIZED = (20 << 1) | 0b1;
            private static final short CODE_BEGIN_RETURN = 21 << 1;
            private static final short CODE_END_RETURN = (21 << 1) | 0b1;
            private static final short CODE_BEGIN_SOURCE = 22 << 1;
            private static final short CODE_END_SOURCE = (22 << 1) | 0b1;
            private static final short CODE_BEGIN_SOURCE_SECTION = 23 << 1;
            private static final short CODE_END_SOURCE_SECTION = (23 << 1) | 0b1;
            private static final short CODE_BEGIN_TAG = 24 << 1;
            private static final short CODE_END_TAG = (24 << 1) | 0b1;
            private static final short CODE_EMIT_SL_ALWAYS_HALT = 25 << 1;
            private static final short CODE_EMIT_SL_LOAD_ARGUMENT = 26 << 1;
            private static final short CODE_EMIT_BUILTIN = 27 << 1;
            private static final short CODE_BEGIN_SL_INVOKE = 28 << 1;
            private static final short CODE_END_SL_INVOKE = (28 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_ADD = 29 << 1;
            private static final short CODE_END_SL_ADD = (29 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_DIV = 30 << 1;
            private static final short CODE_END_SL_DIV = (30 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_EQUAL = 31 << 1;
            private static final short CODE_END_SL_EQUAL = (31 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_LESS_OR_EQUAL = 32 << 1;
            private static final short CODE_END_SL_LESS_OR_EQUAL = (32 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_LESS_THAN = 33 << 1;
            private static final short CODE_END_SL_LESS_THAN = (33 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_LOGICAL_NOT = 34 << 1;
            private static final short CODE_END_SL_LOGICAL_NOT = (34 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_MUL = 35 << 1;
            private static final short CODE_END_SL_MUL = (35 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_READ_PROPERTY = 36 << 1;
            private static final short CODE_END_SL_READ_PROPERTY = (36 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_SUB = 37 << 1;
            private static final short CODE_END_SL_SUB = (37 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_WRITE_PROPERTY = 38 << 1;
            private static final short CODE_END_SL_WRITE_PROPERTY = (38 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_UNBOX = 39 << 1;
            private static final short CODE_END_SL_UNBOX = (39 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_FUNCTION_LITERAL = 40 << 1;
            private static final short CODE_END_SL_FUNCTION_LITERAL = (40 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_TO_BOOLEAN = 41 << 1;
            private static final short CODE_END_SL_TO_BOOLEAN = (41 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_AND = 42 << 1;
            private static final short CODE_END_SL_AND = (42 << 1) | 0b1;
            private static final short CODE_BEGIN_SL_OR = 43 << 1;
            private static final short CODE_END_SL_OR = (43 << 1) | 0b1;

            private final DataOutput buffer;
            private final BytecodeSerializer callback;
            private final SerializationState outer;
            private final int depth;
            private final HashMap<Object, Integer> objects = new HashMap<>();
            private final ArrayList<SLBytecodeRootNode> builtNodes = new ArrayList<>();
            private final ArrayDeque<SerializationRootNode> rootStack = new ArrayDeque<>();
            private int labelCount;
            private int localCount;
            private short rootCount;
            private int finallyParserCount;

            private SerializationState(DataOutput buffer, BytecodeSerializer callback) {
                this.buffer = buffer;
                this.callback = callback;
                this.outer = null;
                this.depth = 0;
            }

            private SerializationState(DataOutput buffer, SerializationState outer) {
                this.buffer = buffer;
                this.callback = outer.callback;
                this.outer = outer;
                this.depth = safeCastShort(outer.depth + 1);
            }

            private int serializeObject(Object object) throws IOException {
                Integer index = objects.get(object);
                if (index == null) {
                    index = objects.size();
                    objects.put(object, index);
                    if (object == null) {
                        buffer.writeShort(CODE_$CREATE_NULL);
                    } else {
                        buffer.writeShort(CODE_$CREATE_OBJECT);
                        callback.serialize(this, buffer, object);
                    }
                }
                return index;
            }

            @Override
            @SuppressWarnings("hiding")
            public void writeBytecodeNode(DataOutput buffer, BytecodeRootNode node) throws IOException {
                SerializationRootNode serializationRoot = (SerializationRootNode) node;
                buffer.writeInt(serializationRoot.contextDepth);
                buffer.writeInt(serializationRoot.rootIndex);
            }

        }
        private static final class DeserializationState implements DeserializerContext {

            private final DeserializationState outer;
            private final int depth;
            private final ArrayList<Object> consts = new ArrayList<>();
            private final ArrayList<SLBytecodeRootNodeGen> builtNodes = new ArrayList<>();
            private final ArrayList<BytecodeLabel> labels = new ArrayList<>();
            private final ArrayList<BytecodeLocal> locals = new ArrayList<>();
            private final ArrayList<Runnable> finallyParsers = new ArrayList<>();

            private DeserializationState(DeserializationState outer) {
                this.outer = outer;
                this.depth = (outer == null) ? 0 : outer.depth + 1;
            }

            @Override
            public BytecodeRootNode readBytecodeNode(DataInput buffer) throws IOException {
                return getContext(buffer.readInt()).builtNodes.get(buffer.readInt());
            }

            private DeserializationState getContext(int targetDepth) {
                assert targetDepth >= 0;
                DeserializationState ctx = this;
                while (ctx.depth != targetDepth) {
                    ctx = ctx.outer;
                }
                return ctx;
            }

        }
    }
    private static final class BytecodeConfigEncoderImpl extends BytecodeConfigEncoder {

        private static final BytecodeConfigEncoderImpl INSTANCE = new BytecodeConfigEncoderImpl();

        private BytecodeConfigEncoderImpl() {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
        }

        @Override
        protected long encodeInstrumentation(Class<?> c) throws IllegalArgumentException {
            throw new IllegalArgumentException(String.format("Invalid instrumentation specified. Instrumentation '%s' does not exist or is not an instrumentation for 'com.oracle.truffle.sl.bytecode.SLBytecodeRootNode'. Instrumentations can be specified using the @Instrumentation annotation.", c.getName()));
        }

        @Override
        protected long encodeTag(Class<?> c) throws IllegalArgumentException {
            return ((long) CLASS_TO_TAG_MASK.get(c)) << 32;
        }

        private static long decode(BytecodeConfig config) {
            return decode(getEncoder(config), getEncoding(config));
        }

        private static long decode(BytecodeConfigEncoder encoder, long encoding) {
            if (encoder != null && encoder  != BytecodeConfigEncoderImpl.INSTANCE) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                throw new IllegalArgumentException("Encoded config is not compatible with this bytecode node.");
            }
            return (encoding & 0xff00000001L);
        }

    }
    private static final class BytecodeRootNodesImpl extends BytecodeRootNodes<SLBytecodeRootNode> {

        private static final Object VISIBLE_TOKEN = TOKEN;

        private volatile long encoding;

        BytecodeRootNodesImpl(BytecodeParser<com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder> generator, BytecodeConfig config) {
            super(VISIBLE_TOKEN, generator);
            this.encoding = BytecodeConfigEncoderImpl.decode(config);
        }

        @Override
        @SuppressWarnings("hiding")
        protected boolean updateImpl(BytecodeConfigEncoder encoder, long encoding) {
            long maskedEncoding = BytecodeConfigEncoderImpl.decode(encoder, encoding);
            long oldEncoding = this.encoding;
            long newEncoding = maskedEncoding | oldEncoding;
            if ((oldEncoding | newEncoding) == oldEncoding) {
                return false;
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return performUpdate(maskedEncoding);
        }

        private synchronized boolean performUpdate(long maskedEncoding) {
            long oldEncoding = this.encoding;
            long newEncoding = maskedEncoding | oldEncoding;
            if ((oldEncoding | newEncoding) == oldEncoding) {
                // double checked locking
                return false;
            }
            boolean oldSources = (oldEncoding & 0b1) != 0;
            int oldInstrumentations = (int)((oldEncoding >> 1) & 0x7FFF_FFFF);
            int oldTags = (int)((oldEncoding >> 32) & 0xFFFF_FFFF);
            boolean newSources = (newEncoding & 0b1) != 0;
            int newInstrumentations = (int)((newEncoding >> 1) & 0x7FFF_FFFF);
            int newTags = (int)((newEncoding >> 32) & 0xFFFF_FFFF);
            boolean needsBytecodeReparse = newInstrumentations != oldInstrumentations || newTags != oldTags;
            boolean needsSourceReparse = newSources != oldSources || (needsBytecodeReparse && newSources);
            if (!needsBytecodeReparse && !needsSourceReparse) {
                return false;
            }
            BytecodeParser<com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder> parser = getParserImpl();
            UpdateReason reason = new UpdateReason(oldSources != newSources, newInstrumentations & ~oldInstrumentations, newTags & ~oldTags);
            Builder builder = new Builder(this, needsBytecodeReparse, newTags, newInstrumentations, needsSourceReparse, reason);
            for (SLBytecodeRootNode node : nodes) {
                builder.builtNodes.add((SLBytecodeRootNodeGen) node);
            }
            parser.parse(builder);
            builder.finish();
            this.encoding = newEncoding;
            return true;
        }

        private void setNodes(SLBytecodeRootNodeGen[] nodes) {
            if (this.nodes != null) {
                throw new AssertionError();
            }
            this.nodes = nodes;
            for (SLBytecodeRootNodeGen node : nodes) {
                if (node.getRootNodes() != this) {
                    throw new AssertionError();
                }
                if (node != nodes[node.buildIndex]) {
                    throw new AssertionError();
                }
            }
        }

        @SuppressWarnings("unchecked")
        private BytecodeParser<com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder> getParserImpl() {
            return (BytecodeParser<com.oracle.truffle.sl.bytecode.SLBytecodeRootNodeGen.Builder>) super.getParser();
        }

        private boolean validate() {
            for (SLBytecodeRootNode node : nodes) {
                ((SLBytecodeRootNodeGen) node).getBytecodeNodeImpl().validateBytecodes();
            }
            return true;
        }

        private SLLanguage getLanguage() {
            if (nodes.length == 0) {
                return null;
            }
            return nodes[0].getLanguage(SLLanguage.class);
        }

        /**
         * Serializes the given bytecode nodes
         * All metadata (e.g., source info) is serialized (even if it has not yet been parsed).
         * <p>
         * This method serializes the root nodes with their current field values.
         *
         * @param buffer the buffer to write the byte output to.
         * @param callback the language-specific serializer for constants in the bytecode.
         */
        @Override
        @SuppressWarnings("cast")
        public void serialize(DataOutput buffer, BytecodeSerializer callback) throws IOException {
            ArrayList<SLBytecodeRootNode> existingNodes = new ArrayList<>(nodes.length);
            for (int i = 0; i < nodes.length; i++) {
                existingNodes.add((SLBytecodeRootNodeGen) nodes[i]);
            }
            SLBytecodeRootNodeGen.doSerialize(buffer, callback, new Builder(getLanguage(), this, BytecodeConfig.COMPLETE), existingNodes);
        }

        private static final class UpdateReason implements CharSequence {

            private final boolean newSources;
            private final int newInstrumentations;
            private final int newTags;

            UpdateReason(boolean newSources, int newInstrumentations, int newTags) {
                this.newSources = newSources;
                this.newInstrumentations = newInstrumentations;
                this.newTags = newTags;
            }

            @Override
            public int length() {
                return toString().length();
            }

            @Override
            public char charAt(int index) {
                return toString().charAt(index);
            }

            @Override
            public CharSequence subSequence(int start, int end) {
                return toString().subSequence(start, end);
            }

            @Override
            public String toString() {
                StringBuilder message = new StringBuilder();
                message.append("SLBytecodeRootNode requested ");
                String sep = "";
                if (newSources) {
                    message.append("SourceInformation");
                    sep = ", ";
                }
                if (newTags != 0) {
                    if ((newTags & 0x1) != 0) {
                        message.append(sep);
                        message.append("Tag[CallTag]");
                        sep = ", ";
                    }
                    if ((newTags & 0x2) != 0) {
                        message.append(sep);
                        message.append("Tag[StatementTag]");
                        sep = ", ";
                    }
                    if ((newTags & 0x4) != 0) {
                        message.append(sep);
                        message.append("Tag[RootTag]");
                        sep = ", ";
                    }
                    if ((newTags & 0x8) != 0) {
                        message.append(sep);
                        message.append("Tag[RootBodyTag]");
                        sep = ", ";
                    }
                    if ((newTags & 0x10) != 0) {
                        message.append(sep);
                        message.append("Tag[ExpressionTag]");
                        sep = ", ";
                    }
                    if ((newTags & 0x20) != 0) {
                        message.append(sep);
                        message.append("Tag[AlwaysHalt]");
                        sep = ", ";
                    }
                    if ((newTags & 0x40) != 0) {
                        message.append(sep);
                        message.append("Tag[ReadVariableTag]");
                        sep = ", ";
                    }
                    if ((newTags & 0x80) != 0) {
                        message.append(sep);
                        message.append("Tag[WriteVariableTag]");
                        sep = ", ";
                    }
                }
                message.append(".");
                return message.toString();
            }

        }
    }
    private static final class Instructions {

        /*
         * Instruction pop
         * kind: POP
         * encoding: [1 : short, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short POP = 1;
        /*
         * Instruction pop$Long
         * kind: POP
         * encoding: [2 : short, child0 (bci) : int]
         * signature: void (long)
         */
        private static final short POP$LONG = 2;
        /*
         * Instruction pop$Boolean
         * kind: POP
         * encoding: [3 : short, child0 (bci) : int]
         * signature: void (boolean)
         */
        private static final short POP$BOOLEAN = 3;
        /*
         * Instruction pop$generic
         * kind: POP
         * encoding: [4 : short, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short POP$GENERIC = 4;
        /*
         * Instruction dup
         * kind: DUP
         * encoding: [5 : short]
         * signature: void ()
         */
        private static final short DUP = 5;
        /*
         * Instruction return
         * kind: RETURN
         * encoding: [6 : short]
         * signature: void (Object)
         */
        private static final short RETURN = 6;
        /*
         * Instruction branch
         * kind: BRANCH
         * encoding: [7 : short, branch_target (bci) : int]
         * signature: void ()
         */
        private static final short BRANCH = 7;
        /*
         * Instruction branch.backward
         * kind: BRANCH_BACKWARD
         * encoding: [8 : short, branch_target (bci) : int, loop_header_branch_profile (branch_profile) : int]
         * signature: void ()
         */
        private static final short BRANCH_BACKWARD = 8;
        /*
         * Instruction branch.false
         * kind: BRANCH_FALSE
         * encoding: [9 : short, branch_target (bci) : int, branch_profile : int, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short BRANCH_FALSE = 9;
        /*
         * Instruction branch.false$Generic
         * kind: BRANCH_FALSE
         * encoding: [10 : short, branch_target (bci) : int, branch_profile : int, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short BRANCH_FALSE$GENERIC = 10;
        /*
         * Instruction branch.false$Boolean
         * kind: BRANCH_FALSE
         * encoding: [11 : short, branch_target (bci) : int, branch_profile : int, child0 (bci) : int]
         * signature: void (boolean)
         */
        private static final short BRANCH_FALSE$BOOLEAN = 11;
        /*
         * Instruction store.local
         * kind: STORE_LOCAL
         * encoding: [12 : short, localOffset : short, localIndex : short, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short STORE_LOCAL = 12;
        /*
         * Instruction store.local$Long
         * kind: STORE_LOCAL
         * encoding: [13 : short, localOffset : short, localIndex : short, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short STORE_LOCAL$LONG = 13;
        /*
         * Instruction store.local$Long$Long
         * kind: STORE_LOCAL
         * encoding: [14 : short, localOffset : short, localIndex : short, child0 (bci) : int]
         * signature: void (long)
         */
        private static final short STORE_LOCAL$LONG$LONG = 14;
        /*
         * Instruction store.local$Boolean
         * kind: STORE_LOCAL
         * encoding: [15 : short, localOffset : short, localIndex : short, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short STORE_LOCAL$BOOLEAN = 15;
        /*
         * Instruction store.local$Boolean$Boolean
         * kind: STORE_LOCAL
         * encoding: [16 : short, localOffset : short, localIndex : short, child0 (bci) : int]
         * signature: void (boolean)
         */
        private static final short STORE_LOCAL$BOOLEAN$BOOLEAN = 16;
        /*
         * Instruction store.local$generic
         * kind: STORE_LOCAL
         * encoding: [17 : short, localOffset : short, localIndex : short, child0 (bci) : int]
         * signature: void (Object)
         */
        private static final short STORE_LOCAL$GENERIC = 17;
        /*
         * Instruction throw
         * kind: THROW
         * encoding: [18 : short]
         * signature: void (Object)
         */
        private static final short THROW = 18;
        /*
         * Instruction load.constant
         * kind: LOAD_CONSTANT
         * encoding: [19 : short, constant (const) : int]
         * signature: Object ()
         */
        private static final short LOAD_CONSTANT = 19;
        /*
         * Instruction load.constant$Long
         * kind: LOAD_CONSTANT
         * encoding: [20 : short, constant (const) : int]
         * signature: long ()
         */
        private static final short LOAD_CONSTANT$LONG = 20;
        /*
         * Instruction load.constant$Boolean
         * kind: LOAD_CONSTANT
         * encoding: [21 : short, constant (const) : int]
         * signature: boolean ()
         */
        private static final short LOAD_CONSTANT$BOOLEAN = 21;
        /*
         * Instruction load.null
         * kind: LOAD_NULL
         * encoding: [22 : short]
         * signature: Object ()
         */
        private static final short LOAD_NULL = 22;
        /*
         * Instruction load.argument
         * kind: LOAD_ARGUMENT
         * encoding: [23 : short, index (short) : short]
         * signature: Object ()
         */
        private static final short LOAD_ARGUMENT = 23;
        /*
         * Instruction load.argument$Long
         * kind: LOAD_ARGUMENT
         * encoding: [24 : short, index (short) : short]
         * signature: long ()
         */
        private static final short LOAD_ARGUMENT$LONG = 24;
        /*
         * Instruction load.argument$Boolean
         * kind: LOAD_ARGUMENT
         * encoding: [25 : short, index (short) : short]
         * signature: boolean ()
         */
        private static final short LOAD_ARGUMENT$BOOLEAN = 25;
        /*
         * Instruction load.exception
         * kind: LOAD_EXCEPTION
         * encoding: [26 : short, exceptionSp (sp) : short]
         * signature: Object ()
         */
        private static final short LOAD_EXCEPTION = 26;
        /*
         * Instruction load.local
         * kind: LOAD_LOCAL
         * encoding: [27 : short, localOffset : short, localIndex : short]
         * signature: Object ()
         */
        private static final short LOAD_LOCAL = 27;
        /*
         * Instruction load.local$Long
         * kind: LOAD_LOCAL
         * encoding: [28 : short, localOffset : short, localIndex : short]
         * signature: Object ()
         */
        private static final short LOAD_LOCAL$LONG = 28;
        /*
         * Instruction load.local$Long$unboxed
         * kind: LOAD_LOCAL
         * encoding: [29 : short, localOffset : short, localIndex : short]
         * signature: long ()
         */
        private static final short LOAD_LOCAL$LONG$UNBOXED = 29;
        /*
         * Instruction load.local$Boolean
         * kind: LOAD_LOCAL
         * encoding: [30 : short, localOffset : short, localIndex : short]
         * signature: Object ()
         */
        private static final short LOAD_LOCAL$BOOLEAN = 30;
        /*
         * Instruction load.local$Boolean$unboxed
         * kind: LOAD_LOCAL
         * encoding: [31 : short, localOffset : short, localIndex : short]
         * signature: boolean ()
         */
        private static final short LOAD_LOCAL$BOOLEAN$UNBOXED = 31;
        /*
         * Instruction load.local$generic
         * kind: LOAD_LOCAL
         * encoding: [32 : short, localOffset : short, localIndex : short]
         * signature: Object ()
         */
        private static final short LOAD_LOCAL$GENERIC = 32;
        /*
         * Instruction load.local.mat
         * kind: LOAD_LOCAL_MATERIALIZED
         * encoding: [33 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
         * signature: Object (Object)
         */
        private static final short LOAD_LOCAL_MAT = 33;
        /*
         * Instruction load.local.mat$Long
         * kind: LOAD_LOCAL_MATERIALIZED
         * encoding: [34 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
         * signature: Object (Object)
         */
        private static final short LOAD_LOCAL_MAT$LONG = 34;
        /*
         * Instruction load.local.mat$Long$unboxed
         * kind: LOAD_LOCAL_MATERIALIZED
         * encoding: [35 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
         * signature: long (Object)
         */
        private static final short LOAD_LOCAL_MAT$LONG$UNBOXED = 35;
        /*
         * Instruction load.local.mat$Boolean
         * kind: LOAD_LOCAL_MATERIALIZED
         * encoding: [36 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
         * signature: Object (Object)
         */
        private static final short LOAD_LOCAL_MAT$BOOLEAN = 36;
        /*
         * Instruction load.local.mat$Boolean$unboxed
         * kind: LOAD_LOCAL_MATERIALIZED
         * encoding: [37 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
         * signature: boolean (Object)
         */
        private static final short LOAD_LOCAL_MAT$BOOLEAN$UNBOXED = 37;
        /*
         * Instruction load.local.mat$generic
         * kind: LOAD_LOCAL_MATERIALIZED
         * encoding: [38 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short]
         * signature: Object (Object)
         */
        private static final short LOAD_LOCAL_MAT$GENERIC = 38;
        /*
         * Instruction store.local.mat
         * kind: STORE_LOCAL_MATERIALIZED
         * encoding: [39 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
         * signature: void (Object, Object)
         */
        private static final short STORE_LOCAL_MAT = 39;
        /*
         * Instruction store.local.mat$Long
         * kind: STORE_LOCAL_MATERIALIZED
         * encoding: [40 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
         * signature: void (Object, Object)
         */
        private static final short STORE_LOCAL_MAT$LONG = 40;
        /*
         * Instruction store.local.mat$Long$Long
         * kind: STORE_LOCAL_MATERIALIZED
         * encoding: [41 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
         * signature: void (long, Object)
         */
        private static final short STORE_LOCAL_MAT$LONG$LONG = 41;
        /*
         * Instruction store.local.mat$Boolean
         * kind: STORE_LOCAL_MATERIALIZED
         * encoding: [42 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
         * signature: void (Object, Object)
         */
        private static final short STORE_LOCAL_MAT$BOOLEAN = 42;
        /*
         * Instruction store.local.mat$Boolean$Boolean
         * kind: STORE_LOCAL_MATERIALIZED
         * encoding: [43 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
         * signature: void (boolean, Object)
         */
        private static final short STORE_LOCAL_MAT$BOOLEAN$BOOLEAN = 43;
        /*
         * Instruction store.local.mat$generic
         * kind: STORE_LOCAL_MATERIALIZED
         * encoding: [44 : short, localOffset : short, localIndex : short, rootIndex (localRoot) : short, child0 (bci) : int]
         * signature: void (Object, Object)
         */
        private static final short STORE_LOCAL_MAT$GENERIC = 44;
        /*
         * Instruction tag.enter
         * kind: TAG_ENTER
         * encoding: [45 : short, tag : int]
         * signature: void ()
         */
        private static final short TAG_ENTER = 45;
        /*
         * Instruction tag.leave
         * kind: TAG_LEAVE
         * encoding: [46 : short, tag : int, child0 (bci) : int]
         * signature: Object (Object)
         */
        private static final short TAG_LEAVE = 46;
        /*
         * Instruction tag.leave$Long
         * kind: TAG_LEAVE
         * encoding: [47 : short, tag : int, child0 (bci) : int]
         * signature: Object (long)
         */
        private static final short TAG_LEAVE$LONG = 47;
        /*
         * Instruction tag.leave$Long$unboxed
         * kind: TAG_LEAVE
         * encoding: [48 : short, tag : int, child0 (bci) : int]
         * signature: long (Object)
         */
        private static final short TAG_LEAVE$LONG$UNBOXED = 48;
        /*
         * Instruction tag.leave$Boolean
         * kind: TAG_LEAVE
         * encoding: [49 : short, tag : int, child0 (bci) : int]
         * signature: Object (boolean)
         */
        private static final short TAG_LEAVE$BOOLEAN = 49;
        /*
         * Instruction tag.leave$Boolean$unboxed
         * kind: TAG_LEAVE
         * encoding: [50 : short, tag : int, child0 (bci) : int]
         * signature: boolean (Object)
         */
        private static final short TAG_LEAVE$BOOLEAN$UNBOXED = 50;
        /*
         * Instruction tag.leave$generic
         * kind: TAG_LEAVE
         * encoding: [51 : short, tag : int, child0 (bci) : int]
         * signature: Object (Object)
         */
        private static final short TAG_LEAVE$GENERIC = 51;
        /*
         * Instruction tag.leaveVoid
         * kind: TAG_LEAVE_VOID
         * encoding: [52 : short, tag : int]
         * signature: Object ()
         */
        private static final short TAG_LEAVE_VOID = 52;
        /*
         * Instruction load.variadic_0
         * kind: LOAD_VARIADIC
         * encoding: [53 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_0 = 53;
        /*
         * Instruction load.variadic_1
         * kind: LOAD_VARIADIC
         * encoding: [54 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_1 = 54;
        /*
         * Instruction load.variadic_2
         * kind: LOAD_VARIADIC
         * encoding: [55 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_2 = 55;
        /*
         * Instruction load.variadic_3
         * kind: LOAD_VARIADIC
         * encoding: [56 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_3 = 56;
        /*
         * Instruction load.variadic_4
         * kind: LOAD_VARIADIC
         * encoding: [57 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_4 = 57;
        /*
         * Instruction load.variadic_5
         * kind: LOAD_VARIADIC
         * encoding: [58 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_5 = 58;
        /*
         * Instruction load.variadic_6
         * kind: LOAD_VARIADIC
         * encoding: [59 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_6 = 59;
        /*
         * Instruction load.variadic_7
         * kind: LOAD_VARIADIC
         * encoding: [60 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_7 = 60;
        /*
         * Instruction load.variadic_8
         * kind: LOAD_VARIADIC
         * encoding: [61 : short]
         * signature: void (Object)
         */
        private static final short LOAD_VARIADIC_8 = 61;
        /*
         * Instruction merge.variadic
         * kind: MERGE_VARIADIC
         * encoding: [62 : short]
         * signature: Object (Object)
         */
        private static final short MERGE_VARIADIC = 62;
        /*
         * Instruction constant_null
         * kind: STORE_NULL
         * encoding: [63 : short]
         * signature: Object ()
         */
        private static final short CONSTANT_NULL = 63;
        /*
         * Instruction clear.local
         * kind: CLEAR_LOCAL
         * encoding: [64 : short, localOffset : short]
         * signature: void ()
         */
        private static final short CLEAR_LOCAL = 64;
        /*
         * Instruction c.SLAlwaysHalt
         * kind: CUSTOM
         * encoding: [65 : short, node : int]
         * nodeType: SLAlwaysHalt
         * signature: void ()
         */
        private static final short SL_ALWAYS_HALT_ = 65;
        /*
         * Instruction c.SLLoadArgument
         * kind: CUSTOM
         * encoding: [66 : short, index (const) : int, node : int]
         * nodeType: SLLoadArgument
         * signature: Object (int)
         */
        private static final short SL_LOAD_ARGUMENT_ = 66;
        /*
         * Instruction c.SLLoadArgument$LoadInBounds
         * kind: CUSTOM
         * encoding: [67 : short, index (const) : int, node : int]
         * nodeType: SLLoadArgument
         * signature: Object (int)
         */
        private static final short SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_ = 67;
        /*
         * Instruction c.Builtin
         * kind: CUSTOM
         * encoding: [68 : short, builtin (const) : int, argumentCount (const) : int, node : int]
         * nodeType: Builtin
         * signature: Object (SLBuiltinNode, int)
         */
        private static final short BUILTIN_ = 68;
        /*
         * Instruction c.SLInvoke
         * kind: CUSTOM
         * encoding: [69 : short, node : int]
         * nodeType: SLInvoke
         * signature: Object (Object, Object[]...)
         */
        private static final short SL_INVOKE_ = 69;
        /*
         * Instruction c.SLAdd
         * kind: CUSTOM
         * encoding: [70 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLAddNode
         * signature: Object (Object, Object)
         */
        private static final short SL_ADD_ = 70;
        /*
         * Instruction c.SLAdd$Long
         * kind: CUSTOM
         * encoding: [71 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLAddNode
         * signature: long (long, long)
         */
        private static final short SL_ADD$LONG_ = 71;
        /*
         * Instruction c.SLAdd$Long$unboxed
         * kind: CUSTOM
         * encoding: [72 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLAddNode
         * signature: long (long, long)
         */
        private static final short SL_ADD$LONG$UNBOXED_ = 72;
        /*
         * Instruction c.SLDiv
         * kind: CUSTOM
         * encoding: [73 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLDivNode
         * signature: Object (Object, Object)
         */
        private static final short SL_DIV_ = 73;
        /*
         * Instruction c.SLDiv$Long
         * kind: CUSTOM
         * encoding: [74 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLDivNode
         * signature: long (long, long)
         */
        private static final short SL_DIV$LONG_ = 74;
        /*
         * Instruction c.SLDiv$Long$unboxed
         * kind: CUSTOM
         * encoding: [75 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLDivNode
         * signature: long (long, long)
         */
        private static final short SL_DIV$LONG$UNBOXED_ = 75;
        /*
         * Instruction c.SLEqual
         * kind: CUSTOM
         * encoding: [76 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLEqualNode
         * signature: boolean (Object, Object)
         */
        private static final short SL_EQUAL_ = 76;
        /*
         * Instruction c.SLEqual$Long
         * kind: CUSTOM
         * encoding: [77 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLEqualNode
         * signature: boolean (long, long)
         */
        private static final short SL_EQUAL$LONG_ = 77;
        /*
         * Instruction c.SLEqual$Long$unboxed
         * kind: CUSTOM
         * encoding: [78 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLEqualNode
         * signature: boolean (long, long)
         */
        private static final short SL_EQUAL$LONG$UNBOXED_ = 78;
        /*
         * Instruction c.SLEqual$Boolean
         * kind: CUSTOM
         * encoding: [79 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLEqualNode
         * signature: boolean (boolean, boolean)
         */
        private static final short SL_EQUAL$BOOLEAN_ = 79;
        /*
         * Instruction c.SLEqual$Boolean$unboxed
         * kind: CUSTOM
         * encoding: [80 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLEqualNode
         * signature: boolean (boolean, boolean)
         */
        private static final short SL_EQUAL$BOOLEAN$UNBOXED_ = 80;
        /*
         * Instruction c.SLEqual$unboxed
         * kind: CUSTOM
         * encoding: [81 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLEqualNode
         * signature: boolean (Object, Object)
         */
        private static final short SL_EQUAL$UNBOXED_ = 81;
        /*
         * Instruction c.SLLessOrEqual
         * kind: CUSTOM
         * encoding: [82 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessOrEqualNode
         * signature: Object (Object, Object)
         */
        private static final short SL_LESS_OR_EQUAL_ = 82;
        /*
         * Instruction c.SLLessOrEqual$Long
         * kind: CUSTOM
         * encoding: [83 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessOrEqualNode
         * signature: boolean (long, long)
         */
        private static final short SL_LESS_OR_EQUAL$LONG_ = 83;
        /*
         * Instruction c.SLLessOrEqual$Long$unboxed
         * kind: CUSTOM
         * encoding: [84 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessOrEqualNode
         * signature: boolean (long, long)
         */
        private static final short SL_LESS_OR_EQUAL$LONG$UNBOXED_ = 84;
        /*
         * Instruction c.SLLessOrEqual$SLBigInteger#InteropBigInteger0#InteropBigInteger1
         * kind: CUSTOM
         * encoding: [85 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessOrEqualNode
         * signature: boolean (Object, Object)
         */
        private static final short SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_ = 85;
        /*
         * Instruction c.SLLessOrEqual$SLBigInteger#InteropBigInteger0#InteropBigInteger1$unboxed
         * kind: CUSTOM
         * encoding: [86 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessOrEqualNode
         * signature: boolean (Object, Object)
         */
        private static final short SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_ = 86;
        /*
         * Instruction c.SLLessThan
         * kind: CUSTOM
         * encoding: [87 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessThanNode
         * signature: boolean (Object, Object)
         */
        private static final short SL_LESS_THAN_ = 87;
        /*
         * Instruction c.SLLessThan$Long
         * kind: CUSTOM
         * encoding: [88 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessThanNode
         * signature: boolean (long, long)
         */
        private static final short SL_LESS_THAN$LONG_ = 88;
        /*
         * Instruction c.SLLessThan$Long$unboxed
         * kind: CUSTOM
         * encoding: [89 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessThanNode
         * signature: boolean (long, long)
         */
        private static final short SL_LESS_THAN$LONG$UNBOXED_ = 89;
        /*
         * Instruction c.SLLessThan$unboxed
         * kind: CUSTOM
         * encoding: [90 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLLessThanNode
         * signature: boolean (Object, Object)
         */
        private static final short SL_LESS_THAN$UNBOXED_ = 90;
        /*
         * Instruction c.SLLogicalNot
         * kind: CUSTOM
         * encoding: [91 : short, node : int, child0 (bci) : int]
         * nodeType: SLLogicalNotNode
         * signature: boolean (Object)
         */
        private static final short SL_LOGICAL_NOT_ = 91;
        /*
         * Instruction c.SLLogicalNot$Boolean
         * kind: CUSTOM
         * encoding: [92 : short, node : int, child0 (bci) : int]
         * nodeType: SLLogicalNotNode
         * signature: boolean (boolean)
         */
        private static final short SL_LOGICAL_NOT$BOOLEAN_ = 92;
        /*
         * Instruction c.SLLogicalNot$Boolean$unboxed
         * kind: CUSTOM
         * encoding: [93 : short, node : int, child0 (bci) : int]
         * nodeType: SLLogicalNotNode
         * signature: boolean (boolean)
         */
        private static final short SL_LOGICAL_NOT$BOOLEAN$UNBOXED_ = 93;
        /*
         * Instruction c.SLLogicalNot$unboxed
         * kind: CUSTOM
         * encoding: [94 : short, node : int, child0 (bci) : int]
         * nodeType: SLLogicalNotNode
         * signature: boolean (Object)
         */
        private static final short SL_LOGICAL_NOT$UNBOXED_ = 94;
        /*
         * Instruction c.SLMul
         * kind: CUSTOM
         * encoding: [95 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLMulNode
         * signature: Object (Object, Object)
         */
        private static final short SL_MUL_ = 95;
        /*
         * Instruction c.SLMul$Long
         * kind: CUSTOM
         * encoding: [96 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLMulNode
         * signature: long (long, long)
         */
        private static final short SL_MUL$LONG_ = 96;
        /*
         * Instruction c.SLMul$Long$unboxed
         * kind: CUSTOM
         * encoding: [97 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLMulNode
         * signature: long (long, long)
         */
        private static final short SL_MUL$LONG$UNBOXED_ = 97;
        /*
         * Instruction c.SLReadProperty
         * kind: CUSTOM
         * encoding: [98 : short, node : int]
         * nodeType: SLReadPropertyNode
         * signature: Object (Object, Object)
         */
        private static final short SL_READ_PROPERTY_ = 98;
        /*
         * Instruction c.SLSub
         * kind: CUSTOM
         * encoding: [99 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLSubNode
         * signature: Object (Object, Object)
         */
        private static final short SL_SUB_ = 99;
        /*
         * Instruction c.SLSub$Long
         * kind: CUSTOM
         * encoding: [100 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLSubNode
         * signature: long (long, long)
         */
        private static final short SL_SUB$LONG_ = 100;
        /*
         * Instruction c.SLSub$Long$unboxed
         * kind: CUSTOM
         * encoding: [101 : short, node : int, child0 (bci) : int, child1 (bci) : int]
         * nodeType: SLSubNode
         * signature: long (long, long)
         */
        private static final short SL_SUB$LONG$UNBOXED_ = 101;
        /*
         * Instruction c.SLWriteProperty
         * kind: CUSTOM
         * encoding: [102 : short, node : int]
         * nodeType: SLWritePropertyNode
         * signature: Object (Object, Object, Object)
         */
        private static final short SL_WRITE_PROPERTY_ = 102;
        /*
         * Instruction c.SLUnbox
         * kind: CUSTOM
         * encoding: [103 : short, node : int, child0 (bci) : int]
         * nodeType: SLUnboxNode
         * signature: Object (Object)
         */
        private static final short SL_UNBOX_ = 103;
        /*
         * Instruction c.SLUnbox$FromBoolean
         * kind: CUSTOM
         * encoding: [104 : short, node : int, child0 (bci) : int]
         * nodeType: SLUnboxNode
         * signature: boolean (boolean)
         */
        private static final short SL_UNBOX$FROM_BOOLEAN_ = 104;
        /*
         * Instruction c.SLUnbox$FromBoolean$unboxed
         * kind: CUSTOM
         * encoding: [105 : short, node : int, child0 (bci) : int]
         * nodeType: SLUnboxNode
         * signature: boolean (boolean)
         */
        private static final short SL_UNBOX$FROM_BOOLEAN$UNBOXED_ = 105;
        /*
         * Instruction c.SLUnbox$FromLong
         * kind: CUSTOM
         * encoding: [106 : short, node : int, child0 (bci) : int]
         * nodeType: SLUnboxNode
         * signature: long (long)
         */
        private static final short SL_UNBOX$FROM_LONG_ = 106;
        /*
         * Instruction c.SLUnbox$FromLong$unboxed
         * kind: CUSTOM
         * encoding: [107 : short, node : int, child0 (bci) : int]
         * nodeType: SLUnboxNode
         * signature: long (long)
         */
        private static final short SL_UNBOX$FROM_LONG$UNBOXED_ = 107;
        /*
         * Instruction c.SLFunctionLiteral
         * kind: CUSTOM
         * encoding: [108 : short, node : int]
         * nodeType: SLFunctionLiteralNode
         * signature: SLFunction (TruffleString)
         */
        private static final short SL_FUNCTION_LITERAL_ = 108;
        /*
         * Instruction c.SLToBoolean
         * kind: CUSTOM
         * encoding: [109 : short, node : int, child0 (bci) : int]
         * nodeType: SLToBooleanNode
         * signature: boolean (Object)
         */
        private static final short SL_TO_BOOLEAN_ = 109;
        /*
         * Instruction c.SLToBoolean$Boolean
         * kind: CUSTOM
         * encoding: [110 : short, node : int, child0 (bci) : int]
         * nodeType: SLToBooleanNode
         * signature: boolean (boolean)
         */
        private static final short SL_TO_BOOLEAN$BOOLEAN_ = 110;
        /*
         * Instruction c.SLToBoolean$Boolean$unboxed
         * kind: CUSTOM
         * encoding: [111 : short, node : int, child0 (bci) : int]
         * nodeType: SLToBooleanNode
         * signature: boolean (boolean)
         */
        private static final short SL_TO_BOOLEAN$BOOLEAN$UNBOXED_ = 111;
        /*
         * Instruction c.SLToBoolean$unboxed
         * kind: CUSTOM
         * encoding: [112 : short, node : int, child0 (bci) : int]
         * nodeType: SLToBooleanNode
         * signature: boolean (Object)
         */
        private static final short SL_TO_BOOLEAN$UNBOXED_ = 112;
        /*
         * Instruction sc.SLAnd
         * kind: CUSTOM_SHORT_CIRCUIT
         * encoding: [113 : short, branch_target (bci) : int, branch_profile : int]
         * signature: Object (boolean, boolean)
         */
        private static final short SL_AND_ = 113;
        /*
         * Instruction sc.SLOr
         * kind: CUSTOM_SHORT_CIRCUIT
         * encoding: [114 : short, branch_target (bci) : int, branch_profile : int]
         * signature: Object (boolean, boolean)
         */
        private static final short SL_OR_ = 114;
        /*
         * Instruction merge.conditional
         * kind: MERGE_CONDITIONAL
         * encoding: [115 : short, child0 (bci) : int, child1 (bci) : int]
         * signature: Object (boolean, Object)
         */
        private static final short MERGE_CONDITIONAL = 115;
        /*
         * Instruction merge.conditional$Long
         * kind: MERGE_CONDITIONAL
         * encoding: [116 : short, child0 (bci) : int, child1 (bci) : int]
         * signature: Object (boolean, long)
         */
        private static final short MERGE_CONDITIONAL$LONG = 116;
        /*
         * Instruction merge.conditional$Long$unboxed
         * kind: MERGE_CONDITIONAL
         * encoding: [117 : short, child0 (bci) : int, child1 (bci) : int]
         * signature: long (boolean, long)
         */
        private static final short MERGE_CONDITIONAL$LONG$UNBOXED = 117;
        /*
         * Instruction merge.conditional$Boolean
         * kind: MERGE_CONDITIONAL
         * encoding: [118 : short, child0 (bci) : int, child1 (bci) : int]
         * signature: Object (boolean, boolean)
         */
        private static final short MERGE_CONDITIONAL$BOOLEAN = 118;
        /*
         * Instruction merge.conditional$Boolean$unboxed
         * kind: MERGE_CONDITIONAL
         * encoding: [119 : short, child0 (bci) : int, child1 (bci) : int]
         * signature: boolean (boolean, boolean)
         */
        private static final short MERGE_CONDITIONAL$BOOLEAN$UNBOXED = 119;
        /*
         * Instruction merge.conditional$generic
         * kind: MERGE_CONDITIONAL
         * encoding: [120 : short, child0 (bci) : int, child1 (bci) : int]
         * signature: Object (boolean, Object)
         */
        private static final short MERGE_CONDITIONAL$GENERIC = 120;
        /*
         * Instruction invalidate0
         * kind: INVALIDATE
         * encoding: [121 : short]
         * signature: void ()
         */
        private static final short INVALIDATE0 = 121;
        /*
         * Instruction invalidate1
         * kind: INVALIDATE
         * encoding: [122 : short, invalidated0 (short) : short]
         * signature: void ()
         */
        private static final short INVALIDATE1 = 122;
        /*
         * Instruction invalidate2
         * kind: INVALIDATE
         * encoding: [123 : short, invalidated0 (short) : short, invalidated1 (short) : short]
         * signature: void ()
         */
        private static final short INVALIDATE2 = 123;
        /*
         * Instruction invalidate3
         * kind: INVALIDATE
         * encoding: [124 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short]
         * signature: void ()
         */
        private static final short INVALIDATE3 = 124;
        /*
         * Instruction invalidate4
         * kind: INVALIDATE
         * encoding: [125 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short, invalidated3 (short) : short]
         * signature: void ()
         */
        private static final short INVALIDATE4 = 125;
        /*
         * Instruction invalidate5
         * kind: INVALIDATE
         * encoding: [126 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short, invalidated3 (short) : short, invalidated4 (short) : short]
         * signature: void ()
         */
        private static final short INVALIDATE5 = 126;
        /*
         * Instruction invalidate6
         * kind: INVALIDATE
         * encoding: [127 : short, invalidated0 (short) : short, invalidated1 (short) : short, invalidated2 (short) : short, invalidated3 (short) : short, invalidated4 (short) : short, invalidated5 (short) : short]
         * signature: void ()
         */
        private static final short INVALIDATE6 = 127;

    }
    private static final class Operations {

        private static final int BLOCK = 1;
        private static final int ROOT = 2;
        private static final int IFTHEN = 3;
        private static final int IFTHENELSE = 4;
        private static final int CONDITIONAL = 5;
        private static final int WHILE = 6;
        private static final int TRYCATCH = 7;
        private static final int FINALLYTRY = 8;
        private static final int FINALLYTRYCATCH = 9;
        private static final int FINALLYHANDLER = 10;
        private static final int LABEL = 11;
        private static final int BRANCH = 12;
        private static final int LOADCONSTANT = 13;
        private static final int LOADNULL = 14;
        private static final int LOADARGUMENT = 15;
        private static final int LOADEXCEPTION = 16;
        private static final int LOADLOCAL = 17;
        private static final int LOADLOCALMATERIALIZED = 18;
        private static final int STORELOCAL = 19;
        private static final int STORELOCALMATERIALIZED = 20;
        private static final int RETURN = 21;
        private static final int SOURCE = 22;
        private static final int SOURCESECTION = 23;
        private static final int TAG = 24;
        private static final int SLALWAYSHALT = 25;
        private static final int SLLOADARGUMENT = 26;
        private static final int BUILTIN = 27;
        private static final int SLINVOKE = 28;
        private static final int SLADD = 29;
        private static final int SLDIV = 30;
        private static final int SLEQUAL = 31;
        private static final int SLLESSOREQUAL = 32;
        private static final int SLLESSTHAN = 33;
        private static final int SLLOGICALNOT = 34;
        private static final int SLMUL = 35;
        private static final int SLREADPROPERTY = 36;
        private static final int SLSUB = 37;
        private static final int SLWRITEPROPERTY = 38;
        private static final int SLUNBOX = 39;
        private static final int SLFUNCTIONLITERAL = 40;
        private static final int SLTOBOOLEAN = 41;
        private static final int SLAND = 42;
        private static final int SLOR = 43;

    }
    private static final class ExceptionHandlerImpl extends ExceptionHandler {

        final AbstractBytecodeNode bytecode;
        final int baseIndex;

        ExceptionHandlerImpl(AbstractBytecodeNode bytecode, int baseIndex) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.bytecode = bytecode;
            this.baseIndex = baseIndex;
        }

        @Override
        public HandlerKind getKind() {
            switch (bytecode.handlers[baseIndex + EXCEPTION_HANDLER_OFFSET_KIND]) {
                case HANDLER_TAG_EXCEPTIONAL :
                    return HandlerKind.TAG;
                default :
                    return HandlerKind.CUSTOM;
            }
        }

        @Override
        public int getStartBytecodeIndex() {
            return bytecode.handlers[baseIndex + EXCEPTION_HANDLER_OFFSET_START_BCI];
        }

        @Override
        public int getEndBytecodeIndex() {
            return bytecode.handlers[baseIndex + EXCEPTION_HANDLER_OFFSET_END_BCI];
        }

        @Override
        public int getHandlerBytecodeIndex() throws UnsupportedOperationException {
            switch (getKind()) {
                case TAG :
                    return super.getHandlerBytecodeIndex();
                default :
                    return bytecode.handlers[baseIndex + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
            }
        }

        @Override
        public TagTree getTagTree() throws UnsupportedOperationException {
            if (getKind() == HandlerKind.TAG) {
                int nodeId = bytecode.handlers[baseIndex + EXCEPTION_HANDLER_OFFSET_HANDLER_BCI];
                return bytecode.tagRoot.tagNodes[nodeId];
            } else {
                return super.getTagTree();
            }
        }

    }
    private static final class ExceptionHandlerList extends AbstractList<ExceptionHandler> {

        final AbstractBytecodeNode bytecode;

        ExceptionHandlerList(AbstractBytecodeNode bytecode) {
            this.bytecode = bytecode;
        }

        @Override
        public ExceptionHandler get(int index) {
            int baseIndex = index * EXCEPTION_HANDLER_LENGTH;
            if (baseIndex < 0 || baseIndex >= bytecode.handlers.length) {
                throw new IndexOutOfBoundsException(String.valueOf(index));
            }
            return new ExceptionHandlerImpl(bytecode, baseIndex);
        }

        @Override
        public int size() {
            return bytecode.handlers.length / EXCEPTION_HANDLER_LENGTH;
        }

    }
    private static final class SourceInformationImpl extends SourceInformation {

        final AbstractBytecodeNode bytecode;
        final int baseIndex;

        SourceInformationImpl(AbstractBytecodeNode bytecode, int baseIndex) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.bytecode = bytecode;
            this.baseIndex = baseIndex;
        }

        @Override
        public int getStartBytecodeIndex() {
            return bytecode.sourceInfo[baseIndex + SOURCE_INFO_OFFSET_START_BCI];
        }

        @Override
        public int getEndBytecodeIndex() {
            return bytecode.sourceInfo[baseIndex + SOURCE_INFO_OFFSET_END_BCI];
        }

        @Override
        public SourceSection getSourceSection() {
            return AbstractBytecodeNode.createSourceSection(bytecode.sources, bytecode.sourceInfo, baseIndex);
        }

    }
    private static final class SourceInformationList extends AbstractList<SourceInformation> {

        final AbstractBytecodeNode bytecode;

        SourceInformationList(AbstractBytecodeNode bytecode) {
            this.bytecode = bytecode;
        }

        @Override
        public SourceInformation get(int index) {
            int baseIndex = index * SOURCE_INFO_LENGTH;
            if (baseIndex < 0 || baseIndex >= bytecode.sourceInfo.length) {
                throw new IndexOutOfBoundsException(String.valueOf(index));
            }
            return new SourceInformationImpl(bytecode, baseIndex);
        }

        @Override
        public int size() {
            return bytecode.sourceInfo.length / SOURCE_INFO_LENGTH;
        }

    }
    private static final class SourceInformationTreeImpl extends SourceInformationTree {

        static final int UNAVAILABLE_ROOT = -1;

        final AbstractBytecodeNode bytecode;
        final int baseIndex;
        final List<SourceInformationTree> children;

        SourceInformationTreeImpl(AbstractBytecodeNode bytecode, int baseIndex) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.bytecode = bytecode;
            this.baseIndex = baseIndex;
            this.children = new LinkedList<SourceInformationTree>();
        }

        @Override
        public int getStartBytecodeIndex() {
            if (baseIndex == UNAVAILABLE_ROOT) {
                return 0;
            }
            return bytecode.sourceInfo[baseIndex + SOURCE_INFO_OFFSET_START_BCI];
        }

        @Override
        public int getEndBytecodeIndex() {
            if (baseIndex == UNAVAILABLE_ROOT) {
                return bytecode.bytecodes.length;
            }
            return bytecode.sourceInfo[baseIndex + SOURCE_INFO_OFFSET_END_BCI];
        }

        @Override
        public SourceSection getSourceSection() {
            if (baseIndex == UNAVAILABLE_ROOT) {
                return null;
            }
            return AbstractBytecodeNode.createSourceSection(bytecode.sources, bytecode.sourceInfo, baseIndex);
        }

        @Override
        public List<SourceInformationTree> getChildren() {
            return children;
        }

        private boolean contains(SourceInformationTreeImpl other) {
            if (baseIndex == UNAVAILABLE_ROOT) {
                return true;
            }
            return this.getStartBytecodeIndex() <= other.getStartBytecodeIndex() && other.getEndBytecodeIndex() <= this.getEndBytecodeIndex();
        }

        @TruffleBoundary
        private static SourceInformationTree parse(AbstractBytecodeNode bytecode) {
            int[] sourceInfo = bytecode.sourceInfo;
            if (sourceInfo.length == 0) {
                return null;
            }
            // Create a synthetic root node that contains all other SourceInformationTrees.
            SourceInformationTreeImpl root = new SourceInformationTreeImpl(bytecode, UNAVAILABLE_ROOT);
            int baseIndex = sourceInfo.length;
            SourceInformationTreeImpl current = root;
            ArrayDeque<SourceInformationTreeImpl> stack = new ArrayDeque<>();
            do {
                baseIndex -= SOURCE_INFO_LENGTH;
                SourceInformationTreeImpl newNode = new SourceInformationTreeImpl(bytecode, baseIndex);
                while (!current.contains(newNode)) {
                    current = stack.pop();
                }
                current.children.addFirst(newNode);
                stack.push(current);
                current = newNode;
            } while (baseIndex > 0);
            if (root.getChildren().size() == 1) {
                // If there is an actual root source section, ignore the synthetic root we created.
                return root.getChildren().getFirst();
            } else {
                return root;
            }
        }

    }
    private static final class LocalVariableImpl extends LocalVariable {

        final AbstractBytecodeNode bytecode;
        final int baseIndex;

        LocalVariableImpl(AbstractBytecodeNode bytecode, int baseIndex) {
            super(BytecodeRootNodesImpl.VISIBLE_TOKEN);
            this.bytecode = bytecode;
            this.baseIndex = baseIndex;
        }

        @Override
        public int getStartIndex() {
            return bytecode.locals[baseIndex + LOCALS_OFFSET_START_BCI];
        }

        @Override
        public int getEndIndex() {
            return bytecode.locals[baseIndex + LOCALS_OFFSET_END_BCI];
        }

        @Override
        public Object getInfo() {
            int infoId = bytecode.locals[baseIndex + LOCALS_OFFSET_INFO];
            if (infoId == -1) {
                return null;
            } else {
                return ACCESS.readObject(bytecode.constants, infoId);
            }
        }

        @Override
        public Object getName() {
            int nameId = bytecode.locals[baseIndex + LOCALS_OFFSET_NAME];
            if (nameId == -1) {
                return null;
            } else {
                return ACCESS.readObject(bytecode.constants, nameId);
            }
        }

        @Override
        public int getLocalIndex() {
            return bytecode.locals[baseIndex + LOCALS_OFFSET_LOCAL_INDEX];
        }

        @Override
        public int getLocalOffset() {
            return bytecode.locals[baseIndex + LOCALS_OFFSET_FRAME_INDEX] - USER_LOCALS_START_INDEX;
        }

        @Override
        public FrameSlotKind getTypeProfile() {
            byte[] localTags = bytecode.getLocalTags();
            if (localTags == null) {
                return null;
            }
            return FrameSlotKind.fromTag(localTags[getLocalIndex()]);
        }

    }
    private static final class LocalVariableList extends AbstractList<LocalVariable> {

        final AbstractBytecodeNode bytecode;

        LocalVariableList(AbstractBytecodeNode bytecode) {
            this.bytecode = bytecode;
        }

        @Override
        public LocalVariable get(int index) {
            int baseIndex = index * LOCALS_LENGTH;
            if (baseIndex < 0 || baseIndex >= bytecode.locals.length) {
                throw new IndexOutOfBoundsException(String.valueOf(index));
            }
            return new LocalVariableImpl(bytecode, baseIndex);
        }

        @Override
        public int size() {
            return bytecode.locals.length / LOCALS_LENGTH;
        }

    }
    private static class LoopCounter {

        private static final int REPORT_LOOP_STRIDE = 1 << 8;

        private int value;

    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLAlwaysHalt#doDefault}
     *     Activation probability: 1.00000
     *     With/without class size: 16/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLAlwaysHalt_Node extends Node {

        private static final Uncached UNCACHED = new Uncached();

        private void execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            SLAlwaysHalt.doDefault();
            return;
        }

        @GeneratedBy(SLBytecodeRootNode.class)
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public void executeUncached(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                SLAlwaysHalt.doDefault();
                return;
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLLoadArgument#doLoadInBounds}
     *     Activation probability: 0.65000
     *     With/without class size: 11/0 bytes
     *   Specialization {@link SLLoadArgument#doLoadOutOfBounds}
     *     Activation probability: 0.35000
     *     With/without class size: 8/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLLoadArgument_Node extends Node {

        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLLoadArgument#doLoadInBounds}
         *   1: SpecializationActive {@link SLLoadArgument#doLoadOutOfBounds}
         * </pre> */
        @CompilationFinal private int state_0_;

        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            int indexValue_ = ACCESS.uncheckedCast(ACCESS.readObject($bytecode.constants, BYTES.getIntUnaligned($bc, $bci + 2 /* imm index */)), Integer.class);
            if (state_0 != 0 /* is SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadInBounds(VirtualFrame, int, Object[])] || SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadOutOfBounds(int)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadInBounds(VirtualFrame, int, Object[])] */) {
                    {
                        Object[] arguments__ = (frameValue.getArguments());
                        if ((indexValue_ < arguments__.length)) {
                            return SLLoadArgument.doLoadInBounds(frameValue, indexValue_, arguments__);
                        }
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadOutOfBounds(int)] */) {
                    if (fallbackGuard_(state_0, frameValue, indexValue_, $bytecode, $bc, $bci, $sp)) {
                        return SLLoadArgument.doLoadOutOfBounds(indexValue_);
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(frameValue, indexValue_, $bytecode, $bc, $bci, $sp);
        }

        private Object executeLoadInBounds(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int indexValue_ = ACCESS.uncheckedCast(ACCESS.readObject($bytecode.constants, BYTES.getIntUnaligned($bc, $bci + 2 /* imm index */)), Integer.class);
            {
                Object[] arguments__ = (frameValue.getArguments());
                if ((indexValue_ < arguments__.length)) {
                    return SLLoadArgument.doLoadInBounds(frameValue, indexValue_, arguments__);
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(frameValue, indexValue_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, VirtualFrame frameValue, int indexValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b1) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadInBounds(VirtualFrame, int, Object[])] */) && (indexValue < (frameValue.getArguments()).length)) {
                return false;
            }
            return true;
        }

        private Object executeAndSpecialize(VirtualFrame frameValue, int indexValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            {
                Object[] arguments__ = null;
                {
                    arguments__ = (frameValue.getArguments());
                    if ((indexValue < arguments__.length)) {
                        state_0 = state_0 | 0b1 /* add SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadInBounds(VirtualFrame, int, Object[])] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLLoadArgument.doLoadInBounds(frameValue, indexValue, arguments__);
                    }
                }
            }
            state_0 = state_0 | 0b10 /* add SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadOutOfBounds(int)] */;
            this.state_0_ = state_0;
            quicken(state_0, $bc, $bci);
            return SLLoadArgument.doLoadOutOfBounds(indexValue);
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            if ((state_0 & 0b10) == 0 /* only-active SpecializationActive[SLBytecodeRootNode.SLLoadArgument.doLoadInBounds(VirtualFrame, int, Object[])] */) {
                newInstruction = Instructions.SL_LOAD_ARGUMENT$LOAD_IN_BOUNDS_;
            } else {
                newInstruction = Instructions.SL_LOAD_ARGUMENT_;
            }
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @GeneratedBy(SLBytecodeRootNode.class)
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, int indexValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if ((indexValue < (frameValue.getArguments()).length)) {
                    return SLLoadArgument.doLoadInBounds(frameValue, indexValue, (frameValue.getArguments()));
                }
                return SLLoadArgument.doLoadOutOfBounds(indexValue);
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link Builtin#doInBounds}
     *     Activation probability: 0.65000
     *     With/without class size: 11/0 bytes
     *   Specialization {@link Builtin#doOutOfBounds}
     *     Activation probability: 0.35000
     *     With/without class size: 8/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class Builtin_Node extends Node {

        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link Builtin#doInBounds}
         *   1: SpecializationActive {@link Builtin#doOutOfBounds}
         * </pre> */
        @CompilationFinal private int state_0_;

        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            SLBuiltinNode builtinValue_ = ACCESS.uncheckedCast(ACCESS.readObject($bytecode.constants, BYTES.getIntUnaligned($bc, $bci + 2 /* imm builtin */)), SLBuiltinNode.class);
            int argumentCountValue_ = ACCESS.uncheckedCast(ACCESS.readObject($bytecode.constants, BYTES.getIntUnaligned($bc, $bci + 6 /* imm argumentCount */)), Integer.class);
            if (state_0 != 0 /* is SpecializationActive[SLBytecodeRootNode.Builtin.doInBounds(VirtualFrame, SLBuiltinNode, int, Node, Object[])] || SpecializationActive[SLBytecodeRootNode.Builtin.doOutOfBounds(VirtualFrame, SLBuiltinNode, int, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLBytecodeRootNode.Builtin.doInBounds(VirtualFrame, SLBuiltinNode, int, Node, Object[])] */) {
                    {
                        Object[] arguments__ = (frameValue.getArguments());
                        if ((arguments__.length == argumentCountValue_)) {
                            Node bytecode__ = (this);
                            return Builtin.doInBounds(frameValue, builtinValue_, argumentCountValue_, bytecode__, arguments__);
                        }
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLBytecodeRootNode.Builtin.doOutOfBounds(VirtualFrame, SLBuiltinNode, int, Node)] */) {
                    {
                        Node bytecode__1 = (this);
                        if (fallbackGuard_(state_0, frameValue, builtinValue_, argumentCountValue_, $bytecode, $bc, $bci, $sp)) {
                            return Builtin.doOutOfBounds(frameValue, builtinValue_, argumentCountValue_, bytecode__1);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(frameValue, builtinValue_, argumentCountValue_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, VirtualFrame frameValue, SLBuiltinNode builtinValue, int argumentCountValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b1) != 0 /* is SpecializationActive[SLBytecodeRootNode.Builtin.doInBounds(VirtualFrame, SLBuiltinNode, int, Node, Object[])] */) && ((frameValue.getArguments()).length == argumentCountValue)) {
                return false;
            }
            return true;
        }

        private Object executeAndSpecialize(VirtualFrame frameValue, SLBuiltinNode builtinValue, int argumentCountValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            {
                Object[] arguments__ = null;
                Node bytecode__ = null;
                {
                    arguments__ = (frameValue.getArguments());
                    if ((arguments__.length == argumentCountValue)) {
                        bytecode__ = (this);
                        state_0 = state_0 | 0b1 /* add SpecializationActive[SLBytecodeRootNode.Builtin.doInBounds(VirtualFrame, SLBuiltinNode, int, Node, Object[])] */;
                        this.state_0_ = state_0;
                        return Builtin.doInBounds(frameValue, builtinValue, argumentCountValue, bytecode__, arguments__);
                    }
                }
            }
            {
                Node bytecode__1 = null;
                bytecode__1 = (this);
                state_0 = state_0 | 0b10 /* add SpecializationActive[SLBytecodeRootNode.Builtin.doOutOfBounds(VirtualFrame, SLBuiltinNode, int, Node)] */;
                this.state_0_ = state_0;
                return Builtin.doOutOfBounds(frameValue, builtinValue, argumentCountValue, bytecode__1);
            }
        }

        @GeneratedBy(SLBytecodeRootNode.class)
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, SLBuiltinNode builtinValue, int argumentCountValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((frameValue.getArguments()).length == argumentCountValue)) {
                    return Builtin.doInBounds(frameValue, builtinValue, argumentCountValue, ($bytecode), (frameValue.getArguments()));
                }
                return Builtin.doOutOfBounds(frameValue, builtinValue, argumentCountValue, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLInvoke#doDirect}
     *     Activation probability: 0.48333
     *     With/without class size: 19/12 bytes
     *   Specialization {@link SLInvoke#doIndirect}
     *     Activation probability: 0.33333
     *     With/without class size: 10/4 bytes
     *   Specialization {@link SLInvoke#doInterop}
     *     Activation probability: 0.18333
     *     With/without class size: 7/4 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLInvoke_Node extends Node {

        static final ReferenceField<DirectData> DIRECT_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "direct_cache", DirectData.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLInvoke#doDirect}
         *   1: SpecializationActive {@link SLInvoke#doIndirect}
         *   2: SpecializationActive {@link SLInvoke#doInterop}
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private DirectData direct_cache;
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLInvoke#doIndirect}
         *   Parameter: {@link IndirectCallNode} callNode</pre> */
        @Child private IndirectCallNode indirect_callNode_;
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLInvoke#doInterop}
         *   Parameter: {@link InteropLibrary} library</pre> */
        @Child private InteropLibrary interop_library_;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 2);
            Object[] child1Value_ = (Object[]) FRAMES.uncheckedGetObject(frameValue, $sp - 1);
            if (state_0 != 0 /* is SpecializationActive[SLBytecodeRootNode.SLInvoke.doDirect(SLFunction, Object[], Assumption, RootCallTarget, DirectCallNode)] || SpecializationActive[SLBytecodeRootNode.SLInvoke.doIndirect(SLFunction, Object[], IndirectCallNode)] || SpecializationActive[SLBytecodeRootNode.SLInvoke.doInterop(Object, Object[], InteropLibrary, Node)] */) {
                if ((state_0 & 0b11) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLInvoke.doDirect(SLFunction, Object[], Assumption, RootCallTarget, DirectCallNode)] || SpecializationActive[SLBytecodeRootNode.SLInvoke.doIndirect(SLFunction, Object[], IndirectCallNode)] */ && child0Value_ instanceof SLFunction) {
                    SLFunction child0Value__ = (SLFunction) child0Value_;
                    if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLInvoke.doDirect(SLFunction, Object[], Assumption, RootCallTarget, DirectCallNode)] */) {
                        DirectData s0_ = this.direct_cache;
                        while (s0_ != null) {
                            if (!Assumption.isValidAssumption((s0_.callTargetStable_))) {
                                CompilerDirectives.transferToInterpreterAndInvalidate();
                                removeDirect_(s0_);
                                return executeAndSpecialize(child0Value__, child1Value_, $bytecode, $bc, $bci, $sp);
                            }
                            if ((child0Value__.getCallTarget() == s0_.cachedTarget_)) {
                                return SLInvoke.doDirect(child0Value__, child1Value_, s0_.callTargetStable_, s0_.cachedTarget_, s0_.callNode_);
                            }
                            s0_ = s0_.next_;
                        }
                    }
                    if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLInvoke.doIndirect(SLFunction, Object[], IndirectCallNode)] */) {
                        {
                            IndirectCallNode callNode__ = this.indirect_callNode_;
                            if (callNode__ != null) {
                                return SLInvoke.doIndirect(child0Value__, child1Value_, callNode__);
                            }
                        }
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLBytecodeRootNode.SLInvoke.doInterop(Object, Object[], InteropLibrary, Node)] */) {
                    {
                        InteropLibrary library__ = this.interop_library_;
                        if (library__ != null) {
                            Node location__ = (this);
                            return SLInvoke.doInterop(child0Value_, child1Value_, library__, location__);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private Object executeAndSpecialize(Object child0Value, Object[] child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof SLFunction) {
                SLFunction child0Value_ = (SLFunction) child0Value;
                if (((state_0 & 0b10)) == 0 /* is-not SpecializationActive[SLBytecodeRootNode.SLInvoke.doIndirect(SLFunction, Object[], IndirectCallNode)] */) {
                    while (true) {
                        int count0_ = 0;
                        DirectData s0_ = DIRECT_CACHE_UPDATER.getVolatile(this);
                        DirectData s0_original = s0_;
                        while (s0_ != null) {
                            if ((child0Value_.getCallTarget() == s0_.cachedTarget_) && Assumption.isValidAssumption((s0_.callTargetStable_))) {
                                break;
                            }
                            count0_++;
                            s0_ = s0_.next_;
                        }
                        if (s0_ == null) {
                            {
                                RootCallTarget cachedTarget__ = (child0Value_.getCallTarget());
                                if ((child0Value_.getCallTarget() == cachedTarget__)) {
                                    Assumption callTargetStable__ = (child0Value_.getCallTargetStable());
                                    Assumption assumption0 = (callTargetStable__);
                                    if (Assumption.isValidAssumption(assumption0)) {
                                        if (count0_ < (3)) {
                                            s0_ = this.insert(new DirectData(s0_original));
                                            s0_.callTargetStable_ = callTargetStable__;
                                            s0_.cachedTarget_ = cachedTarget__;
                                            s0_.callNode_ = s0_.insert((DirectCallNode.create(cachedTarget__)));
                                            if (!DIRECT_CACHE_UPDATER.compareAndSet(this, s0_original, s0_)) {
                                                continue;
                                            }
                                            state_0 = state_0 | 0b1 /* add SpecializationActive[SLBytecodeRootNode.SLInvoke.doDirect(SLFunction, Object[], Assumption, RootCallTarget, DirectCallNode)] */;
                                            this.state_0_ = state_0;
                                        }
                                    }
                                }
                            }
                        }
                        if (s0_ != null) {
                            return SLInvoke.doDirect(child0Value_, child1Value, s0_.callTargetStable_, s0_.cachedTarget_, s0_.callNode_);
                        }
                        break;
                    }
                }
                VarHandle.storeStoreFence();
                this.indirect_callNode_ = this.insert((IndirectCallNode.create()));
                this.direct_cache = null;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLBytecodeRootNode.SLInvoke.doDirect(SLFunction, Object[], Assumption, RootCallTarget, DirectCallNode)] */;
                state_0 = state_0 | 0b10 /* add SpecializationActive[SLBytecodeRootNode.SLInvoke.doIndirect(SLFunction, Object[], IndirectCallNode)] */;
                this.state_0_ = state_0;
                return SLInvoke.doIndirect(child0Value_, child1Value, this.indirect_callNode_);
            }
            {
                Node location__ = null;
                InteropLibrary library__ = this.insert((INTEROP_LIBRARY_.createDispatched(3)));
                Objects.requireNonNull(library__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                VarHandle.storeStoreFence();
                this.interop_library_ = library__;
                location__ = (this);
                state_0 = state_0 | 0b100 /* add SpecializationActive[SLBytecodeRootNode.SLInvoke.doInterop(Object, Object[], InteropLibrary, Node)] */;
                this.state_0_ = state_0;
                return SLInvoke.doInterop(child0Value, child1Value, library__, location__);
            }
        }

        void removeDirect_(DirectData s0_) {
            while (true) {
                DirectData cur = this.direct_cache;
                DirectData original = cur;
                DirectData update = null;
                while (cur != null) {
                    if (cur == s0_) {
                        if (cur == original) {
                            update = cur.next_;
                        } else {
                            update = original.remove(this, s0_);
                        }
                        break;
                    }
                    cur = cur.next_;
                }
                if (cur != null && !DIRECT_CACHE_UPDATER.compareAndSet(this, original, update)) {
                    continue;
                }
                break;
            }
        }

        @GeneratedBy(SLBytecodeRootNode.class)
        @DenyReplace
        private static final class DirectData extends Node implements SpecializationDataNode {

            @Child DirectData next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLInvoke#doDirect}
             *   Parameter: {@link Assumption} callTargetStable</pre> */
            @CompilationFinal Assumption callTargetStable_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLInvoke#doDirect}
             *   Parameter: {@link RootCallTarget} cachedTarget</pre> */
            @CompilationFinal RootCallTarget cachedTarget_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLInvoke#doDirect}
             *   Parameter: {@link DirectCallNode} callNode</pre> */
            @Child DirectCallNode callNode_;

            DirectData(DirectData next_) {
                this.next_ = next_;
            }

            DirectData remove(Node parent, DirectData search) {
                DirectData newNext = this.next_;
                if (newNext != null) {
                    if (search == newNext) {
                        newNext = newNext.next_;
                    } else {
                        newNext = newNext.remove(this, search);
                    }
                }
                DirectData copy = parent.insert(new DirectData(newNext));
                copy.callTargetStable_ = this.callTargetStable_;
                copy.cachedTarget_ = this.cachedTarget_;
                copy.callNode_ = copy.insert(this.callNode_);
                return copy;
            }

        }
        @GeneratedBy(SLBytecodeRootNode.class)
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object[] child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof SLFunction) {
                    SLFunction child0Value_ = (SLFunction) child0Value;
                    return SLInvoke.doIndirect(child0Value_, child1Value, (IndirectCallNode.getUncached()));
                }
                return SLInvoke.doInterop(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached()), ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLAddNode#doLong}
     *     Activation probability: 0.27381
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLAddNode#doSLBigInteger}
     *     Activation probability: 0.23095
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLAddNode#doInteropBigInteger}
     *     Activation probability: 0.18810
     *     With/without class size: 9/8 bytes
     *   Specialization {@link SLAddNode#doInteropBigInteger}
     *     Activation probability: 0.14524
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLAddNode#doString}
     *     Activation probability: 0.10238
     *     With/without class size: 8/31 bytes
     *   Specialization {@link SLAddNode#typeError}
     *     Activation probability: 0.05952
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLAdd_Node extends Node {

        private static final StateField STRING_SL_ADD_NODE_STRING_STATE_0_UPDATER = StateField.create(StringData.lookup_(), "string_state_0_");
        static final ReferenceField<InteropBigInteger0Data> INTEROP_BIG_INTEGER0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interopBigInteger0_cache", InteropBigInteger0Data.class);
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLAddNode#doString}
         *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeLeft
         *   Inline method: {@link SLToTruffleStringNodeGen#inline}</pre> */
        private static final SLToTruffleStringNode INLINED_STRING_TO_TRUFFLE_STRING_NODE_LEFT_ = SLToTruffleStringNodeGen.inline(InlineTarget.create(SLToTruffleStringNode.class, STRING_SL_ADD_NODE_STRING_STATE_0_UPDATER.subUpdater(0, 11), ReferenceField.create(StringData.lookup_(), "string_toTruffleStringNodeLeft__field1_", Node.class), ReferenceField.create(StringData.lookup_(), "string_toTruffleStringNodeLeft__field2_", Node.class), ReferenceField.create(StringData.lookup_(), "string_toTruffleStringNodeLeft__field3_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLAddNode#doString}
         *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeRight
         *   Inline method: {@link SLToTruffleStringNodeGen#inline}</pre> */
        private static final SLToTruffleStringNode INLINED_STRING_TO_TRUFFLE_STRING_NODE_RIGHT_ = SLToTruffleStringNodeGen.inline(InlineTarget.create(SLToTruffleStringNode.class, STRING_SL_ADD_NODE_STRING_STATE_0_UPDATER.subUpdater(11, 11), ReferenceField.create(StringData.lookup_(), "string_toTruffleStringNodeRight__field1_", Node.class), ReferenceField.create(StringData.lookup_(), "string_toTruffleStringNodeRight__field2_", Node.class), ReferenceField.create(StringData.lookup_(), "string_toTruffleStringNodeRight__field3_", Node.class)));
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLAddNode#doLong}
         *   1: SpecializationExcluded {@link SLAddNode#doLong}
         *   2: SpecializationActive {@link SLAddNode#doSLBigInteger}
         *   3: SpecializationActive {@link SLAddNode#doInteropBigInteger}
         *   4: SpecializationActive {@link SLAddNode#doInteropBigInteger}
         *   5: SpecializationActive {@link SLAddNode#doString}
         *   6: SpecializationActive {@link SLAddNode#typeError}
         *   7-8: ImplicitCast[type=SLBigInteger, index=0]
         *   9-10: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private InteropBigInteger0Data interopBigInteger0_cache;
        @Child private StringData string_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b1111101) != 0 /* is SpecializationActive[SLAddNode.doLong(long, long)] || SpecializationActive[SLAddNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLAddNode.doString(Object, Object, Node, SLToTruffleStringNode, SLToTruffleStringNode, ConcatNode)] || SpecializationActive[SLAddNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLAddNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        try {
                            return SLAddNode.doLong(child0Value__, child1Value__);
                        } catch (ArithmeticException ex) {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            state_0 = this.state_0_;
                            state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLAddNode.doLong(long, long)] */;
                            state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                            this.state_0_ = state_0;
                            return executeAndSpecialize(child0Value__, child1Value__, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLAddNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLAddNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b1111000) != 0 /* is SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLAddNode.doString(Object, Object, Node, SLToTruffleStringNode, SLToTruffleStringNode, ConcatNode)] || SpecializationActive[SLAddNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLAddNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLAddNode.doString(Object, Object, Node, SLToTruffleStringNode, SLToTruffleStringNode, ConcatNode)] */) {
                        StringData s4_ = this.string_cache;
                        if (s4_ != null) {
                            if ((SLAddNode.isString(child0Value_, child1Value_))) {
                                Node node__ = (s4_);
                                return SLAddNode.doString(child0Value_, child1Value_, node__, INLINED_STRING_TO_TRUFFLE_STRING_NODE_LEFT_, INLINED_STRING_TO_TRUFFLE_STRING_NODE_RIGHT_, s4_.concatNode_);
                            }
                        }
                    }
                    if ((state_0 & 0b1000000) != 0 /* is SpecializationActive[SLAddNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__1 = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLAddNode.typeError(child0Value_, child1Value_, node__1);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private long executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLAddNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLAddNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        private long executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLAddNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLAddNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b10000) != 0 /* is SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child1Value))) {
                return false;
            }
            if (!((state_0 & 0b100000) != 0 /* is SpecializationActive[SLAddNode.doString(Object, Object, Node, SLToTruffleStringNode, SLToTruffleStringNode, ConcatNode)] */) && (SLAddNode.isString(child0Value, child1Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLAddNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLAddNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (((state_0 & 0b11100)) == 0 /* is-not SpecializationActive[SLAddNode.doSLBigInteger(SLBigInteger, SLBigInteger)] && SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */ && ((state_0 & 0b10)) == 0 /* is-not SpecializationExcluded  */ && child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLAddNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    try {
                        return SLAddNode.doLong(child0Value_, child1Value_);
                    } catch (ArithmeticException ex) {
                        CompilerDirectives.transferToInterpreterAndInvalidate();
                        state_0 = this.state_0_;
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLAddNode.doLong(long, long)] */;
                        state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                        this.state_0_ = state_0;
                        return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                    }
                }
            }
            if (((state_0 & 0b11000)) == 0 /* is-not SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLAddNode.doLong(long, long)] */;
                        state_0 = (state_0 | (sLBigIntegerCast0 << 7) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 9) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b100 /* add SpecializationActive[SLAddNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLAddNode.doSLBigInteger(child0Value_, child1Value_);
                    }
                }
            }
            if (((state_0 & 0b10000)) == 0 /* is-not SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count2_ = 0;
                    InteropBigInteger0Data s2_ = INTEROP_BIG_INTEGER0_CACHE_UPDATER.getVolatile(this);
                    InteropBigInteger0Data s2_original = s2_;
                    while (s2_ != null) {
                        if ((s2_.leftLibrary_.accepts(child0Value)) && (s2_.rightLibrary_.accepts(child1Value)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value))) {
                            break;
                        }
                        count2_++;
                        s2_ = s2_.next_;
                    }
                    if (s2_ == null) {
                        {
                            InteropLibrary leftLibrary__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                            // assert (s2_.leftLibrary_.accepts(child0Value));
                            // assert (s2_.rightLibrary_.accepts(child1Value));
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                InteropLibrary rightLibrary__ = this.insert((INTEROP_LIBRARY_.create(child1Value)));
                                if ((rightLibrary__.fitsInBigInteger(child1Value)) && count2_ < (3)) {
                                    s2_ = this.insert(new InteropBigInteger0Data(s2_original));
                                    Objects.requireNonNull(s2_.insert(leftLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.leftLibrary_ = leftLibrary__;
                                    Objects.requireNonNull(s2_.insert(rightLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.rightLibrary_ = rightLibrary__;
                                    if (!INTEROP_BIG_INTEGER0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 & 0xfffffffa /* remove SpecializationActive[SLAddNode.doLong(long, long)], SpecializationActive[SLAddNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                    }
                    if (s2_ != null) {
                        return SLAddNode.doInteropBigInteger(child0Value, child1Value, s2_.leftLibrary_, s2_.rightLibrary_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightLibrary__ = null;
                InteropLibrary leftLibrary__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((rightLibrary__.fitsInBigInteger(child1Value))) {
                                    this.interopBigInteger0_cache = null;
                                    state_0 = state_0 & 0xfffffff2 /* remove SpecializationActive[SLAddNode.doLong(long, long)], SpecializationActive[SLAddNode.doSLBigInteger(SLBigInteger, SLBigInteger)], SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLAddNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                    return SLAddNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
                                }
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__ = null;
                if ((SLAddNode.isString(child0Value, child1Value))) {
                    StringData s4_ = this.insert(new StringData());
                    node__ = (s4_);
                    ConcatNode concatNode__ = s4_.insert((ConcatNode.create()));
                    Objects.requireNonNull(concatNode__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                    s4_.concatNode_ = concatNode__;
                    VarHandle.storeStoreFence();
                    this.string_cache = s4_;
                    state_0 = state_0 | 0b100000 /* add SpecializationActive[SLAddNode.doString(Object, Object, Node, SLToTruffleStringNode, SLToTruffleStringNode, ConcatNode)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLAddNode.doString(child0Value, child1Value, node__, INLINED_STRING_TO_TRUFFLE_STRING_NODE_LEFT_, INLINED_STRING_TO_TRUFFLE_STRING_NODE_RIGHT_, concatNode__);
                }
            }
            {
                Node node__1 = null;
                node__1 = (this);
                state_0 = state_0 | 0b1000000 /* add SpecializationActive[SLAddNode.typeError(Object, Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLAddNode.typeError(child0Value, child1Value, node__1);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLAddNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b1111100) == 0 /* only-active SpecializationActive[SLAddNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningLong(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_ADD$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_ADD$LONG_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                newInstruction = Instructions.SL_ADD_;
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class InteropBigInteger0Data extends Node implements SpecializationDataNode {

            @Child InteropBigInteger0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} leftLibrary</pre> */
            @Child InteropLibrary leftLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} rightLibrary</pre> */
            @Child InteropLibrary rightLibrary_;

            InteropBigInteger0Data(InteropBigInteger0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class StringData extends Node implements SpecializationDataNode {

            /**
             * State Info: <pre>
             *   0-10: InlinedCache
             *        Specialization: {@link SLAddNode#doString}
             *        Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeLeft
             *        Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   11-21: InlinedCache
             *        Specialization: {@link SLAddNode#doString}
             *        Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeRight
             *        Inline method: {@link SLToTruffleStringNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int string_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeLeft
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node string_toTruffleStringNodeLeft__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeLeft
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node string_toTruffleStringNodeLeft__field2_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeLeft
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field3</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node string_toTruffleStringNodeLeft__field3_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeRight
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node string_toTruffleStringNodeRight__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeRight
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node string_toTruffleStringNodeRight__field2_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNodeRight
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field3</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node string_toTruffleStringNodeRight__field3_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLAddNode#doString}
             *   Parameter: {@link ConcatNode} concatNode</pre> */
            @Child ConcatNode concatNode_;

            StringData() {
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached(child1Value)).fitsInBigInteger(child1Value))) {
                    return SLAddNode.doInteropBigInteger(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                if ((SLAddNode.isString(child0Value, child1Value))) {
                    return SLAddNode.doString(child0Value, child1Value, ($bytecode), (SLToTruffleStringNodeGen.getUncached()), (SLToTruffleStringNodeGen.getUncached()), (ConcatNode.getUncached()));
                }
                return SLAddNode.typeError(child0Value, child1Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLDivNode#doLong}
     *     Activation probability: 0.32000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLDivNode#doSLBigInteger}
     *     Activation probability: 0.26000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLDivNode#doInteropBigInteger}
     *     Activation probability: 0.20000
     *     With/without class size: 9/8 bytes
     *   Specialization {@link SLDivNode#doInteropBigInteger}
     *     Activation probability: 0.14000
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLDivNode#typeError}
     *     Activation probability: 0.08000
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLDiv_Node extends Node {

        static final ReferenceField<InteropBigInteger0Data> INTEROP_BIG_INTEGER0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interopBigInteger0_cache", InteropBigInteger0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLDivNode#doLong}
         *   1: SpecializationExcluded {@link SLDivNode#doLong}
         *   2: SpecializationActive {@link SLDivNode#doSLBigInteger}
         *   3: SpecializationActive {@link SLDivNode#doInteropBigInteger}
         *   4: SpecializationActive {@link SLDivNode#doInteropBigInteger}
         *   5: SpecializationActive {@link SLDivNode#typeError}
         *   6-7: ImplicitCast[type=SLBigInteger, index=0]
         *   8-9: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private InteropBigInteger0Data interopBigInteger0_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b111101) != 0 /* is SpecializationActive[SLDivNode.doLong(long, long)] || SpecializationActive[SLDivNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLDivNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLDivNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        try {
                            return SLDivNode.doLong(child0Value__, child1Value__);
                        } catch (ArithmeticException ex) {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            state_0 = this.state_0_;
                            state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLDivNode.doLong(long, long)] */;
                            state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                            this.state_0_ = state_0;
                            return executeAndSpecialize(child0Value__, child1Value__, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLDivNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000) >>> 6 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000) >>> 6 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000000) >>> 8 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000000) >>> 8 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLDivNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b111000) != 0 /* is SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLDivNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLDivNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLDivNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__ = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLDivNode.typeError(child0Value_, child1Value_, node__);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private long executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLDivNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLDivNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        private long executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLDivNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLDivNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b10000) != 0 /* is SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child1Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLDivNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLDivNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (((state_0 & 0b11100)) == 0 /* is-not SpecializationActive[SLDivNode.doSLBigInteger(SLBigInteger, SLBigInteger)] && SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */ && ((state_0 & 0b10)) == 0 /* is-not SpecializationExcluded  */ && child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLDivNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    try {
                        return SLDivNode.doLong(child0Value_, child1Value_);
                    } catch (ArithmeticException ex) {
                        CompilerDirectives.transferToInterpreterAndInvalidate();
                        state_0 = this.state_0_;
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLDivNode.doLong(long, long)] */;
                        state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                        this.state_0_ = state_0;
                        return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                    }
                }
            }
            if (((state_0 & 0b11000)) == 0 /* is-not SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLDivNode.doLong(long, long)] */;
                        state_0 = (state_0 | (sLBigIntegerCast0 << 6) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 8) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b100 /* add SpecializationActive[SLDivNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLDivNode.doSLBigInteger(child0Value_, child1Value_);
                    }
                }
            }
            if (((state_0 & 0b10000)) == 0 /* is-not SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count2_ = 0;
                    InteropBigInteger0Data s2_ = INTEROP_BIG_INTEGER0_CACHE_UPDATER.getVolatile(this);
                    InteropBigInteger0Data s2_original = s2_;
                    while (s2_ != null) {
                        if ((s2_.leftLibrary_.accepts(child0Value)) && (s2_.rightLibrary_.accepts(child1Value)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value))) {
                            break;
                        }
                        count2_++;
                        s2_ = s2_.next_;
                    }
                    if (s2_ == null) {
                        {
                            InteropLibrary leftLibrary__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                            // assert (s2_.leftLibrary_.accepts(child0Value));
                            // assert (s2_.rightLibrary_.accepts(child1Value));
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                InteropLibrary rightLibrary__ = this.insert((INTEROP_LIBRARY_.create(child1Value)));
                                if ((rightLibrary__.fitsInBigInteger(child1Value)) && count2_ < (3)) {
                                    s2_ = this.insert(new InteropBigInteger0Data(s2_original));
                                    Objects.requireNonNull(s2_.insert(leftLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.leftLibrary_ = leftLibrary__;
                                    Objects.requireNonNull(s2_.insert(rightLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.rightLibrary_ = rightLibrary__;
                                    if (!INTEROP_BIG_INTEGER0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 & 0xfffffffa /* remove SpecializationActive[SLDivNode.doLong(long, long)], SpecializationActive[SLDivNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                    }
                    if (s2_ != null) {
                        return SLDivNode.doInteropBigInteger(child0Value, child1Value, s2_.leftLibrary_, s2_.rightLibrary_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightLibrary__ = null;
                InteropLibrary leftLibrary__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((rightLibrary__.fitsInBigInteger(child1Value))) {
                                    this.interopBigInteger0_cache = null;
                                    state_0 = state_0 & 0xfffffff2 /* remove SpecializationActive[SLDivNode.doLong(long, long)], SpecializationActive[SLDivNode.doSLBigInteger(SLBigInteger, SLBigInteger)], SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLDivNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                    return SLDivNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
                                }
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__ = null;
                node__ = (this);
                state_0 = state_0 | 0b100000 /* add SpecializationActive[SLDivNode.typeError(Object, Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLDivNode.typeError(child0Value, child1Value, node__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLDivNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b111100) == 0 /* only-active SpecializationActive[SLDivNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningLong(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_DIV$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_DIV$LONG_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                newInstruction = Instructions.SL_DIV_;
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class InteropBigInteger0Data extends Node implements SpecializationDataNode {

            @Child InteropBigInteger0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLDivNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} leftLibrary</pre> */
            @Child InteropLibrary leftLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLDivNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} rightLibrary</pre> */
            @Child InteropLibrary rightLibrary_;

            InteropBigInteger0Data(InteropBigInteger0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached(child1Value)).fitsInBigInteger(child1Value))) {
                    return SLDivNode.doInteropBigInteger(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                return SLDivNode.typeError(child0Value, child1Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLEqualNode#doLong}
     *     Activation probability: 0.19111
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLEqualNode#doBigNumber}
     *     Activation probability: 0.17111
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLEqualNode#doBoolean}
     *     Activation probability: 0.15111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLEqualNode#doString}
     *     Activation probability: 0.13111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLEqualNode#doTruffleString}
     *     Activation probability: 0.11111
     *     With/without class size: 6/4 bytes
     *   Specialization {@link SLEqualNode#doNull}
     *     Activation probability: 0.09111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLEqualNode#doFunction}
     *     Activation probability: 0.07111
     *     With/without class size: 4/0 bytes
     *   Specialization {@link SLEqualNode#doGeneric}
     *     Activation probability: 0.05111
     *     With/without class size: 5/8 bytes
     *   Specialization {@link SLEqualNode#doGeneric}
     *     Activation probability: 0.03111
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLEqual_Node extends Node {

        static final ReferenceField<Generic0Data> GENERIC0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "generic0_cache", Generic0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLEqualNode#doLong}
         *   1: SpecializationActive {@link SLEqualNode#doBigNumber}
         *   2: SpecializationActive {@link SLEqualNode#doBoolean}
         *   3: SpecializationActive {@link SLEqualNode#doString}
         *   4: SpecializationActive {@link SLEqualNode#doTruffleString}
         *   5: SpecializationActive {@link SLEqualNode#doNull}
         *   6: SpecializationActive {@link SLEqualNode#doFunction}
         *   7: SpecializationActive {@link SLEqualNode#doGeneric}
         *   8: SpecializationActive {@link SLEqualNode#doGeneric}
         *   9-10: ImplicitCast[type=SLBigInteger, index=0]
         *   11-12: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLEqualNode#doTruffleString}
         *   Parameter: {@link EqualNode} equalNode</pre> */
        @Child private EqualNode truffleString_equalNode_;
        @UnsafeAccessedField @Child private Generic0Data generic0_cache;

        @ExplodeLoop
        private boolean execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b111111111) != 0 /* is SpecializationActive[SLEqualNode.doLong(long, long)] || SpecializationActive[SLEqualNode.doBigNumber(SLBigInteger, SLBigInteger)] || SpecializationActive[SLEqualNode.doBoolean(boolean, boolean)] || SpecializationActive[SLEqualNode.doString(String, String)] || SpecializationActive[SLEqualNode.doTruffleString(TruffleString, TruffleString, EqualNode)] || SpecializationActive[SLEqualNode.doNull(SLNull, SLNull)] || SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLEqualNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        return SLEqualNode.doLong(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLEqualNode.doBigNumber(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000000000) >>> 11 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000000000) >>> 11 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLEqualNode.doBigNumber(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLEqualNode.doBoolean(boolean, boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    if (child1Value_ instanceof Boolean) {
                        boolean child1Value__ = (boolean) child1Value_;
                        return SLEqualNode.doBoolean(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLEqualNode.doString(String, String)] */ && child0Value_ instanceof String) {
                    String child0Value__ = (String) child0Value_;
                    if (child1Value_ instanceof String) {
                        String child1Value__ = (String) child1Value_;
                        return SLEqualNode.doString(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLEqualNode.doTruffleString(TruffleString, TruffleString, EqualNode)] */ && child0Value_ instanceof TruffleString) {
                    TruffleString child0Value__ = (TruffleString) child0Value_;
                    if (child1Value_ instanceof TruffleString) {
                        TruffleString child1Value__ = (TruffleString) child1Value_;
                        {
                            EqualNode equalNode__ = this.truffleString_equalNode_;
                            if (equalNode__ != null) {
                                return SLEqualNode.doTruffleString(child0Value__, child1Value__, equalNode__);
                            }
                        }
                    }
                }
                if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLEqualNode.doNull(SLNull, SLNull)] */ && SLTypes.isSLNull(child0Value_)) {
                    SLNull child0Value__ = SLTypes.asSLNull(child0Value_);
                    if (SLTypes.isSLNull(child1Value_)) {
                        SLNull child1Value__ = SLTypes.asSLNull(child1Value_);
                        return SLEqualNode.doNull(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b111000000) != 0 /* is SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                    if ((state_0 & 0b1000000) != 0 /* is SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] */ && child0Value_ instanceof SLFunction) {
                        SLFunction child0Value__ = (SLFunction) child0Value_;
                        return SLEqualNode.doFunction(child0Value__, child1Value_);
                    }
                    if ((state_0 & 0b110000000) != 0 /* is SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        if ((state_0 & 0b10000000) != 0 /* is SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                            Generic0Data s7_ = this.generic0_cache;
                            while (s7_ != null) {
                                if ((s7_.leftInterop_.accepts(child0Value_)) && (s7_.rightInterop_.accepts(child1Value_))) {
                                    return SLEqualNode.doGeneric(child0Value_, child1Value_, s7_.leftInterop_, s7_.rightInterop_);
                                }
                                s7_ = s7_.next_;
                            }
                        }
                        if ((state_0 & 0b100000000) != 0 /* is SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                            return this.generic1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private boolean executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLEqualNode.doLong(child0Value_, child1Value_);
        }

        private boolean executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLEqualNode.doLong(child0Value_, child1Value_);
        }

        private boolean executeBoolean(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            boolean child1Value_;
            try {
                child1Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLEqualNode.doBoolean(child0Value_, child1Value_);
        }

        private boolean executeBoolean$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            boolean child1Value_;
            try {
                child1Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLEqualNode.doBoolean(child0Value_, child1Value_);
        }

        @ExplodeLoop
        private boolean executeunboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b111111111) != 0 /* is SpecializationActive[SLEqualNode.doLong(long, long)] || SpecializationActive[SLEqualNode.doBigNumber(SLBigInteger, SLBigInteger)] || SpecializationActive[SLEqualNode.doBoolean(boolean, boolean)] || SpecializationActive[SLEqualNode.doString(String, String)] || SpecializationActive[SLEqualNode.doTruffleString(TruffleString, TruffleString, EqualNode)] || SpecializationActive[SLEqualNode.doNull(SLNull, SLNull)] || SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLEqualNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        return SLEqualNode.doLong(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLEqualNode.doBigNumber(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000000000) >>> 11 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000000000) >>> 11 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLEqualNode.doBigNumber(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLEqualNode.doBoolean(boolean, boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    if (child1Value_ instanceof Boolean) {
                        boolean child1Value__ = (boolean) child1Value_;
                        return SLEqualNode.doBoolean(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLEqualNode.doString(String, String)] */ && child0Value_ instanceof String) {
                    String child0Value__ = (String) child0Value_;
                    if (child1Value_ instanceof String) {
                        String child1Value__ = (String) child1Value_;
                        return SLEqualNode.doString(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLEqualNode.doTruffleString(TruffleString, TruffleString, EqualNode)] */ && child0Value_ instanceof TruffleString) {
                    TruffleString child0Value__ = (TruffleString) child0Value_;
                    if (child1Value_ instanceof TruffleString) {
                        TruffleString child1Value__ = (TruffleString) child1Value_;
                        {
                            EqualNode equalNode__ = this.truffleString_equalNode_;
                            if (equalNode__ != null) {
                                return SLEqualNode.doTruffleString(child0Value__, child1Value__, equalNode__);
                            }
                        }
                    }
                }
                if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLEqualNode.doNull(SLNull, SLNull)] */ && SLTypes.isSLNull(child0Value_)) {
                    SLNull child0Value__ = SLTypes.asSLNull(child0Value_);
                    if (SLTypes.isSLNull(child1Value_)) {
                        SLNull child1Value__ = SLTypes.asSLNull(child1Value_);
                        return SLEqualNode.doNull(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b111000000) != 0 /* is SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                    if ((state_0 & 0b1000000) != 0 /* is SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] */ && child0Value_ instanceof SLFunction) {
                        SLFunction child0Value__ = (SLFunction) child0Value_;
                        return SLEqualNode.doFunction(child0Value__, child1Value_);
                    }
                    if ((state_0 & 0b110000000) != 0 /* is SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        if ((state_0 & 0b10000000) != 0 /* is SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                            Generic0Data s7_ = this.generic0_cache;
                            while (s7_ != null) {
                                if ((s7_.leftInterop_.accepts(child0Value_)) && (s7_.rightInterop_.accepts(child1Value_))) {
                                    return SLEqualNode.doGeneric(child0Value_, child1Value_, s7_.leftInterop_, s7_.rightInterop_);
                                }
                                s7_ = s7_.next_;
                            }
                        }
                        if ((state_0 & 0b100000000) != 0 /* is SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                            return this.generic1Boundary2(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean generic1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary leftInterop__ = (INTEROP_LIBRARY_.getUncached(child0Value));
                    InteropLibrary rightInterop__ = (INTEROP_LIBRARY_.getUncached(child1Value));
                    return SLEqualNode.doGeneric(child0Value, child1Value, leftInterop__, rightInterop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean generic1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary leftInterop__ = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    InteropLibrary rightInterop__ = (INTEROP_LIBRARY_.getUncached(child1Value_));
                    return SLEqualNode.doGeneric(child0Value_, child1Value_, leftInterop__, rightInterop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        private boolean executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLEqualNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLEqualNode.doLong(child0Value_, child1Value_);
                }
            }
            {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = (state_0 | (sLBigIntegerCast0 << 9) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 11) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b10 /* add SpecializationActive[SLEqualNode.doBigNumber(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLEqualNode.doBigNumber(child0Value_, child1Value_);
                    }
                }
            }
            if (child0Value instanceof Boolean) {
                boolean child0Value_ = (boolean) child0Value;
                if (child1Value instanceof Boolean) {
                    boolean child1Value_ = (boolean) child1Value;
                    state_0 = state_0 | 0b100 /* add SpecializationActive[SLEqualNode.doBoolean(boolean, boolean)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLEqualNode.doBoolean(child0Value_, child1Value_);
                }
            }
            if (child0Value instanceof String) {
                String child0Value_ = (String) child0Value;
                if (child1Value instanceof String) {
                    String child1Value_ = (String) child1Value;
                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLEqualNode.doString(String, String)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLEqualNode.doString(child0Value_, child1Value_);
                }
            }
            if (child0Value instanceof TruffleString) {
                TruffleString child0Value_ = (TruffleString) child0Value;
                if (child1Value instanceof TruffleString) {
                    TruffleString child1Value_ = (TruffleString) child1Value;
                    EqualNode equalNode__ = this.insert((EqualNode.create()));
                    Objects.requireNonNull(equalNode__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                    VarHandle.storeStoreFence();
                    this.truffleString_equalNode_ = equalNode__;
                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLEqualNode.doTruffleString(TruffleString, TruffleString, EqualNode)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLEqualNode.doTruffleString(child0Value_, child1Value_, equalNode__);
                }
            }
            if (SLTypes.isSLNull(child0Value)) {
                SLNull child0Value_ = SLTypes.asSLNull(child0Value);
                if (SLTypes.isSLNull(child1Value)) {
                    SLNull child1Value_ = SLTypes.asSLNull(child1Value);
                    state_0 = state_0 | 0b100000 /* add SpecializationActive[SLEqualNode.doNull(SLNull, SLNull)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLEqualNode.doNull(child0Value_, child1Value_);
                }
            }
            if (child0Value instanceof SLFunction) {
                SLFunction child0Value_ = (SLFunction) child0Value;
                state_0 = state_0 | 0b1000000 /* add SpecializationActive[SLEqualNode.doFunction(SLFunction, Object)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLEqualNode.doFunction(child0Value_, child1Value);
            }
            if (((state_0 & 0b100000000)) == 0 /* is-not SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count7_ = 0;
                    Generic0Data s7_ = GENERIC0_CACHE_UPDATER.getVolatile(this);
                    Generic0Data s7_original = s7_;
                    while (s7_ != null) {
                        if ((s7_.leftInterop_.accepts(child0Value)) && (s7_.rightInterop_.accepts(child1Value))) {
                            break;
                        }
                        count7_++;
                        s7_ = s7_.next_;
                    }
                    if (s7_ == null) {
                        // assert (s7_.leftInterop_.accepts(child0Value));
                        // assert (s7_.rightInterop_.accepts(child1Value));
                        if (count7_ < (4)) {
                            s7_ = this.insert(new Generic0Data(s7_original));
                            InteropLibrary leftInterop__ = s7_.insert((INTEROP_LIBRARY_.create(child0Value)));
                            Objects.requireNonNull(leftInterop__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                            s7_.leftInterop_ = leftInterop__;
                            InteropLibrary rightInterop__ = s7_.insert((INTEROP_LIBRARY_.create(child1Value)));
                            Objects.requireNonNull(rightInterop__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                            s7_.rightInterop_ = rightInterop__;
                            if (!GENERIC0_CACHE_UPDATER.compareAndSet(this, s7_original, s7_)) {
                                continue;
                            }
                            state_0 = state_0 | 0b10000000 /* add SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */;
                            this.state_0_ = state_0;
                            quicken(state_0, $bc, $bci);
                        }
                    }
                    if (s7_ != null) {
                        return SLEqualNode.doGeneric(child0Value, child1Value, s7_.leftInterop_, s7_.rightInterop_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightInterop__ = null;
                InteropLibrary leftInterop__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        leftInterop__ = (INTEROP_LIBRARY_.getUncached(child0Value));
                        rightInterop__ = (INTEROP_LIBRARY_.getUncached(child1Value));
                        this.generic0_cache = null;
                        state_0 = state_0 & 0xffffff7f /* remove SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */;
                        state_0 = state_0 | 0b100000000 /* add SpecializationActive[SLEqualNode.doGeneric(Object, Object, InteropLibrary, InteropLibrary)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLEqualNode.doGeneric(child0Value, child1Value, leftInterop__, rightInterop__);
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean generic1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary leftInterop__ = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    InteropLibrary rightInterop__ = (INTEROP_LIBRARY_.getUncached(child1Value_));
                    return SLEqualNode.doGeneric(child0Value_, child1Value_, leftInterop__, rightInterop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean generic1Boundary2(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary leftInterop__ = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    InteropLibrary rightInterop__ = (INTEROP_LIBRARY_.getUncached(child1Value_));
                    return SLEqualNode.doGeneric(child0Value_, child1Value_, leftInterop__, rightInterop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b111111110) == 0 /* only-active SpecializationActive[SLEqualNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_EQUAL$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_EQUAL$LONG_;
                }
            } else if ((state_0 & 0b111111011) == 0 /* only-active SpecializationActive[SLEqualNode.doBoolean(boolean, boolean)] */
               && (newOperand0 = applyQuickeningBoolean(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningBoolean(oldOperand1)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_EQUAL$BOOLEAN$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_EQUAL$BOOLEAN_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_EQUAL$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_EQUAL_;
                }
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class Generic0Data extends Node implements SpecializationDataNode {

            @Child Generic0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLEqualNode#doGeneric}
             *   Parameter: {@link InteropLibrary} leftInterop</pre> */
            @Child InteropLibrary leftInterop_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLEqualNode#doGeneric}
             *   Parameter: {@link InteropLibrary} rightInterop</pre> */
            @Child InteropLibrary rightInterop_;

            Generic0Data(Generic0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public boolean executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof Long) {
                    long child0Value_ = (long) child0Value;
                    if (child1Value instanceof Long) {
                        long child1Value_ = (long) child1Value;
                        return SLEqualNode.doLong(child0Value_, child1Value_);
                    }
                }
                if (SLTypesGen.isImplicitSLBigInteger(child0Value)) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(child0Value);
                    if (SLTypesGen.isImplicitSLBigInteger(child1Value)) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(child1Value);
                        return SLEqualNode.doBigNumber(child0Value_, child1Value_);
                    }
                }
                if (child0Value instanceof Boolean) {
                    boolean child0Value_ = (boolean) child0Value;
                    if (child1Value instanceof Boolean) {
                        boolean child1Value_ = (boolean) child1Value;
                        return SLEqualNode.doBoolean(child0Value_, child1Value_);
                    }
                }
                if (child0Value instanceof String) {
                    String child0Value_ = (String) child0Value;
                    if (child1Value instanceof String) {
                        String child1Value_ = (String) child1Value;
                        return SLEqualNode.doString(child0Value_, child1Value_);
                    }
                }
                if (child0Value instanceof TruffleString) {
                    TruffleString child0Value_ = (TruffleString) child0Value;
                    if (child1Value instanceof TruffleString) {
                        TruffleString child1Value_ = (TruffleString) child1Value;
                        return SLEqualNode.doTruffleString(child0Value_, child1Value_, (EqualNode.getUncached()));
                    }
                }
                if (SLTypes.isSLNull(child0Value)) {
                    SLNull child0Value_ = SLTypes.asSLNull(child0Value);
                    if (SLTypes.isSLNull(child1Value)) {
                        SLNull child1Value_ = SLTypes.asSLNull(child1Value);
                        return SLEqualNode.doNull(child0Value_, child1Value_);
                    }
                }
                if (child0Value instanceof SLFunction) {
                    SLFunction child0Value_ = (SLFunction) child0Value;
                    return SLEqualNode.doFunction(child0Value_, child1Value);
                }
                return SLEqualNode.doGeneric(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLLessOrEqualNode#doLong}
     *     Activation probability: 0.32000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLLessOrEqualNode#doSLBigInteger}
     *     Activation probability: 0.26000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLLessOrEqualNode#doInteropBigInteger}
     *     Activation probability: 0.20000
     *     With/without class size: 9/8 bytes
     *   Specialization {@link SLLessOrEqualNode#doInteropBigInteger}
     *     Activation probability: 0.14000
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLLessOrEqualNode#typeError}
     *     Activation probability: 0.08000
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLLessOrEqual_Node extends Node {

        static final ReferenceField<InteropBigInteger0Data> INTEROP_BIG_INTEGER0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interopBigInteger0_cache", InteropBigInteger0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLLessOrEqualNode#doLong}
         *   1: SpecializationActive {@link SLLessOrEqualNode#doSLBigInteger}
         *   2: SpecializationActive {@link SLLessOrEqualNode#doInteropBigInteger}
         *   3: SpecializationActive {@link SLLessOrEqualNode#doInteropBigInteger}
         *   4: SpecializationActive {@link SLLessOrEqualNode#typeError}
         *   5-6: ImplicitCast[type=SLBigInteger, index=0]
         *   7-8: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private InteropBigInteger0Data interopBigInteger0_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b11111) != 0 /* is SpecializationActive[SLLessOrEqualNode.doLong(long, long)] || SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLLessOrEqualNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        return SLLessOrEqualNode.doLong(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLLessOrEqualNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b11100) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLLessOrEqualNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__ = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLLessOrEqualNode.typeError(child0Value_, child1Value_, node__);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private boolean executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectBoolean(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectBoolean(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            return SLLessOrEqualNode.doLong(child0Value_, child1Value_);
        }

        private boolean executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectBoolean(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectBoolean(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            return SLLessOrEqualNode.doLong(child0Value_, child1Value_);
        }

        @ExplodeLoop
        private boolean executeSLBigInteger_InteropBigInteger0_InteropBigInteger1(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectBoolean(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectBoolean(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            if ((state_0 & 0b1110) != 0 /* is SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLLessOrEqualNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b1100) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary2(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return SLTypesGen.expectBoolean(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
        }

        @ExplodeLoop
        private boolean executeSLBigInteger_InteropBigInteger0_InteropBigInteger1$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectBoolean(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectBoolean(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            if ((state_0 & 0b1110) != 0 /* is SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLLessOrEqualNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b1100) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary3(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return SLTypesGen.expectBoolean(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b1) != 0 /* is SpecializationActive[SLLessOrEqualNode.doLong(long, long)] */) && child0Value instanceof Long && child1Value instanceof Long) {
                return false;
            }
            if (!((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child1Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessOrEqualNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLLessOrEqualNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLLessOrEqualNode.doLong(child0Value_, child1Value_);
                }
            }
            if (((state_0 & 0b1100)) == 0 /* is-not SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = (state_0 | (sLBigIntegerCast0 << 5) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 7) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b10 /* add SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLLessOrEqualNode.doSLBigInteger(child0Value_, child1Value_);
                    }
                }
            }
            if (((state_0 & 0b1000)) == 0 /* is-not SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count2_ = 0;
                    InteropBigInteger0Data s2_ = INTEROP_BIG_INTEGER0_CACHE_UPDATER.getVolatile(this);
                    InteropBigInteger0Data s2_original = s2_;
                    while (s2_ != null) {
                        if ((s2_.leftLibrary_.accepts(child0Value)) && (s2_.rightLibrary_.accepts(child1Value)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value))) {
                            break;
                        }
                        count2_++;
                        s2_ = s2_.next_;
                    }
                    if (s2_ == null) {
                        {
                            InteropLibrary leftLibrary__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                            // assert (s2_.leftLibrary_.accepts(child0Value));
                            // assert (s2_.rightLibrary_.accepts(child1Value));
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                InteropLibrary rightLibrary__ = this.insert((INTEROP_LIBRARY_.create(child1Value)));
                                if ((rightLibrary__.fitsInBigInteger(child1Value)) && count2_ < (3)) {
                                    s2_ = this.insert(new InteropBigInteger0Data(s2_original));
                                    Objects.requireNonNull(s2_.insert(leftLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.leftLibrary_ = leftLibrary__;
                                    Objects.requireNonNull(s2_.insert(rightLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.rightLibrary_ = rightLibrary__;
                                    if (!INTEROP_BIG_INTEGER0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 & 0xfffffffd /* remove SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                                    state_0 = state_0 | 0b100 /* add SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                    }
                    if (s2_ != null) {
                        return SLLessOrEqualNode.doInteropBigInteger(child0Value, child1Value, s2_.leftLibrary_, s2_.rightLibrary_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightLibrary__ = null;
                InteropLibrary leftLibrary__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((rightLibrary__.fitsInBigInteger(child1Value))) {
                                    this.interopBigInteger0_cache = null;
                                    state_0 = state_0 & 0xfffffff9 /* remove SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)], SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                    return SLLessOrEqualNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
                                }
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__ = null;
                node__ = (this);
                state_0 = state_0 | 0b10000 /* add SpecializationActive[SLLessOrEqualNode.typeError(Object, Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLLessOrEqualNode.typeError(child0Value, child1Value, node__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interopBigInteger1Boundary2(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interopBigInteger1Boundary3(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessOrEqualNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b11110) == 0 /* only-active SpecializationActive[SLLessOrEqualNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_LESS_OR_EQUAL$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_LESS_OR_EQUAL$LONG_;
                }
            } else if ((state_0 & 0b10001) == 0 /* only-active SpecializationActive[SLLessOrEqualNode.doSLBigInteger(SLBigInteger, SLBigInteger)] && SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLLessOrEqualNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */
               && ((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */ == 0b10)
               && ((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */ == 0b10)) {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_LESS_OR_EQUAL$SL_BIG_INTEGER$INTEROP_BIG_INTEGER0$INTEROP_BIG_INTEGER1_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                newInstruction = Instructions.SL_LESS_OR_EQUAL_;
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class InteropBigInteger0Data extends Node implements SpecializationDataNode {

            @Child InteropBigInteger0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLLessOrEqualNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} leftLibrary</pre> */
            @Child InteropLibrary leftLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLLessOrEqualNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} rightLibrary</pre> */
            @Child InteropLibrary rightLibrary_;

            InteropBigInteger0Data(InteropBigInteger0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof Long) {
                    long child0Value_ = (long) child0Value;
                    if (child1Value instanceof Long) {
                        long child1Value_ = (long) child1Value;
                        return SLLessOrEqualNode.doLong(child0Value_, child1Value_);
                    }
                }
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached(child1Value)).fitsInBigInteger(child1Value))) {
                    return SLLessOrEqualNode.doInteropBigInteger(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                return SLLessOrEqualNode.typeError(child0Value, child1Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLLessThanNode#doLong}
     *     Activation probability: 0.32000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLLessThanNode#doSLBigInteger}
     *     Activation probability: 0.26000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLLessThanNode#doInteropBigInteger}
     *     Activation probability: 0.20000
     *     With/without class size: 9/8 bytes
     *   Specialization {@link SLLessThanNode#doInteropBigInteger}
     *     Activation probability: 0.14000
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLLessThanNode#typeError}
     *     Activation probability: 0.08000
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLLessThan_Node extends Node {

        static final ReferenceField<InteropBigInteger0Data> INTEROP_BIG_INTEGER0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interopBigInteger0_cache", InteropBigInteger0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLLessThanNode#doLong}
         *   1: SpecializationActive {@link SLLessThanNode#doSLBigInteger}
         *   2: SpecializationActive {@link SLLessThanNode#doInteropBigInteger}
         *   3: SpecializationActive {@link SLLessThanNode#doInteropBigInteger}
         *   4: SpecializationActive {@link SLLessThanNode#typeError}
         *   5-6: ImplicitCast[type=SLBigInteger, index=0]
         *   7-8: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private InteropBigInteger0Data interopBigInteger0_cache;

        @ExplodeLoop
        private boolean execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b11111) != 0 /* is SpecializationActive[SLLessThanNode.doLong(long, long)] || SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLLessThanNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        return SLLessThanNode.doLong(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLLessThanNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b11100) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLLessThanNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__ = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLLessThanNode.typeError(child0Value_, child1Value_, node__);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private boolean executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLLessThanNode.doLong(child0Value_, child1Value_);
        }

        private boolean executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLLessThanNode.doLong(child0Value_, child1Value_);
        }

        @ExplodeLoop
        private boolean executeunboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b11111) != 0 /* is SpecializationActive[SLLessThanNode.doLong(long, long)] || SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLLessThanNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        return SLLessThanNode.doLong(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000) >>> 5 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b110000000) >>> 7 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLLessThanNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b11100) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLLessThanNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary2(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__ = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLLessThanNode.typeError(child0Value_, child1Value_, node__);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b1) != 0 /* is SpecializationActive[SLLessThanNode.doLong(long, long)] */) && child0Value instanceof Long && child1Value instanceof Long) {
                return false;
            }
            if (!((state_0 & 0b1000) != 0 /* is SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child1Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interopBigInteger1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessThanNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interopBigInteger1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessThanNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("unused")
        private boolean executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLLessThanNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLLessThanNode.doLong(child0Value_, child1Value_);
                }
            }
            if (((state_0 & 0b1100)) == 0 /* is-not SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = (state_0 | (sLBigIntegerCast0 << 5) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 7) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b10 /* add SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLLessThanNode.doSLBigInteger(child0Value_, child1Value_);
                    }
                }
            }
            if (((state_0 & 0b1000)) == 0 /* is-not SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count2_ = 0;
                    InteropBigInteger0Data s2_ = INTEROP_BIG_INTEGER0_CACHE_UPDATER.getVolatile(this);
                    InteropBigInteger0Data s2_original = s2_;
                    while (s2_ != null) {
                        if ((s2_.leftLibrary_.accepts(child0Value)) && (s2_.rightLibrary_.accepts(child1Value)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value))) {
                            break;
                        }
                        count2_++;
                        s2_ = s2_.next_;
                    }
                    if (s2_ == null) {
                        {
                            InteropLibrary leftLibrary__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                            // assert (s2_.leftLibrary_.accepts(child0Value));
                            // assert (s2_.rightLibrary_.accepts(child1Value));
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                InteropLibrary rightLibrary__ = this.insert((INTEROP_LIBRARY_.create(child1Value)));
                                if ((rightLibrary__.fitsInBigInteger(child1Value)) && count2_ < (3)) {
                                    s2_ = this.insert(new InteropBigInteger0Data(s2_original));
                                    Objects.requireNonNull(s2_.insert(leftLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.leftLibrary_ = leftLibrary__;
                                    Objects.requireNonNull(s2_.insert(rightLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.rightLibrary_ = rightLibrary__;
                                    if (!INTEROP_BIG_INTEGER0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 & 0xfffffffd /* remove SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                                    state_0 = state_0 | 0b100 /* add SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                    }
                    if (s2_ != null) {
                        return SLLessThanNode.doInteropBigInteger(child0Value, child1Value, s2_.leftLibrary_, s2_.rightLibrary_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightLibrary__ = null;
                InteropLibrary leftLibrary__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((rightLibrary__.fitsInBigInteger(child1Value))) {
                                    this.interopBigInteger0_cache = null;
                                    state_0 = state_0 & 0xfffffff9 /* remove SpecializationActive[SLLessThanNode.doSLBigInteger(SLBigInteger, SLBigInteger)], SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLLessThanNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                    return SLLessThanNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
                                }
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__ = null;
                node__ = (this);
                state_0 = state_0 | 0b10000 /* add SpecializationActive[SLLessThanNode.typeError(Object, Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLLessThanNode.typeError(child0Value, child1Value, node__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interopBigInteger1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessThanNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interopBigInteger1Boundary2(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLLessThanNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b11110) == 0 /* only-active SpecializationActive[SLLessThanNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_LESS_THAN$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_LESS_THAN$LONG_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_LESS_THAN$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_LESS_THAN_;
                }
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class InteropBigInteger0Data extends Node implements SpecializationDataNode {

            @Child InteropBigInteger0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLLessThanNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} leftLibrary</pre> */
            @Child InteropLibrary leftLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLLessThanNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} rightLibrary</pre> */
            @Child InteropLibrary rightLibrary_;

            InteropBigInteger0Data(InteropBigInteger0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public boolean executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof Long) {
                    long child0Value_ = (long) child0Value;
                    if (child1Value instanceof Long) {
                        long child1Value_ = (long) child1Value;
                        return SLLessThanNode.doLong(child0Value_, child1Value_);
                    }
                }
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached(child1Value)).fitsInBigInteger(child1Value))) {
                    return SLLessThanNode.doInteropBigInteger(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                return SLLessThanNode.typeError(child0Value, child1Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLLogicalNotNode#doBoolean}
     *     Activation probability: 0.65000
     *     With/without class size: 11/0 bytes
     *   Specialization {@link SLLogicalNotNode#typeError}
     *     Activation probability: 0.35000
     *     With/without class size: 8/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLLogicalNot_Node extends Node {

        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLLogicalNotNode#doBoolean}
         *   1: SpecializationActive {@link SLLogicalNotNode#typeError}
         * </pre> */
        @CompilationFinal private int state_0_;

        private boolean execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if (state_0 != 0 /* is SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] || SpecializationActive[SLLogicalNotNode.typeError(Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    return SLLogicalNotNode.doBoolean(child0Value__);
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLogicalNotNode.typeError(Object, Node)] */) {
                    {
                        Node node__ = (this);
                        if (fallbackGuard_(state_0, child0Value_, $bytecode, $bc, $bci, $sp)) {
                            return SLLogicalNotNode.typeError(child0Value_, node__);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, $bytecode, $bc, $bci, $sp);
        }

        private boolean executeBoolean(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLLogicalNotNode.doBoolean(child0Value_);
        }

        private boolean executeBoolean$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLLogicalNotNode.doBoolean(child0Value_);
        }

        private boolean executeunboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if (state_0 != 0 /* is SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] || SpecializationActive[SLLogicalNotNode.typeError(Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    return SLLogicalNotNode.doBoolean(child0Value__);
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLLogicalNotNode.typeError(Object, Node)] */) {
                    {
                        Node node__ = (this);
                        if (fallbackGuard_(state_0, child0Value_, $bytecode, $bc, $bci, $sp)) {
                            return SLLogicalNotNode.typeError(child0Value_, node__);
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b1) != 0 /* is SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] */) && child0Value instanceof Boolean) {
                return false;
            }
            return true;
        }

        private boolean executeAndSpecialize(Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof Boolean) {
                boolean child0Value_ = (boolean) child0Value;
                state_0 = state_0 | 0b1 /* add SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLLogicalNotNode.doBoolean(child0Value_);
            }
            {
                Node node__ = null;
                node__ = (this);
                state_0 = state_0 | 0b10 /* add SpecializationActive[SLLogicalNotNode.typeError(Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLLogicalNotNode.typeError(child0Value, node__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            if ((state_0 & 0b10) == 0 /* only-active SpecializationActive[SLLogicalNotNode.doBoolean(boolean)] */
               && (newOperand0 = applyQuickeningBoolean(oldOperand0)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_LOGICAL_NOT$BOOLEAN$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_LOGICAL_NOT$BOOLEAN_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_LOGICAL_NOT$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_LOGICAL_NOT_;
                }
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public boolean executeUncached(VirtualFrame frameValue, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof Boolean) {
                    boolean child0Value_ = (boolean) child0Value;
                    return SLLogicalNotNode.doBoolean(child0Value_);
                }
                return SLLogicalNotNode.typeError(child0Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLMulNode#doLong}
     *     Activation probability: 0.32000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLMulNode#doSLBigInteger}
     *     Activation probability: 0.26000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLMulNode#doInteropBigInteger}
     *     Activation probability: 0.20000
     *     With/without class size: 9/8 bytes
     *   Specialization {@link SLMulNode#doInteropBigInteger}
     *     Activation probability: 0.14000
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLMulNode#typeError}
     *     Activation probability: 0.08000
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLMul_Node extends Node {

        static final ReferenceField<InteropBigInteger0Data> INTEROP_BIG_INTEGER0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interopBigInteger0_cache", InteropBigInteger0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLMulNode#doLong}
         *   1: SpecializationExcluded {@link SLMulNode#doLong}
         *   2: SpecializationActive {@link SLMulNode#doSLBigInteger}
         *   3: SpecializationActive {@link SLMulNode#doInteropBigInteger}
         *   4: SpecializationActive {@link SLMulNode#doInteropBigInteger}
         *   5: SpecializationActive {@link SLMulNode#typeError}
         *   6-7: ImplicitCast[type=SLBigInteger, index=0]
         *   8-9: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private InteropBigInteger0Data interopBigInteger0_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b111101) != 0 /* is SpecializationActive[SLMulNode.doLong(long, long)] || SpecializationActive[SLMulNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLMulNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLMulNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        try {
                            return SLMulNode.doLong(child0Value__, child1Value__);
                        } catch (ArithmeticException ex) {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            state_0 = this.state_0_;
                            state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLMulNode.doLong(long, long)] */;
                            state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                            this.state_0_ = state_0;
                            return executeAndSpecialize(child0Value__, child1Value__, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLMulNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000) >>> 6 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000) >>> 6 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000000) >>> 8 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000000) >>> 8 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLMulNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b111000) != 0 /* is SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLMulNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLMulNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLMulNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__ = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLMulNode.typeError(child0Value_, child1Value_, node__);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private long executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLMulNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLMulNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        private long executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLMulNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLMulNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b10000) != 0 /* is SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child1Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLMulNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLMulNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (((state_0 & 0b11100)) == 0 /* is-not SpecializationActive[SLMulNode.doSLBigInteger(SLBigInteger, SLBigInteger)] && SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */ && ((state_0 & 0b10)) == 0 /* is-not SpecializationExcluded  */ && child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLMulNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    try {
                        return SLMulNode.doLong(child0Value_, child1Value_);
                    } catch (ArithmeticException ex) {
                        CompilerDirectives.transferToInterpreterAndInvalidate();
                        state_0 = this.state_0_;
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLMulNode.doLong(long, long)] */;
                        state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                        this.state_0_ = state_0;
                        return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                    }
                }
            }
            if (((state_0 & 0b11000)) == 0 /* is-not SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLMulNode.doLong(long, long)] */;
                        state_0 = (state_0 | (sLBigIntegerCast0 << 6) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 8) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b100 /* add SpecializationActive[SLMulNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLMulNode.doSLBigInteger(child0Value_, child1Value_);
                    }
                }
            }
            if (((state_0 & 0b10000)) == 0 /* is-not SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count2_ = 0;
                    InteropBigInteger0Data s2_ = INTEROP_BIG_INTEGER0_CACHE_UPDATER.getVolatile(this);
                    InteropBigInteger0Data s2_original = s2_;
                    while (s2_ != null) {
                        if ((s2_.leftLibrary_.accepts(child0Value)) && (s2_.rightLibrary_.accepts(child1Value)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value))) {
                            break;
                        }
                        count2_++;
                        s2_ = s2_.next_;
                    }
                    if (s2_ == null) {
                        {
                            InteropLibrary leftLibrary__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                            // assert (s2_.leftLibrary_.accepts(child0Value));
                            // assert (s2_.rightLibrary_.accepts(child1Value));
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                InteropLibrary rightLibrary__ = this.insert((INTEROP_LIBRARY_.create(child1Value)));
                                if ((rightLibrary__.fitsInBigInteger(child1Value)) && count2_ < (3)) {
                                    s2_ = this.insert(new InteropBigInteger0Data(s2_original));
                                    Objects.requireNonNull(s2_.insert(leftLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.leftLibrary_ = leftLibrary__;
                                    Objects.requireNonNull(s2_.insert(rightLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.rightLibrary_ = rightLibrary__;
                                    if (!INTEROP_BIG_INTEGER0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 & 0xfffffffa /* remove SpecializationActive[SLMulNode.doLong(long, long)], SpecializationActive[SLMulNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                    }
                    if (s2_ != null) {
                        return SLMulNode.doInteropBigInteger(child0Value, child1Value, s2_.leftLibrary_, s2_.rightLibrary_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightLibrary__ = null;
                InteropLibrary leftLibrary__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((rightLibrary__.fitsInBigInteger(child1Value))) {
                                    this.interopBigInteger0_cache = null;
                                    state_0 = state_0 & 0xfffffff2 /* remove SpecializationActive[SLMulNode.doLong(long, long)], SpecializationActive[SLMulNode.doSLBigInteger(SLBigInteger, SLBigInteger)], SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLMulNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                    return SLMulNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
                                }
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__ = null;
                node__ = (this);
                state_0 = state_0 | 0b100000 /* add SpecializationActive[SLMulNode.typeError(Object, Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLMulNode.typeError(child0Value, child1Value, node__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLMulNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b111100) == 0 /* only-active SpecializationActive[SLMulNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningLong(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_MUL$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_MUL$LONG_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                newInstruction = Instructions.SL_MUL_;
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class InteropBigInteger0Data extends Node implements SpecializationDataNode {

            @Child InteropBigInteger0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLMulNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} leftLibrary</pre> */
            @Child InteropLibrary leftLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLMulNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} rightLibrary</pre> */
            @Child InteropLibrary rightLibrary_;

            InteropBigInteger0Data(InteropBigInteger0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached(child1Value)).fitsInBigInteger(child1Value))) {
                    return SLMulNode.doInteropBigInteger(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                return SLMulNode.typeError(child0Value, child1Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLReadPropertyNode#readArray}
     *     Activation probability: 0.27381
     *     With/without class size: 11/8 bytes
     *   Specialization {@link SLReadPropertyNode#readArray}
     *     Activation probability: 0.23095
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLReadPropertyNode#readSLObject}
     *     Activation probability: 0.18810
     *     With/without class size: 11/18 bytes
     *   Specialization {@link SLReadPropertyNode#readSLObject}
     *     Activation probability: 0.14524
     *     With/without class size: 8/14 bytes
     *   Specialization {@link SLReadPropertyNode#readObject}
     *     Activation probability: 0.10238
     *     With/without class size: 7/14 bytes
     *   Specialization {@link SLReadPropertyNode#readObject}
     *     Activation probability: 0.05952
     *     With/without class size: 5/10 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLReadProperty_Node extends Node {

        private static final StateField READ_SL_OBJECT0_SL_READ_PROPERTY_NODE_READ_SL_OBJECT0_STATE_0_UPDATER = StateField.create(ReadSLObject0Data.lookup_(), "readSLObject0_state_0_");
        private static final StateField READ_SL_OBJECT1_SL_READ_PROPERTY_NODE_READ_SL_OBJECT1_STATE_0_UPDATER = StateField.create(ReadSLObject1Data.lookup_(), "readSLObject1_state_0_");
        private static final StateField READ_OBJECT0_SL_READ_PROPERTY_NODE_READ_OBJECT0_STATE_0_UPDATER = StateField.create(ReadObject0Data.lookup_(), "readObject0_state_0_");
        private static final StateField READ_OBJECT1_SL_READ_PROPERTY_NODE_READ_OBJECT1_STATE_0_UPDATER = StateField.create(ReadObject1Data.lookup_(), "readObject1_state_0_");
        static final ReferenceField<ReadArray0Data> READ_ARRAY0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "readArray0_cache", ReadArray0Data.class);
        static final ReferenceField<ReadSLObject0Data> READ_SL_OBJECT0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "readSLObject0_cache", ReadSLObject0Data.class);
        static final ReferenceField<ReadObject0Data> READ_OBJECT0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "readObject0_cache", ReadObject0Data.class);
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLReadPropertyNode#readSLObject}
         *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
         *   Inline method: {@link SLToTruffleStringNodeGen#inline}</pre> */
        private static final SLToTruffleStringNode INLINED_READ_SL_OBJECT0_TO_TRUFFLE_STRING_NODE_ = SLToTruffleStringNodeGen.inline(InlineTarget.create(SLToTruffleStringNode.class, READ_SL_OBJECT0_SL_READ_PROPERTY_NODE_READ_SL_OBJECT0_STATE_0_UPDATER.subUpdater(0, 11), ReferenceField.create(ReadSLObject0Data.lookup_(), "readSLObject0_toTruffleStringNode__field1_", Node.class), ReferenceField.create(ReadSLObject0Data.lookup_(), "readSLObject0_toTruffleStringNode__field2_", Node.class), ReferenceField.create(ReadSLObject0Data.lookup_(), "readSLObject0_toTruffleStringNode__field3_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLReadPropertyNode#readSLObject}
         *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
         *   Inline method: {@link SLToTruffleStringNodeGen#inline}</pre> */
        private static final SLToTruffleStringNode INLINED_READ_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_ = SLToTruffleStringNodeGen.inline(InlineTarget.create(SLToTruffleStringNode.class, READ_SL_OBJECT1_SL_READ_PROPERTY_NODE_READ_SL_OBJECT1_STATE_0_UPDATER.subUpdater(0, 11), ReferenceField.create(ReadSLObject1Data.lookup_(), "readSLObject1_toTruffleStringNode__field1_", Node.class), ReferenceField.create(ReadSLObject1Data.lookup_(), "readSLObject1_toTruffleStringNode__field2_", Node.class), ReferenceField.create(ReadSLObject1Data.lookup_(), "readSLObject1_toTruffleStringNode__field3_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLReadPropertyNode#readObject}
         *   Parameter: {@link SLToMemberNode} asMember
         *   Inline method: {@link SLToMemberNodeGen#inline}</pre> */
        private static final SLToMemberNode INLINED_READ_OBJECT0_AS_MEMBER_ = SLToMemberNodeGen.inline(InlineTarget.create(SLToMemberNode.class, READ_OBJECT0_SL_READ_PROPERTY_NODE_READ_OBJECT0_STATE_0_UPDATER.subUpdater(0, 9), ReferenceField.create(ReadObject0Data.lookup_(), "readObject0_asMember__field1_", Node.class), ReferenceField.create(ReadObject0Data.lookup_(), "readObject0_asMember__field2_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLReadPropertyNode#readObject}
         *   Parameter: {@link SLToMemberNode} asMember
         *   Inline method: {@link SLToMemberNodeGen#inline}</pre> */
        private static final SLToMemberNode INLINED_READ_OBJECT1_AS_MEMBER_ = SLToMemberNodeGen.inline(InlineTarget.create(SLToMemberNode.class, READ_OBJECT1_SL_READ_PROPERTY_NODE_READ_OBJECT1_STATE_0_UPDATER.subUpdater(0, 9), ReferenceField.create(ReadObject1Data.lookup_(), "readObject1_asMember__field1_", Node.class), ReferenceField.create(ReadObject1Data.lookup_(), "readObject1_asMember__field2_", Node.class)));
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLReadPropertyNode#readArray}
         *   1: SpecializationActive {@link SLReadPropertyNode#readArray}
         *   2: SpecializationActive {@link SLReadPropertyNode#readSLObject}
         *   3: SpecializationActive {@link SLReadPropertyNode#readSLObject}
         *   4: SpecializationActive {@link SLReadPropertyNode#readObject}
         *   5: SpecializationActive {@link SLReadPropertyNode#readObject}
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private ReadArray0Data readArray0_cache;
        @UnsafeAccessedField @Child private ReadSLObject0Data readSLObject0_cache;
        @Child private ReadSLObject1Data readSLObject1_cache;
        @UnsafeAccessedField @Child private ReadObject0Data readObject0_cache;
        @Child private ReadObject1Data readObject1_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 2);
            Object child1Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 1);
            if (state_0 != 0 /* is SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] || SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] || SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] || SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] || SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] || SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                if ((state_0 & 0b11) != 0 /* is SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] || SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                    if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                        ReadArray0Data s0_ = this.readArray0_cache;
                        while (s0_ != null) {
                            if ((s0_.arrays_.accepts(child0Value_)) && (s0_.numbers_.accepts(child1Value_)) && (s0_.arrays_.hasArrayElements(child0Value_))) {
                                Node node__ = (s0_);
                                return SLReadPropertyNode.readArray(child0Value_, child1Value_, node__, s0_.arrays_, s0_.numbers_);
                            }
                            s0_ = s0_.next_;
                        }
                    }
                    if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                                if ((arrays__.hasArrayElements(child0Value_))) {
                                    return this.readArray1Boundary3(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                }
                if ((state_0 & 0b1100) != 0 /* is SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] || SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */ && child0Value_ instanceof SLObject) {
                    SLObject child0Value__ = (SLObject) child0Value_;
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */) {
                        ReadSLObject0Data s2_ = this.readSLObject0_cache;
                        while (s2_ != null) {
                            if ((s2_.objectLibrary_.accepts(child0Value__))) {
                                Node node__1 = (s2_);
                                return SLReadPropertyNode.readSLObject(child0Value__, child1Value_, node__1, s2_.objectLibrary_, INLINED_READ_SL_OBJECT0_TO_TRUFFLE_STRING_NODE_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */) {
                        ReadSLObject1Data s3_ = this.readSLObject1_cache;
                        if (s3_ != null) {
                            return this.readSLObject1Boundary4(state_0, s3_, child0Value__, child1Value_, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
                if ((state_0 & 0b110000) != 0 /* is SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] || SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                        ReadObject0Data s4_ = this.readObject0_cache;
                        while (s4_ != null) {
                            if ((s4_.objects_.accepts(child0Value_)) && (!(SLReadPropertyNode.isSLObject(child0Value_))) && (s4_.objects_.hasMembers(child0Value_))) {
                                Node node__2 = (s4_);
                                return SLReadPropertyNode.readObject(child0Value_, child1Value_, node__2, s4_.objects_, INLINED_READ_OBJECT0_AS_MEMBER_);
                            }
                            s4_ = s4_.next_;
                        }
                    }
                    if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                        ReadObject1Data s5_ = this.readObject1_cache;
                        if (s5_ != null) {
                            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                            Node prev_ = encapsulating_.set(this);
                            try {
                                if ((!(SLReadPropertyNode.isSLObject(child0Value_)))) {
                                    InteropLibrary objects__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((objects__.hasMembers(child0Value_))) {
                                        return this.readObject1Boundary5(state_0, s5_, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            } finally {
                                encapsulating_.set(prev_);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readArray1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary numbers__ = (INTEROP_LIBRARY_.getUncached());
                return SLReadPropertyNode.readArray(child0Value, child1Value, node__, arrays__, numbers__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readSLObject1Boundary(int state_0, ReadSLObject1Data s3_, SLObject child0Value_, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__1 = (s3_);
                DynamicObjectLibrary objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value_));
                return SLReadPropertyNode.readSLObject(child0Value_, child1Value, node__1, objectLibrary__, INLINED_READ_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readObject1Boundary(int state_0, ReadObject1Data s5_, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__2 = (s5_);
                InteropLibrary objects__ = (INTEROP_LIBRARY_.getUncached());
                return SLReadPropertyNode.readObject(child0Value, child1Value, node__2, objects__, INLINED_READ_OBJECT1_AS_MEMBER_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readArray1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary numbers__ = (INTEROP_LIBRARY_.getUncached());
                return SLReadPropertyNode.readArray(child0Value_, child1Value_, node__, arrays__, numbers__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readSLObject1Boundary1(int state_0, ReadSLObject1Data s3_, SLObject child0Value__, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__1 = (s3_);
                DynamicObjectLibrary objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value__));
                return SLReadPropertyNode.readSLObject(child0Value__, child1Value_, node__1, objectLibrary__, INLINED_READ_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readObject1Boundary2(int state_0, ReadObject1Data s5_, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__2 = (s5_);
                InteropLibrary objects__ = (INTEROP_LIBRARY_.getUncached());
                return SLReadPropertyNode.readObject(child0Value_, child1Value_, node__2, objects__, INLINED_READ_OBJECT1_AS_MEMBER_);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            {
                Node node__ = null;
                if (((state_0 & 0b10)) == 0 /* is-not SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                    while (true) {
                        int count0_ = 0;
                        ReadArray0Data s0_ = READ_ARRAY0_CACHE_UPDATER.getVolatile(this);
                        ReadArray0Data s0_original = s0_;
                        while (s0_ != null) {
                            if ((s0_.arrays_.accepts(child0Value)) && (s0_.numbers_.accepts(child1Value)) && (s0_.arrays_.hasArrayElements(child0Value))) {
                                node__ = (s0_);
                                break;
                            }
                            count0_++;
                            s0_ = s0_.next_;
                        }
                        if (s0_ == null) {
                            {
                                InteropLibrary arrays__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                                // assert (s0_.arrays_.accepts(child0Value));
                                // assert (s0_.numbers_.accepts(child1Value));
                                if ((arrays__.hasArrayElements(child0Value)) && count0_ < (SLReadPropertyNode.LIBRARY_LIMIT)) {
                                    s0_ = this.insert(new ReadArray0Data(s0_original));
                                    node__ = (s0_);
                                    Objects.requireNonNull(s0_.insert(arrays__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s0_.arrays_ = arrays__;
                                    InteropLibrary numbers__ = s0_.insert((INTEROP_LIBRARY_.create(child1Value)));
                                    Objects.requireNonNull(numbers__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s0_.numbers_ = numbers__;
                                    if (!READ_ARRAY0_CACHE_UPDATER.compareAndSet(this, s0_original, s0_)) {
                                        continue;
                                    }
                                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                }
                            }
                        }
                        if (s0_ != null) {
                            return SLReadPropertyNode.readArray(child0Value, child1Value, node__, s0_.arrays_, s0_.numbers_);
                        }
                        break;
                    }
                }
            }
            {
                InteropLibrary numbers__ = null;
                InteropLibrary arrays__ = null;
                Node node__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            arrays__ = (INTEROP_LIBRARY_.getUncached());
                            if ((arrays__.hasArrayElements(child0Value))) {
                                node__ = (this);
                                numbers__ = (INTEROP_LIBRARY_.getUncached());
                                this.readArray0_cache = null;
                                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */;
                                state_0 = state_0 | 0b10 /* add SpecializationActive[SLReadPropertyNode.readArray(Object, Object, Node, InteropLibrary, InteropLibrary)] */;
                                this.state_0_ = state_0;
                                return SLReadPropertyNode.readArray(child0Value, child1Value, node__, arrays__, numbers__);
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            if (child0Value instanceof SLObject) {
                SLObject child0Value_ = (SLObject) child0Value;
                {
                    Node node__1 = null;
                    if (((state_0 & 0b1000)) == 0 /* is-not SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */) {
                        while (true) {
                            int count2_ = 0;
                            ReadSLObject0Data s2_ = READ_SL_OBJECT0_CACHE_UPDATER.getVolatile(this);
                            ReadSLObject0Data s2_original = s2_;
                            while (s2_ != null) {
                                if ((s2_.objectLibrary_.accepts(child0Value_))) {
                                    node__1 = (s2_);
                                    break;
                                }
                                count2_++;
                                s2_ = s2_.next_;
                            }
                            if (s2_ == null) {
                                // assert (s2_.objectLibrary_.accepts(child0Value_));
                                if (count2_ < (SLReadPropertyNode.LIBRARY_LIMIT)) {
                                    s2_ = this.insert(new ReadSLObject0Data(s2_original));
                                    node__1 = (s2_);
                                    DynamicObjectLibrary objectLibrary__ = s2_.insert((DYNAMIC_OBJECT_LIBRARY_.create(child0Value_)));
                                    Objects.requireNonNull(objectLibrary__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.objectLibrary_ = objectLibrary__;
                                    if (!READ_SL_OBJECT0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 | 0b100 /* add SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */;
                                    this.state_0_ = state_0;
                                }
                            }
                            if (s2_ != null) {
                                return SLReadPropertyNode.readSLObject(child0Value_, child1Value, node__1, s2_.objectLibrary_, INLINED_READ_SL_OBJECT0_TO_TRUFFLE_STRING_NODE_);
                            }
                            break;
                        }
                    }
                }
                {
                    DynamicObjectLibrary objectLibrary__ = null;
                    Node node__1 = null;
                    ReadSLObject1Data s3_ = this.insert(new ReadSLObject1Data());
                    node__1 = (s3_);
                    objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value_));
                    VarHandle.storeStoreFence();
                    this.readSLObject1_cache = s3_;
                    this.readSLObject0_cache = null;
                    state_0 = state_0 & 0xfffffffb /* remove SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */;
                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLReadPropertyNode.readSLObject(SLObject, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */;
                    this.state_0_ = state_0;
                    return SLReadPropertyNode.readSLObject(child0Value_, child1Value, node__1, objectLibrary__, INLINED_READ_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
                }
            }
            {
                Node node__2 = null;
                if (((state_0 & 0b100000)) == 0 /* is-not SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                    while (true) {
                        int count4_ = 0;
                        ReadObject0Data s4_ = READ_OBJECT0_CACHE_UPDATER.getVolatile(this);
                        ReadObject0Data s4_original = s4_;
                        while (s4_ != null) {
                            if ((s4_.objects_.accepts(child0Value)) && (!(SLReadPropertyNode.isSLObject(child0Value))) && (s4_.objects_.hasMembers(child0Value))) {
                                node__2 = (s4_);
                                break;
                            }
                            count4_++;
                            s4_ = s4_.next_;
                        }
                        if (s4_ == null) {
                            if ((!(SLReadPropertyNode.isSLObject(child0Value)))) {
                                // assert (s4_.objects_.accepts(child0Value));
                                InteropLibrary objects__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                                if ((objects__.hasMembers(child0Value)) && count4_ < (SLReadPropertyNode.LIBRARY_LIMIT)) {
                                    s4_ = this.insert(new ReadObject0Data(s4_original));
                                    node__2 = (s4_);
                                    Objects.requireNonNull(s4_.insert(objects__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s4_.objects_ = objects__;
                                    if (!READ_OBJECT0_CACHE_UPDATER.compareAndSet(this, s4_original, s4_)) {
                                        continue;
                                    }
                                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */;
                                    this.state_0_ = state_0;
                                }
                            }
                        }
                        if (s4_ != null) {
                            return SLReadPropertyNode.readObject(child0Value, child1Value, node__2, s4_.objects_, INLINED_READ_OBJECT0_AS_MEMBER_);
                        }
                        break;
                    }
                }
            }
            {
                InteropLibrary objects__ = null;
                Node node__2 = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        if ((!(SLReadPropertyNode.isSLObject(child0Value)))) {
                            objects__ = (INTEROP_LIBRARY_.getUncached());
                            if ((objects__.hasMembers(child0Value))) {
                                ReadObject1Data s5_ = this.insert(new ReadObject1Data());
                                node__2 = (s5_);
                                VarHandle.storeStoreFence();
                                this.readObject1_cache = s5_;
                                this.readObject0_cache = null;
                                state_0 = state_0 & 0xffffffef /* remove SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */;
                                state_0 = state_0 | 0b100000 /* add SpecializationActive[SLReadPropertyNode.readObject(Object, Object, Node, InteropLibrary, SLToMemberNode)] */;
                                this.state_0_ = state_0;
                                return SLReadPropertyNode.readObject(child0Value, child1Value, node__2, objects__, INLINED_READ_OBJECT1_AS_MEMBER_);
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            throw new UnsupportedSpecializationException(this, null, child0Value, child1Value);
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readArray1Boundary3(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary numbers__ = (INTEROP_LIBRARY_.getUncached());
                return SLReadPropertyNode.readArray(child0Value_, child1Value_, node__, arrays__, numbers__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readSLObject1Boundary4(int state_0, ReadSLObject1Data s3_, SLObject child0Value__, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__1 = (s3_);
                DynamicObjectLibrary objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value__));
                return SLReadPropertyNode.readSLObject(child0Value__, child1Value_, node__1, objectLibrary__, INLINED_READ_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object readObject1Boundary5(int state_0, ReadObject1Data s5_, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__2 = (s5_);
                InteropLibrary objects__ = (INTEROP_LIBRARY_.getUncached());
                return SLReadPropertyNode.readObject(child0Value_, child1Value_, node__2, objects__, INLINED_READ_OBJECT1_AS_MEMBER_);
            }
        }

        @TruffleBoundary
        private static UnsupportedSpecializationException newUnsupportedSpecializationException2(Node thisNode_, Object child0Value, Object child1Value) {
            return new UnsupportedSpecializationException(thisNode_, null, child0Value, child1Value);
        }

        @DenyReplace
        private static final class ReadArray0Data extends Node implements SpecializationDataNode {

            @Child ReadArray0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readArray}
             *   Parameter: {@link InteropLibrary} arrays</pre> */
            @Child InteropLibrary arrays_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readArray}
             *   Parameter: {@link InteropLibrary} numbers</pre> */
            @Child InteropLibrary numbers_;

            ReadArray0Data(ReadArray0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class ReadSLObject0Data extends Node implements SpecializationDataNode {

            @Child ReadSLObject0Data next_;
            /**
             * State Info: <pre>
             *   0-10: InlinedCache
             *        Specialization: {@link SLReadPropertyNode#readSLObject}
             *        Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *        Inline method: {@link SLToTruffleStringNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int readSLObject0_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link DynamicObjectLibrary} objectLibrary</pre> */
            @Child DynamicObjectLibrary objectLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readSLObject0_toTruffleStringNode__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readSLObject0_toTruffleStringNode__field2_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field3</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readSLObject0_toTruffleStringNode__field3_;

            ReadSLObject0Data(ReadSLObject0Data next_) {
                this.next_ = next_;
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class ReadSLObject1Data extends Node implements SpecializationDataNode {

            /**
             * State Info: <pre>
             *   0-10: InlinedCache
             *        Specialization: {@link SLReadPropertyNode#readSLObject}
             *        Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *        Inline method: {@link SLToTruffleStringNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int readSLObject1_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readSLObject1_toTruffleStringNode__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readSLObject1_toTruffleStringNode__field2_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field3</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readSLObject1_toTruffleStringNode__field3_;

            ReadSLObject1Data() {
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class ReadObject0Data extends Node implements SpecializationDataNode {

            @Child ReadObject0Data next_;
            /**
             * State Info: <pre>
             *   0-8: InlinedCache
             *        Specialization: {@link SLReadPropertyNode#readObject}
             *        Parameter: {@link SLToMemberNode} asMember
             *        Inline method: {@link SLToMemberNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int readObject0_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readObject}
             *   Parameter: {@link InteropLibrary} objects</pre> */
            @Child InteropLibrary objects_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readObject0_asMember__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readObject0_asMember__field2_;

            ReadObject0Data(ReadObject0Data next_) {
                this.next_ = next_;
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class ReadObject1Data extends Node implements SpecializationDataNode {

            /**
             * State Info: <pre>
             *   0-8: InlinedCache
             *        Specialization: {@link SLReadPropertyNode#readObject}
             *        Parameter: {@link SLToMemberNode} asMember
             *        Inline method: {@link SLToMemberNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int readObject1_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readObject1_asMember__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLReadPropertyNode#readObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node readObject1_asMember__field2_;

            ReadObject1Data() {
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).hasArrayElements(child0Value))) {
                    return SLReadPropertyNode.readArray(child0Value, child1Value, ($bytecode), (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                if (child0Value instanceof SLObject) {
                    SLObject child0Value_ = (SLObject) child0Value;
                    return SLReadPropertyNode.readSLObject(child0Value_, child1Value, ($bytecode), (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value_)), (SLToTruffleStringNodeGen.getUncached()));
                }
                if ((!(SLReadPropertyNode.isSLObject(child0Value))) && ((INTEROP_LIBRARY_.getUncached(child0Value)).hasMembers(child0Value))) {
                    return SLReadPropertyNode.readObject(child0Value, child1Value, ($bytecode), (INTEROP_LIBRARY_.getUncached(child0Value)), (SLToMemberNodeGen.getUncached()));
                }
                throw newUnsupportedSpecializationException2(this, child0Value, child1Value);
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLSubNode#doLong}
     *     Activation probability: 0.32000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLSubNode#doSLBigInteger}
     *     Activation probability: 0.26000
     *     With/without class size: 7/0 bytes
     *   Specialization {@link SLSubNode#doInteropBigInteger}
     *     Activation probability: 0.20000
     *     With/without class size: 9/8 bytes
     *   Specialization {@link SLSubNode#doInteropBigInteger}
     *     Activation probability: 0.14000
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLSubNode#typeError}
     *     Activation probability: 0.08000
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLSub_Node extends Node {

        static final ReferenceField<InteropBigInteger0Data> INTEROP_BIG_INTEGER0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interopBigInteger0_cache", InteropBigInteger0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLSubNode#doLong}
         *   1: SpecializationExcluded {@link SLSubNode#doLong}
         *   2: SpecializationActive {@link SLSubNode#doSLBigInteger}
         *   3: SpecializationActive {@link SLSubNode#doInteropBigInteger}
         *   4: SpecializationActive {@link SLSubNode#doInteropBigInteger}
         *   5: SpecializationActive {@link SLSubNode#typeError}
         *   6-7: ImplicitCast[type=SLBigInteger, index=0]
         *   8-9: ImplicitCast[type=SLBigInteger, index=1]
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private InteropBigInteger0Data interopBigInteger0_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp);
            }
            Object child1Value_;
            try {
                child1Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b111101) != 0 /* is SpecializationActive[SLSubNode.doLong(long, long)] || SpecializationActive[SLSubNode.doSLBigInteger(SLBigInteger, SLBigInteger)] || SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLSubNode.typeError(Object, Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLSubNode.doLong(long, long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    if (child1Value_ instanceof Long) {
                        long child1Value__ = (long) child1Value_;
                        try {
                            return SLSubNode.doLong(child0Value__, child1Value__);
                        } catch (ArithmeticException ex) {
                            CompilerDirectives.transferToInterpreterAndInvalidate();
                            state_0 = this.state_0_;
                            state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLSubNode.doLong(long, long)] */;
                            state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                            this.state_0_ = state_0;
                            return executeAndSpecialize(child0Value__, child1Value__, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLSubNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000) >>> 6 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000) >>> 6 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    if (SLTypesGen.isImplicitSLBigInteger((state_0 & 0b1100000000) >>> 8 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_)) {
                        SLBigInteger child1Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b1100000000) >>> 8 /* get-int ImplicitCast[type=SLBigInteger, index=1] */, child1Value_);
                        return SLSubNode.doSLBigInteger(child0Value__, child1Value__);
                    }
                }
                if ((state_0 & 0b111000) != 0 /* is SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] || SpecializationActive[SLSubNode.typeError(Object, Object, Node)] */) {
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        InteropBigInteger0Data s2_ = this.interopBigInteger0_cache;
                        while (s2_ != null) {
                            if ((s2_.leftLibrary_.accepts(child0Value_)) && (s2_.rightLibrary_.accepts(child1Value_)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value_)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value_))) {
                                return SLSubNode.doInteropBigInteger(child0Value_, child1Value_, s2_.leftLibrary_, s2_.rightLibrary_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((leftLibrary__.fitsInBigInteger(child0Value_))) {
                                    InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                    if ((rightLibrary__.fitsInBigInteger(child1Value_))) {
                                        return this.interopBigInteger1Boundary1(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                                    }
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLSubNode.typeError(Object, Object, Node)] */) {
                        {
                            Node node__ = (this);
                            if (fallbackGuard_(state_0, child0Value_, child1Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLSubNode.typeError(child0Value_, child1Value_, node__);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
        }

        private long executeLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLSubNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLSubNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        private long executeLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 2);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                Object child1Value = FRAMES.getValue(frameValue, $sp - 1);
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), child1Value, $bytecode, $bc, $bci, $sp));
            }
            long child1Value_;
            try {
                child1Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            try {
                return SLSubNode.doLong(child0Value_, child1Value_);
            } catch (ArithmeticException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                int state_0 = this.state_0_;
                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLSubNode.doLong(long, long)] */;
                state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                this.state_0_ = state_0;
                return SLTypesGen.expectLong(executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp));
            }
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b10000) != 0 /* is SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached()).fitsInBigInteger(child1Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary(int state_0, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLSubNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary0(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLSubNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (((state_0 & 0b11100)) == 0 /* is-not SpecializationActive[SLSubNode.doSLBigInteger(SLBigInteger, SLBigInteger)] && SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */ && ((state_0 & 0b10)) == 0 /* is-not SpecializationExcluded  */ && child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                if (child1Value instanceof Long) {
                    long child1Value_ = (long) child1Value;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLSubNode.doLong(long, long)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    try {
                        return SLSubNode.doLong(child0Value_, child1Value_);
                    } catch (ArithmeticException ex) {
                        CompilerDirectives.transferToInterpreterAndInvalidate();
                        state_0 = this.state_0_;
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLSubNode.doLong(long, long)] */;
                        state_0 = state_0 | 0b10 /* add SpecializationExcluded  */;
                        this.state_0_ = state_0;
                        return executeAndSpecialize(child0Value_, child1Value_, $bytecode, $bc, $bci, $sp);
                    }
                }
            }
            if (((state_0 & 0b11000)) == 0 /* is-not SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] && SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    int sLBigIntegerCast1;
                    if ((sLBigIntegerCast1 = SLTypesGen.specializeImplicitSLBigInteger(child1Value)) != 0) {
                        SLBigInteger child1Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast1, child1Value);
                        state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLSubNode.doLong(long, long)] */;
                        state_0 = (state_0 | (sLBigIntegerCast0 << 6) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                        state_0 = (state_0 | (sLBigIntegerCast1 << 8) /* set-int ImplicitCast[type=SLBigInteger, index=1] */);
                        state_0 = state_0 | 0b100 /* add SpecializationActive[SLSubNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLSubNode.doSLBigInteger(child0Value_, child1Value_);
                    }
                }
            }
            if (((state_0 & 0b10000)) == 0 /* is-not SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */) {
                while (true) {
                    int count2_ = 0;
                    InteropBigInteger0Data s2_ = INTEROP_BIG_INTEGER0_CACHE_UPDATER.getVolatile(this);
                    InteropBigInteger0Data s2_original = s2_;
                    while (s2_ != null) {
                        if ((s2_.leftLibrary_.accepts(child0Value)) && (s2_.rightLibrary_.accepts(child1Value)) && (s2_.leftLibrary_.fitsInBigInteger(child0Value)) && (s2_.rightLibrary_.fitsInBigInteger(child1Value))) {
                            break;
                        }
                        count2_++;
                        s2_ = s2_.next_;
                    }
                    if (s2_ == null) {
                        {
                            InteropLibrary leftLibrary__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                            // assert (s2_.leftLibrary_.accepts(child0Value));
                            // assert (s2_.rightLibrary_.accepts(child1Value));
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                InteropLibrary rightLibrary__ = this.insert((INTEROP_LIBRARY_.create(child1Value)));
                                if ((rightLibrary__.fitsInBigInteger(child1Value)) && count2_ < (3)) {
                                    s2_ = this.insert(new InteropBigInteger0Data(s2_original));
                                    Objects.requireNonNull(s2_.insert(leftLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.leftLibrary_ = leftLibrary__;
                                    Objects.requireNonNull(s2_.insert(rightLibrary__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.rightLibrary_ = rightLibrary__;
                                    if (!INTEROP_BIG_INTEGER0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 & 0xfffffffa /* remove SpecializationActive[SLSubNode.doLong(long, long)], SpecializationActive[SLSubNode.doSLBigInteger(SLBigInteger, SLBigInteger)] */;
                                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                    }
                    if (s2_ != null) {
                        return SLSubNode.doInteropBigInteger(child0Value, child1Value, s2_.leftLibrary_, s2_.rightLibrary_);
                    }
                    break;
                }
            }
            {
                InteropLibrary rightLibrary__ = null;
                InteropLibrary leftLibrary__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                            if ((leftLibrary__.fitsInBigInteger(child0Value))) {
                                rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                                if ((rightLibrary__.fitsInBigInteger(child1Value))) {
                                    this.interopBigInteger0_cache = null;
                                    state_0 = state_0 & 0xfffffff2 /* remove SpecializationActive[SLSubNode.doLong(long, long)], SpecializationActive[SLSubNode.doSLBigInteger(SLBigInteger, SLBigInteger)], SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLSubNode.doInteropBigInteger(Object, Object, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                    return SLSubNode.doInteropBigInteger(child0Value, child1Value, leftLibrary__, rightLibrary__);
                                }
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__ = null;
                node__ = (this);
                state_0 = state_0 | 0b100000 /* add SpecializationActive[SLSubNode.typeError(Object, Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLSubNode.typeError(child0Value, child1Value, node__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object interopBigInteger1Boundary1(int state_0, Object child0Value_, Object child1Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                InteropLibrary leftLibrary__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary rightLibrary__ = (INTEROP_LIBRARY_.getUncached());
                return SLSubNode.doInteropBigInteger(child0Value_, child1Value_, leftLibrary__, rightLibrary__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            int oldOperandIndex1 = BYTES.getIntUnaligned($bc, $bci + 10 /* imm child1 */);
            short oldOperand1 = BYTES.getShort($bc, oldOperandIndex1);
            short newOperand1;
            if ((state_0 & 0b111100) == 0 /* only-active SpecializationActive[SLSubNode.doLong(long, long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1
               && (newOperand1 = applyQuickeningLong(oldOperand1)) != -1) {
                if (isQuickeningLong(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_SUB$LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_SUB$LONG_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newOperand1 = undoQuickening(oldOperand1);
                newInstruction = Instructions.SL_SUB_;
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, oldOperandIndex1, newOperand1);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class InteropBigInteger0Data extends Node implements SpecializationDataNode {

            @Child InteropBigInteger0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLSubNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} leftLibrary</pre> */
            @Child InteropLibrary leftLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLSubNode#doInteropBigInteger}
             *   Parameter: {@link InteropLibrary} rightLibrary</pre> */
            @Child InteropLibrary rightLibrary_;

            InteropBigInteger0Data(InteropBigInteger0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).fitsInBigInteger(child0Value)) && ((INTEROP_LIBRARY_.getUncached(child1Value)).fitsInBigInteger(child1Value))) {
                    return SLSubNode.doInteropBigInteger(child0Value, child1Value, (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                return SLSubNode.typeError(child0Value, child1Value, ($bytecode));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLWritePropertyNode#writeArray}
     *     Activation probability: 0.27381
     *     With/without class size: 11/8 bytes
     *   Specialization {@link SLWritePropertyNode#writeArray}
     *     Activation probability: 0.23095
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLWritePropertyNode#writeSLObject}
     *     Activation probability: 0.18810
     *     With/without class size: 11/18 bytes
     *   Specialization {@link SLWritePropertyNode#writeSLObject}
     *     Activation probability: 0.14524
     *     With/without class size: 8/14 bytes
     *   Specialization {@link SLWritePropertyNode#writeObject}
     *     Activation probability: 0.10238
     *     With/without class size: 7/14 bytes
     *   Specialization {@link SLWritePropertyNode#writeObject}
     *     Activation probability: 0.05952
     *     With/without class size: 5/10 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLWriteProperty_Node extends Node {

        private static final StateField WRITE_SL_OBJECT0_SL_WRITE_PROPERTY_NODE_WRITE_SL_OBJECT0_STATE_0_UPDATER = StateField.create(WriteSLObject0Data.lookup_(), "writeSLObject0_state_0_");
        private static final StateField WRITE_SL_OBJECT1_SL_WRITE_PROPERTY_NODE_WRITE_SL_OBJECT1_STATE_0_UPDATER = StateField.create(WriteSLObject1Data.lookup_(), "writeSLObject1_state_0_");
        private static final StateField WRITE_OBJECT0_SL_WRITE_PROPERTY_NODE_WRITE_OBJECT0_STATE_0_UPDATER = StateField.create(WriteObject0Data.lookup_(), "writeObject0_state_0_");
        private static final StateField WRITE_OBJECT1_SL_WRITE_PROPERTY_NODE_WRITE_OBJECT1_STATE_0_UPDATER = StateField.create(WriteObject1Data.lookup_(), "writeObject1_state_0_");
        static final ReferenceField<WriteArray0Data> WRITE_ARRAY0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "writeArray0_cache", WriteArray0Data.class);
        static final ReferenceField<WriteSLObject0Data> WRITE_SL_OBJECT0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "writeSLObject0_cache", WriteSLObject0Data.class);
        static final ReferenceField<WriteObject0Data> WRITE_OBJECT0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "writeObject0_cache", WriteObject0Data.class);
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLWritePropertyNode#writeSLObject}
         *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
         *   Inline method: {@link SLToTruffleStringNodeGen#inline}</pre> */
        private static final SLToTruffleStringNode INLINED_WRITE_SL_OBJECT0_TO_TRUFFLE_STRING_NODE_ = SLToTruffleStringNodeGen.inline(InlineTarget.create(SLToTruffleStringNode.class, WRITE_SL_OBJECT0_SL_WRITE_PROPERTY_NODE_WRITE_SL_OBJECT0_STATE_0_UPDATER.subUpdater(0, 11), ReferenceField.create(WriteSLObject0Data.lookup_(), "writeSLObject0_toTruffleStringNode__field1_", Node.class), ReferenceField.create(WriteSLObject0Data.lookup_(), "writeSLObject0_toTruffleStringNode__field2_", Node.class), ReferenceField.create(WriteSLObject0Data.lookup_(), "writeSLObject0_toTruffleStringNode__field3_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLWritePropertyNode#writeSLObject}
         *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
         *   Inline method: {@link SLToTruffleStringNodeGen#inline}</pre> */
        private static final SLToTruffleStringNode INLINED_WRITE_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_ = SLToTruffleStringNodeGen.inline(InlineTarget.create(SLToTruffleStringNode.class, WRITE_SL_OBJECT1_SL_WRITE_PROPERTY_NODE_WRITE_SL_OBJECT1_STATE_0_UPDATER.subUpdater(0, 11), ReferenceField.create(WriteSLObject1Data.lookup_(), "writeSLObject1_toTruffleStringNode__field1_", Node.class), ReferenceField.create(WriteSLObject1Data.lookup_(), "writeSLObject1_toTruffleStringNode__field2_", Node.class), ReferenceField.create(WriteSLObject1Data.lookup_(), "writeSLObject1_toTruffleStringNode__field3_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLWritePropertyNode#writeObject}
         *   Parameter: {@link SLToMemberNode} asMember
         *   Inline method: {@link SLToMemberNodeGen#inline}</pre> */
        private static final SLToMemberNode INLINED_WRITE_OBJECT0_AS_MEMBER_ = SLToMemberNodeGen.inline(InlineTarget.create(SLToMemberNode.class, WRITE_OBJECT0_SL_WRITE_PROPERTY_NODE_WRITE_OBJECT0_STATE_0_UPDATER.subUpdater(0, 9), ReferenceField.create(WriteObject0Data.lookup_(), "writeObject0_asMember__field1_", Node.class), ReferenceField.create(WriteObject0Data.lookup_(), "writeObject0_asMember__field2_", Node.class)));
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLWritePropertyNode#writeObject}
         *   Parameter: {@link SLToMemberNode} asMember
         *   Inline method: {@link SLToMemberNodeGen#inline}</pre> */
        private static final SLToMemberNode INLINED_WRITE_OBJECT1_AS_MEMBER_ = SLToMemberNodeGen.inline(InlineTarget.create(SLToMemberNode.class, WRITE_OBJECT1_SL_WRITE_PROPERTY_NODE_WRITE_OBJECT1_STATE_0_UPDATER.subUpdater(0, 9), ReferenceField.create(WriteObject1Data.lookup_(), "writeObject1_asMember__field1_", Node.class), ReferenceField.create(WriteObject1Data.lookup_(), "writeObject1_asMember__field2_", Node.class)));
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLWritePropertyNode#writeArray}
         *   1: SpecializationActive {@link SLWritePropertyNode#writeArray}
         *   2: SpecializationActive {@link SLWritePropertyNode#writeSLObject}
         *   3: SpecializationActive {@link SLWritePropertyNode#writeSLObject}
         *   4: SpecializationActive {@link SLWritePropertyNode#writeObject}
         *   5: SpecializationActive {@link SLWritePropertyNode#writeObject}
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private WriteArray0Data writeArray0_cache;
        @UnsafeAccessedField @Child private WriteSLObject0Data writeSLObject0_cache;
        @Child private WriteSLObject1Data writeSLObject1_cache;
        @UnsafeAccessedField @Child private WriteObject0Data writeObject0_cache;
        @Child private WriteObject1Data writeObject1_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 3);
            Object child1Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 2);
            Object child2Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 1);
            if (state_0 != 0 /* is SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] || SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] || SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] || SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] || SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] || SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                if ((state_0 & 0b11) != 0 /* is SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] || SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                    if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                        WriteArray0Data s0_ = this.writeArray0_cache;
                        while (s0_ != null) {
                            if ((s0_.arrays_.accepts(child0Value_)) && (s0_.numbers_.accepts(child1Value_)) && (s0_.arrays_.hasArrayElements(child0Value_))) {
                                Node node__ = (s0_);
                                return SLWritePropertyNode.writeArray(child0Value_, child1Value_, child2Value_, node__, s0_.arrays_, s0_.numbers_);
                            }
                            s0_ = s0_.next_;
                        }
                    }
                    if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                                if ((arrays__.hasArrayElements(child0Value_))) {
                                    return this.writeArray1Boundary3(state_0, child0Value_, child1Value_, child2Value_, $bytecode, $bc, $bci, $sp);
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                }
                if ((state_0 & 0b1100) != 0 /* is SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] || SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */ && child0Value_ instanceof SLObject) {
                    SLObject child0Value__ = (SLObject) child0Value_;
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */) {
                        WriteSLObject0Data s2_ = this.writeSLObject0_cache;
                        while (s2_ != null) {
                            if ((s2_.objectLibrary_.accepts(child0Value__))) {
                                Node node__1 = (s2_);
                                return SLWritePropertyNode.writeSLObject(child0Value__, child1Value_, child2Value_, node__1, s2_.objectLibrary_, INLINED_WRITE_SL_OBJECT0_TO_TRUFFLE_STRING_NODE_);
                            }
                            s2_ = s2_.next_;
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */) {
                        WriteSLObject1Data s3_ = this.writeSLObject1_cache;
                        if (s3_ != null) {
                            return this.writeSLObject1Boundary4(state_0, s3_, child0Value__, child1Value_, child2Value_, $bytecode, $bc, $bci, $sp);
                        }
                    }
                }
                if ((state_0 & 0b110000) != 0 /* is SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] || SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                    if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                        WriteObject0Data s4_ = this.writeObject0_cache;
                        while (s4_ != null) {
                            if ((s4_.objectLibrary_.accepts(child0Value_)) && (!(SLWritePropertyNode.isSLObject(child0Value_)))) {
                                Node node__2 = (s4_);
                                return SLWritePropertyNode.writeObject(child0Value_, child1Value_, child2Value_, node__2, s4_.objectLibrary_, INLINED_WRITE_OBJECT0_AS_MEMBER_);
                            }
                            s4_ = s4_.next_;
                        }
                    }
                    if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                        WriteObject1Data s5_ = this.writeObject1_cache;
                        if (s5_ != null) {
                            if ((!(SLWritePropertyNode.isSLObject(child0Value_)))) {
                                return this.writeObject1Boundary5(state_0, s5_, child0Value_, child1Value_, child2Value_, $bytecode, $bc, $bci, $sp);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, child1Value_, child2Value_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeArray1Boundary(int state_0, Object child0Value, Object child1Value, Object child2Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary numbers__ = (INTEROP_LIBRARY_.getUncached());
                return SLWritePropertyNode.writeArray(child0Value, child1Value, child2Value, node__, arrays__, numbers__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeSLObject1Boundary(int state_0, WriteSLObject1Data s3_, SLObject child0Value_, Object child1Value, Object child2Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__1 = (s3_);
                DynamicObjectLibrary objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value_));
                return SLWritePropertyNode.writeSLObject(child0Value_, child1Value, child2Value, node__1, objectLibrary__, INLINED_WRITE_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeObject1Boundary(int state_0, WriteObject1Data s5_, Object child0Value, Object child1Value, Object child2Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    Node node__2 = (s5_);
                    InteropLibrary objectLibrary__1 = (INTEROP_LIBRARY_.getUncached(child0Value));
                    return SLWritePropertyNode.writeObject(child0Value, child1Value, child2Value, node__2, objectLibrary__1, INLINED_WRITE_OBJECT1_AS_MEMBER_);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeArray1Boundary0(int state_0, Object child0Value_, Object child1Value_, Object child2Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary numbers__ = (INTEROP_LIBRARY_.getUncached());
                return SLWritePropertyNode.writeArray(child0Value_, child1Value_, child2Value_, node__, arrays__, numbers__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeSLObject1Boundary1(int state_0, WriteSLObject1Data s3_, SLObject child0Value__, Object child1Value_, Object child2Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__1 = (s3_);
                DynamicObjectLibrary objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value__));
                return SLWritePropertyNode.writeSLObject(child0Value__, child1Value_, child2Value_, node__1, objectLibrary__, INLINED_WRITE_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeObject1Boundary2(int state_0, WriteObject1Data s5_, Object child0Value_, Object child1Value_, Object child2Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    Node node__2 = (s5_);
                    InteropLibrary objectLibrary__1 = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    return SLWritePropertyNode.writeObject(child0Value_, child1Value_, child2Value_, node__2, objectLibrary__1, INLINED_WRITE_OBJECT1_AS_MEMBER_);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        @SuppressWarnings("unused")
        private Object executeAndSpecialize(Object child0Value, Object child1Value, Object child2Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            {
                Node node__ = null;
                if (((state_0 & 0b10)) == 0 /* is-not SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */) {
                    while (true) {
                        int count0_ = 0;
                        WriteArray0Data s0_ = WRITE_ARRAY0_CACHE_UPDATER.getVolatile(this);
                        WriteArray0Data s0_original = s0_;
                        while (s0_ != null) {
                            if ((s0_.arrays_.accepts(child0Value)) && (s0_.numbers_.accepts(child1Value)) && (s0_.arrays_.hasArrayElements(child0Value))) {
                                node__ = (s0_);
                                break;
                            }
                            count0_++;
                            s0_ = s0_.next_;
                        }
                        if (s0_ == null) {
                            {
                                InteropLibrary arrays__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                                // assert (s0_.arrays_.accepts(child0Value));
                                // assert (s0_.numbers_.accepts(child1Value));
                                if ((arrays__.hasArrayElements(child0Value)) && count0_ < (SLWritePropertyNode.LIBRARY_LIMIT)) {
                                    s0_ = this.insert(new WriteArray0Data(s0_original));
                                    node__ = (s0_);
                                    Objects.requireNonNull(s0_.insert(arrays__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s0_.arrays_ = arrays__;
                                    InteropLibrary numbers__ = s0_.insert((INTEROP_LIBRARY_.create(child1Value)));
                                    Objects.requireNonNull(numbers__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s0_.numbers_ = numbers__;
                                    if (!WRITE_ARRAY0_CACHE_UPDATER.compareAndSet(this, s0_original, s0_)) {
                                        continue;
                                    }
                                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                }
                            }
                        }
                        if (s0_ != null) {
                            return SLWritePropertyNode.writeArray(child0Value, child1Value, child2Value, node__, s0_.arrays_, s0_.numbers_);
                        }
                        break;
                    }
                }
            }
            {
                InteropLibrary numbers__ = null;
                InteropLibrary arrays__ = null;
                Node node__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            arrays__ = (INTEROP_LIBRARY_.getUncached());
                            if ((arrays__.hasArrayElements(child0Value))) {
                                node__ = (this);
                                numbers__ = (INTEROP_LIBRARY_.getUncached());
                                this.writeArray0_cache = null;
                                state_0 = state_0 & 0xfffffffe /* remove SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */;
                                state_0 = state_0 | 0b10 /* add SpecializationActive[SLWritePropertyNode.writeArray(Object, Object, Object, Node, InteropLibrary, InteropLibrary)] */;
                                this.state_0_ = state_0;
                                return SLWritePropertyNode.writeArray(child0Value, child1Value, child2Value, node__, arrays__, numbers__);
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            if (child0Value instanceof SLObject) {
                SLObject child0Value_ = (SLObject) child0Value;
                {
                    Node node__1 = null;
                    if (((state_0 & 0b1000)) == 0 /* is-not SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */) {
                        while (true) {
                            int count2_ = 0;
                            WriteSLObject0Data s2_ = WRITE_SL_OBJECT0_CACHE_UPDATER.getVolatile(this);
                            WriteSLObject0Data s2_original = s2_;
                            while (s2_ != null) {
                                if ((s2_.objectLibrary_.accepts(child0Value_))) {
                                    node__1 = (s2_);
                                    break;
                                }
                                count2_++;
                                s2_ = s2_.next_;
                            }
                            if (s2_ == null) {
                                // assert (s2_.objectLibrary_.accepts(child0Value_));
                                if (count2_ < (SLWritePropertyNode.LIBRARY_LIMIT)) {
                                    s2_ = this.insert(new WriteSLObject0Data(s2_original));
                                    node__1 = (s2_);
                                    DynamicObjectLibrary objectLibrary__ = s2_.insert((DYNAMIC_OBJECT_LIBRARY_.create(child0Value_)));
                                    Objects.requireNonNull(objectLibrary__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s2_.objectLibrary_ = objectLibrary__;
                                    if (!WRITE_SL_OBJECT0_CACHE_UPDATER.compareAndSet(this, s2_original, s2_)) {
                                        continue;
                                    }
                                    state_0 = state_0 | 0b100 /* add SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */;
                                    this.state_0_ = state_0;
                                }
                            }
                            if (s2_ != null) {
                                return SLWritePropertyNode.writeSLObject(child0Value_, child1Value, child2Value, node__1, s2_.objectLibrary_, INLINED_WRITE_SL_OBJECT0_TO_TRUFFLE_STRING_NODE_);
                            }
                            break;
                        }
                    }
                }
                {
                    DynamicObjectLibrary objectLibrary__ = null;
                    Node node__1 = null;
                    WriteSLObject1Data s3_ = this.insert(new WriteSLObject1Data());
                    node__1 = (s3_);
                    objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value_));
                    VarHandle.storeStoreFence();
                    this.writeSLObject1_cache = s3_;
                    this.writeSLObject0_cache = null;
                    state_0 = state_0 & 0xfffffffb /* remove SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */;
                    state_0 = state_0 | 0b1000 /* add SpecializationActive[SLWritePropertyNode.writeSLObject(SLObject, Object, Object, Node, DynamicObjectLibrary, SLToTruffleStringNode)] */;
                    this.state_0_ = state_0;
                    return SLWritePropertyNode.writeSLObject(child0Value_, child1Value, child2Value, node__1, objectLibrary__, INLINED_WRITE_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
                }
            }
            {
                Node node__2 = null;
                if (((state_0 & 0b100000)) == 0 /* is-not SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */) {
                    while (true) {
                        int count4_ = 0;
                        WriteObject0Data s4_ = WRITE_OBJECT0_CACHE_UPDATER.getVolatile(this);
                        WriteObject0Data s4_original = s4_;
                        while (s4_ != null) {
                            if ((s4_.objectLibrary_.accepts(child0Value)) && (!(SLWritePropertyNode.isSLObject(child0Value)))) {
                                node__2 = (s4_);
                                break;
                            }
                            count4_++;
                            s4_ = s4_.next_;
                        }
                        if (s4_ == null) {
                            if ((!(SLWritePropertyNode.isSLObject(child0Value))) && count4_ < (SLWritePropertyNode.LIBRARY_LIMIT)) {
                                // assert (s4_.objectLibrary_.accepts(child0Value));
                                s4_ = this.insert(new WriteObject0Data(s4_original));
                                node__2 = (s4_);
                                InteropLibrary objectLibrary__1 = s4_.insert((INTEROP_LIBRARY_.create(child0Value)));
                                Objects.requireNonNull(objectLibrary__1, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                s4_.objectLibrary_ = objectLibrary__1;
                                if (!WRITE_OBJECT0_CACHE_UPDATER.compareAndSet(this, s4_original, s4_)) {
                                    continue;
                                }
                                state_0 = state_0 | 0b10000 /* add SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */;
                                this.state_0_ = state_0;
                            }
                        }
                        if (s4_ != null) {
                            return SLWritePropertyNode.writeObject(child0Value, child1Value, child2Value, node__2, s4_.objectLibrary_, INLINED_WRITE_OBJECT0_AS_MEMBER_);
                        }
                        break;
                    }
                }
            }
            {
                InteropLibrary objectLibrary__1 = null;
                Node node__2 = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        if ((!(SLWritePropertyNode.isSLObject(child0Value)))) {
                            WriteObject1Data s5_ = this.insert(new WriteObject1Data());
                            node__2 = (s5_);
                            objectLibrary__1 = (INTEROP_LIBRARY_.getUncached(child0Value));
                            VarHandle.storeStoreFence();
                            this.writeObject1_cache = s5_;
                            this.writeObject0_cache = null;
                            state_0 = state_0 & 0xffffffef /* remove SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */;
                            state_0 = state_0 | 0b100000 /* add SpecializationActive[SLWritePropertyNode.writeObject(Object, Object, Object, Node, InteropLibrary, SLToMemberNode)] */;
                            this.state_0_ = state_0;
                            return SLWritePropertyNode.writeObject(child0Value, child1Value, child2Value, node__2, objectLibrary__1, INLINED_WRITE_OBJECT1_AS_MEMBER_);
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            throw new UnsupportedSpecializationException(this, null, child0Value, child1Value, child2Value);
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeArray1Boundary3(int state_0, Object child0Value_, Object child1Value_, Object child2Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary arrays__ = (INTEROP_LIBRARY_.getUncached());
                InteropLibrary numbers__ = (INTEROP_LIBRARY_.getUncached());
                return SLWritePropertyNode.writeArray(child0Value_, child1Value_, child2Value_, node__, arrays__, numbers__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeSLObject1Boundary4(int state_0, WriteSLObject1Data s3_, SLObject child0Value__, Object child1Value_, Object child2Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__1 = (s3_);
                DynamicObjectLibrary objectLibrary__ = (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value__));
                return SLWritePropertyNode.writeSLObject(child0Value__, child1Value_, child2Value_, node__1, objectLibrary__, INLINED_WRITE_SL_OBJECT1_TO_TRUFFLE_STRING_NODE_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object writeObject1Boundary5(int state_0, WriteObject1Data s5_, Object child0Value_, Object child1Value_, Object child2Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    Node node__2 = (s5_);
                    InteropLibrary objectLibrary__1 = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    return SLWritePropertyNode.writeObject(child0Value_, child1Value_, child2Value_, node__2, objectLibrary__1, INLINED_WRITE_OBJECT1_AS_MEMBER_);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        @TruffleBoundary
        private static UnsupportedSpecializationException newUnsupportedSpecializationException3(Node thisNode_, Object child0Value, Object child1Value, Object child2Value) {
            return new UnsupportedSpecializationException(thisNode_, null, child0Value, child1Value, child2Value);
        }

        @DenyReplace
        private static final class WriteArray0Data extends Node implements SpecializationDataNode {

            @Child WriteArray0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeArray}
             *   Parameter: {@link InteropLibrary} arrays</pre> */
            @Child InteropLibrary arrays_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeArray}
             *   Parameter: {@link InteropLibrary} numbers</pre> */
            @Child InteropLibrary numbers_;

            WriteArray0Data(WriteArray0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class WriteSLObject0Data extends Node implements SpecializationDataNode {

            @Child WriteSLObject0Data next_;
            /**
             * State Info: <pre>
             *   0-10: InlinedCache
             *        Specialization: {@link SLWritePropertyNode#writeSLObject}
             *        Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *        Inline method: {@link SLToTruffleStringNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int writeSLObject0_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link DynamicObjectLibrary} objectLibrary</pre> */
            @Child DynamicObjectLibrary objectLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeSLObject0_toTruffleStringNode__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeSLObject0_toTruffleStringNode__field2_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field3</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeSLObject0_toTruffleStringNode__field3_;

            WriteSLObject0Data(WriteSLObject0Data next_) {
                this.next_ = next_;
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class WriteSLObject1Data extends Node implements SpecializationDataNode {

            /**
             * State Info: <pre>
             *   0-10: InlinedCache
             *        Specialization: {@link SLWritePropertyNode#writeSLObject}
             *        Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *        Inline method: {@link SLToTruffleStringNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int writeSLObject1_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeSLObject1_toTruffleStringNode__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeSLObject1_toTruffleStringNode__field2_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeSLObject}
             *   Parameter: {@link SLToTruffleStringNode} toTruffleStringNode
             *   Inline method: {@link SLToTruffleStringNodeGen#inline}
             *   Inline field: {@link Node} field3</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeSLObject1_toTruffleStringNode__field3_;

            WriteSLObject1Data() {
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class WriteObject0Data extends Node implements SpecializationDataNode {

            @Child WriteObject0Data next_;
            /**
             * State Info: <pre>
             *   0-8: InlinedCache
             *        Specialization: {@link SLWritePropertyNode#writeObject}
             *        Parameter: {@link SLToMemberNode} asMember
             *        Inline method: {@link SLToMemberNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int writeObject0_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeObject}
             *   Parameter: {@link InteropLibrary} objectLibrary</pre> */
            @Child InteropLibrary objectLibrary_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeObject0_asMember__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeObject0_asMember__field2_;

            WriteObject0Data(WriteObject0Data next_) {
                this.next_ = next_;
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class WriteObject1Data extends Node implements SpecializationDataNode {

            /**
             * State Info: <pre>
             *   0-8: InlinedCache
             *        Specialization: {@link SLWritePropertyNode#writeObject}
             *        Parameter: {@link SLToMemberNode} asMember
             *        Inline method: {@link SLToMemberNodeGen#inline}
             * </pre> */
            @CompilationFinal @UnsafeAccessedField private int writeObject1_state_0_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field1</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeObject1_asMember__field1_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLWritePropertyNode#writeObject}
             *   Parameter: {@link SLToMemberNode} asMember
             *   Inline method: {@link SLToMemberNodeGen#inline}
             *   Inline field: {@link Node} field2</pre> */
            @Child @UnsafeAccessedField @SuppressWarnings("unused") private Node writeObject1_asMember__field2_;

            WriteObject1Data() {
            }

            private static Lookup lookup_() {
                return MethodHandles.lookup();
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, Object child1Value, Object child2Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).hasArrayElements(child0Value))) {
                    return SLWritePropertyNode.writeArray(child0Value, child1Value, child2Value, ($bytecode), (INTEROP_LIBRARY_.getUncached(child0Value)), (INTEROP_LIBRARY_.getUncached(child1Value)));
                }
                if (child0Value instanceof SLObject) {
                    SLObject child0Value_ = (SLObject) child0Value;
                    return SLWritePropertyNode.writeSLObject(child0Value_, child1Value, child2Value, ($bytecode), (DYNAMIC_OBJECT_LIBRARY_.getUncached(child0Value_)), (SLToTruffleStringNodeGen.getUncached()));
                }
                if ((!(SLWritePropertyNode.isSLObject(child0Value)))) {
                    return SLWritePropertyNode.writeObject(child0Value, child1Value, child2Value, ($bytecode), (INTEROP_LIBRARY_.getUncached(child0Value)), (SLToMemberNodeGen.getUncached()));
                }
                throw newUnsupportedSpecializationException3(this, child0Value, child1Value, child2Value);
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLUnboxNode#fromString}
     *     Activation probability: 0.19111
     *     With/without class size: 7/4 bytes
     *   Specialization {@link SLUnboxNode#fromTruffleString}
     *     Activation probability: 0.17111
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLUnboxNode#fromBoolean}
     *     Activation probability: 0.15111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLUnboxNode#fromLong}
     *     Activation probability: 0.13111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLUnboxNode#fromBigNumber}
     *     Activation probability: 0.11111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLUnboxNode#fromFunction(SLFunction)}
     *     Activation probability: 0.09111
     *     With/without class size: 5/0 bytes
     *   Specialization {@link SLUnboxNode#fromFunction(SLNull)}
     *     Activation probability: 0.07111
     *     With/without class size: 4/0 bytes
     *   Specialization {@link SLUnboxNode#fromForeign}
     *     Activation probability: 0.05111
     *     With/without class size: 5/4 bytes
     *   Specialization {@link SLUnboxNode#fromForeign}
     *     Activation probability: 0.03111
     *     With/without class size: 4/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLUnbox_Node extends Node {

        static final ReferenceField<FromForeign0Data> FROM_FOREIGN0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "fromForeign0_cache", FromForeign0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLUnboxNode#fromString}
         *   1: SpecializationActive {@link SLUnboxNode#fromTruffleString}
         *   2: SpecializationActive {@link SLUnboxNode#fromBoolean}
         *   3: SpecializationActive {@link SLUnboxNode#fromLong}
         *   4: SpecializationActive {@link SLUnboxNode#fromBigNumber}
         *   5: SpecializationActive {@link SLUnboxNode#fromFunction(SLFunction)}
         *   6: SpecializationActive {@link SLUnboxNode#fromFunction(SLNull)}
         *   7: SpecializationActive {@link SLUnboxNode#fromForeign}
         *   8: SpecializationActive {@link SLUnboxNode#fromForeign}
         *   9-10: ImplicitCast[type=SLBigInteger, index=0]
         * </pre> */
        @CompilationFinal private int state_0_;
        /**
         * Source Info: <pre>
         *   Specialization: {@link SLUnboxNode#fromString}
         *   Parameter: {@link FromJavaStringNode} fromJavaStringNode</pre> */
        @Child private FromJavaStringNode fromString_fromJavaStringNode_;
        @UnsafeAccessedField @Child private FromForeign0Data fromForeign0_cache;

        @ExplodeLoop
        private Object execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if ((state_0 & 0b111111111) != 0 /* is SpecializationActive[SLUnboxNode.fromString(String, FromJavaStringNode)] || SpecializationActive[SLUnboxNode.fromTruffleString(TruffleString)] || SpecializationActive[SLUnboxNode.fromBoolean(boolean)] || SpecializationActive[SLUnboxNode.fromLong(long)] || SpecializationActive[SLUnboxNode.fromBigNumber(SLBigInteger)] || SpecializationActive[SLUnboxNode.fromFunction(SLFunction)] || SpecializationActive[SLUnboxNode.fromFunction(SLNull)] || SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] || SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLUnboxNode.fromString(String, FromJavaStringNode)] */ && child0Value_ instanceof String) {
                    String child0Value__ = (String) child0Value_;
                    {
                        FromJavaStringNode fromJavaStringNode__ = this.fromString_fromJavaStringNode_;
                        if (fromJavaStringNode__ != null) {
                            return SLUnboxNode.fromString(child0Value__, fromJavaStringNode__);
                        }
                    }
                }
                if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLUnboxNode.fromTruffleString(TruffleString)] */ && child0Value_ instanceof TruffleString) {
                    TruffleString child0Value__ = (TruffleString) child0Value_;
                    return SLUnboxNode.fromTruffleString(child0Value__);
                }
                if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLUnboxNode.fromBoolean(boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    return SLUnboxNode.fromBoolean(child0Value__);
                }
                if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLUnboxNode.fromLong(long)] */ && child0Value_ instanceof Long) {
                    long child0Value__ = (long) child0Value_;
                    return SLUnboxNode.fromLong(child0Value__);
                }
                if ((state_0 & 0b10000) != 0 /* is SpecializationActive[SLUnboxNode.fromBigNumber(SLBigInteger)] */ && SLTypesGen.isImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_)) {
                    SLBigInteger child0Value__ = SLTypesGen.asImplicitSLBigInteger((state_0 & 0b11000000000) >>> 9 /* get-int ImplicitCast[type=SLBigInteger, index=0] */, child0Value_);
                    return SLUnboxNode.fromBigNumber(child0Value__);
                }
                if ((state_0 & 0b100000) != 0 /* is SpecializationActive[SLUnboxNode.fromFunction(SLFunction)] */ && child0Value_ instanceof SLFunction) {
                    SLFunction child0Value__ = (SLFunction) child0Value_;
                    return SLUnboxNode.fromFunction(child0Value__);
                }
                if ((state_0 & 0b1000000) != 0 /* is SpecializationActive[SLUnboxNode.fromFunction(SLNull)] */ && SLTypes.isSLNull(child0Value_)) {
                    SLNull child0Value__ = SLTypes.asSLNull(child0Value_);
                    return SLUnboxNode.fromFunction(child0Value__);
                }
                if ((state_0 & 0b110000000) != 0 /* is SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] || SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */) {
                    if ((state_0 & 0b10000000) != 0 /* is SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */) {
                        FromForeign0Data s7_ = this.fromForeign0_cache;
                        while (s7_ != null) {
                            if ((s7_.interop_.accepts(child0Value_))) {
                                return SLUnboxNode.fromForeign(child0Value_, s7_.interop_);
                            }
                            s7_ = s7_.next_;
                        }
                    }
                    if ((state_0 & 0b100000000) != 0 /* is SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */) {
                        return this.fromForeign1Boundary1(state_0, child0Value_, $bytecode, $bc, $bci, $sp);
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, $bytecode, $bc, $bci, $sp);
        }

        private boolean executeFromBoolean(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectBoolean(executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            return SLUnboxNode.fromBoolean(child0Value_);
        }

        private boolean executeFromBoolean$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectBoolean(executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            return SLUnboxNode.fromBoolean(child0Value_);
        }

        private long executeFromLong(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            return SLUnboxNode.fromLong(child0Value_);
        }

        private long executeFromLong$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) throws UnexpectedResultException {
            long child0Value_;
            try {
                child0Value_ = FRAMES.expectLong(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return SLTypesGen.expectLong(executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp));
            }
            return SLUnboxNode.fromLong(child0Value_);
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object fromForeign1Boundary(int state_0, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary interop__ = (INTEROP_LIBRARY_.getUncached(child0Value));
                    return SLUnboxNode.fromForeign(child0Value, interop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object fromForeign1Boundary0(int state_0, Object child0Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary interop__ = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    return SLUnboxNode.fromForeign(child0Value_, interop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        private Object executeAndSpecialize(Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof String) {
                String child0Value_ = (String) child0Value;
                FromJavaStringNode fromJavaStringNode__ = this.insert((FromJavaStringNode.create()));
                Objects.requireNonNull(fromJavaStringNode__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                VarHandle.storeStoreFence();
                this.fromString_fromJavaStringNode_ = fromJavaStringNode__;
                state_0 = state_0 | 0b1 /* add SpecializationActive[SLUnboxNode.fromString(String, FromJavaStringNode)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLUnboxNode.fromString(child0Value_, fromJavaStringNode__);
            }
            if (child0Value instanceof TruffleString) {
                TruffleString child0Value_ = (TruffleString) child0Value;
                state_0 = state_0 | 0b10 /* add SpecializationActive[SLUnboxNode.fromTruffleString(TruffleString)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLUnboxNode.fromTruffleString(child0Value_);
            }
            if (child0Value instanceof Boolean) {
                boolean child0Value_ = (boolean) child0Value;
                state_0 = state_0 | 0b100 /* add SpecializationActive[SLUnboxNode.fromBoolean(boolean)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLUnboxNode.fromBoolean(child0Value_);
            }
            if (child0Value instanceof Long) {
                long child0Value_ = (long) child0Value;
                state_0 = state_0 | 0b1000 /* add SpecializationActive[SLUnboxNode.fromLong(long)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLUnboxNode.fromLong(child0Value_);
            }
            {
                int sLBigIntegerCast0;
                if ((sLBigIntegerCast0 = SLTypesGen.specializeImplicitSLBigInteger(child0Value)) != 0) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(sLBigIntegerCast0, child0Value);
                    state_0 = (state_0 | (sLBigIntegerCast0 << 9) /* set-int ImplicitCast[type=SLBigInteger, index=0] */);
                    state_0 = state_0 | 0b10000 /* add SpecializationActive[SLUnboxNode.fromBigNumber(SLBigInteger)] */;
                    this.state_0_ = state_0;
                    quicken(state_0, $bc, $bci);
                    return SLUnboxNode.fromBigNumber(child0Value_);
                }
            }
            if (child0Value instanceof SLFunction) {
                SLFunction child0Value_ = (SLFunction) child0Value;
                state_0 = state_0 | 0b100000 /* add SpecializationActive[SLUnboxNode.fromFunction(SLFunction)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLUnboxNode.fromFunction(child0Value_);
            }
            if (SLTypes.isSLNull(child0Value)) {
                SLNull child0Value_ = SLTypes.asSLNull(child0Value);
                state_0 = state_0 | 0b1000000 /* add SpecializationActive[SLUnboxNode.fromFunction(SLNull)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLUnboxNode.fromFunction(child0Value_);
            }
            if (((state_0 & 0b100000000)) == 0 /* is-not SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */) {
                while (true) {
                    int count7_ = 0;
                    FromForeign0Data s7_ = FROM_FOREIGN0_CACHE_UPDATER.getVolatile(this);
                    FromForeign0Data s7_original = s7_;
                    while (s7_ != null) {
                        if ((s7_.interop_.accepts(child0Value))) {
                            break;
                        }
                        count7_++;
                        s7_ = s7_.next_;
                    }
                    if (s7_ == null) {
                        // assert (s7_.interop_.accepts(child0Value));
                        if (count7_ < (SLUnboxNode.LIMIT)) {
                            s7_ = this.insert(new FromForeign0Data(s7_original));
                            InteropLibrary interop__ = s7_.insert((INTEROP_LIBRARY_.create(child0Value)));
                            Objects.requireNonNull(interop__, "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                            s7_.interop_ = interop__;
                            if (!FROM_FOREIGN0_CACHE_UPDATER.compareAndSet(this, s7_original, s7_)) {
                                continue;
                            }
                            state_0 = state_0 | 0b10000000 /* add SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */;
                            this.state_0_ = state_0;
                            quicken(state_0, $bc, $bci);
                        }
                    }
                    if (s7_ != null) {
                        return SLUnboxNode.fromForeign(child0Value, s7_.interop_);
                    }
                    break;
                }
            }
            {
                InteropLibrary interop__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        interop__ = (INTEROP_LIBRARY_.getUncached(child0Value));
                        this.fromForeign0_cache = null;
                        state_0 = state_0 & 0xffffff7f /* remove SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */;
                        state_0 = state_0 | 0b100000000 /* add SpecializationActive[SLUnboxNode.fromForeign(Object, InteropLibrary)] */;
                        this.state_0_ = state_0;
                        quicken(state_0, $bc, $bci);
                        return SLUnboxNode.fromForeign(child0Value, interop__);
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private Object fromForeign1Boundary1(int state_0, Object child0Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
            Node prev_ = encapsulating_.set(this);
            try {
                {
                    InteropLibrary interop__ = (INTEROP_LIBRARY_.getUncached(child0Value_));
                    return SLUnboxNode.fromForeign(child0Value_, interop__);
                }
            } finally {
                encapsulating_.set(prev_);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            short newOperand0;
            if ((state_0 & 0b111111011) == 0 /* only-active SpecializationActive[SLUnboxNode.fromBoolean(boolean)] */
               && (newOperand0 = applyQuickeningBoolean(oldOperand0)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_UNBOX$FROM_BOOLEAN$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_UNBOX$FROM_BOOLEAN_;
                }
            } else if ((state_0 & 0b111110111) == 0 /* only-active SpecializationActive[SLUnboxNode.fromLong(long)] */
               && (newOperand0 = applyQuickeningLong(oldOperand0)) != -1) {
                if (isQuickeningLong(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_UNBOX$FROM_LONG$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_UNBOX$FROM_LONG_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                newInstruction = Instructions.SL_UNBOX_;
            }
            BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class FromForeign0Data extends Node implements SpecializationDataNode {

            @Child FromForeign0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLUnboxNode#fromForeign}
             *   Parameter: {@link InteropLibrary} interop</pre> */
            @Child InteropLibrary interop_;

            FromForeign0Data(FromForeign0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public Object executeUncached(VirtualFrame frameValue, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof String) {
                    String child0Value_ = (String) child0Value;
                    return SLUnboxNode.fromString(child0Value_, (FromJavaStringNode.getUncached()));
                }
                if (child0Value instanceof TruffleString) {
                    TruffleString child0Value_ = (TruffleString) child0Value;
                    return SLUnboxNode.fromTruffleString(child0Value_);
                }
                if (child0Value instanceof Boolean) {
                    boolean child0Value_ = (boolean) child0Value;
                    return SLUnboxNode.fromBoolean(child0Value_);
                }
                if (child0Value instanceof Long) {
                    long child0Value_ = (long) child0Value;
                    return SLUnboxNode.fromLong(child0Value_);
                }
                if (SLTypesGen.isImplicitSLBigInteger(child0Value)) {
                    SLBigInteger child0Value_ = SLTypesGen.asImplicitSLBigInteger(child0Value);
                    return SLUnboxNode.fromBigNumber(child0Value_);
                }
                if (child0Value instanceof SLFunction) {
                    SLFunction child0Value_ = (SLFunction) child0Value;
                    return SLUnboxNode.fromFunction(child0Value_);
                }
                if (SLTypes.isSLNull(child0Value)) {
                    SLNull child0Value_ = SLTypes.asSLNull(child0Value);
                    return SLUnboxNode.fromFunction(child0Value_);
                }
                return SLUnboxNode.fromForeign(child0Value, (INTEROP_LIBRARY_.getUncached(child0Value)));
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLFunctionLiteralNode#perform}
     *     Activation probability: 1.00000
     *     With/without class size: 20/4 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLFunctionLiteral_Node extends Node {

        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLFunctionLiteralNode#perform}
         * </pre> */
        @CompilationFinal private int state_0_;
        @CompilationFinal private PerformData perform_cache;

        private SLFunction execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_ = FRAMES.uncheckedGetObject(frameValue, $sp - 1);
            if (state_0 != 0 /* is SpecializationActive[SLFunctionLiteralNode.perform(TruffleString, Node, SLFunction)] */ && child0Value_ instanceof TruffleString) {
                TruffleString child0Value__ = (TruffleString) child0Value_;
                PerformData s0_ = this.perform_cache;
                if (s0_ != null) {
                    {
                        Node node__ = (this);
                        return SLFunctionLiteralNode.perform(child0Value__, node__, s0_.result_);
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, $bytecode, $bc, $bci, $sp);
        }

        private SLFunction executeAndSpecialize(Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            {
                Node node__ = null;
                if (child0Value instanceof TruffleString) {
                    TruffleString child0Value_ = (TruffleString) child0Value;
                    PerformData s0_ = new PerformData();
                    node__ = (this);
                    s0_.result_ = (SLFunctionLiteralNode.lookupFunctionCached(child0Value_, node__));
                    VarHandle.storeStoreFence();
                    this.perform_cache = s0_;
                    state_0 = state_0 | 0b1 /* add SpecializationActive[SLFunctionLiteralNode.perform(TruffleString, Node, SLFunction)] */;
                    this.state_0_ = state_0;
                    return SLFunctionLiteralNode.perform(child0Value_, node__, s0_.result_);
                }
            }
            throw new UnsupportedSpecializationException(this, null, child0Value);
        }

        @TruffleBoundary
        private static UnsupportedSpecializationException newUnsupportedSpecializationException1(Node thisNode_, Object child0Value) {
            return new UnsupportedSpecializationException(thisNode_, null, child0Value);
        }

        @DenyReplace
        private static final class PerformData implements SpecializationDataNode {

            /**
             * Source Info: <pre>
             *   Specialization: {@link SLFunctionLiteralNode#perform}
             *   Parameter: {@link SLFunction} result</pre> */
            @CompilationFinal SLFunction result_;

            PerformData() {
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public SLFunction executeUncached(VirtualFrame frameValue, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof TruffleString) {
                    TruffleString child0Value_ = (TruffleString) child0Value;
                    return SLFunctionLiteralNode.perform(child0Value_, ($bytecode), (SLFunctionLiteralNode.lookupFunction(child0Value_, ($bytecode))));
                }
                throw newUnsupportedSpecializationException1(this, child0Value);
            }

        }
    }
    /**
     * Debug Info: <pre>
     *   Specialization {@link SLToBooleanNode#doBoolean}
     *     Activation probability: 0.38500
     *     With/without class size: 8/0 bytes
     *   Specialization {@link SLToBooleanNode#doInterop}
     *     Activation probability: 0.29500
     *     With/without class size: 11/4 bytes
     *   Specialization {@link SLToBooleanNode#doInterop}
     *     Activation probability: 0.20500
     *     With/without class size: 6/0 bytes
     *   Specialization {@link SLToBooleanNode#doFallback}
     *     Activation probability: 0.11500
     *     With/without class size: 5/0 bytes
     * </pre> */
    @SuppressWarnings("javadoc")
    private static final class SLToBoolean_Node extends Node {

        static final ReferenceField<Interop0Data> INTEROP0_CACHE_UPDATER = ReferenceField.create(MethodHandles.lookup(), "interop0_cache", Interop0Data.class);
        private static final Uncached UNCACHED = new Uncached();

        /**
         * State Info: <pre>
         *   0: SpecializationActive {@link SLToBooleanNode#doBoolean}
         *   1: SpecializationActive {@link SLToBooleanNode#doInterop}
         *   2: SpecializationActive {@link SLToBooleanNode#doInterop}
         *   3: SpecializationActive {@link SLToBooleanNode#doFallback}
         * </pre> */
        @CompilationFinal private int state_0_;
        @UnsafeAccessedField @Child private Interop0Data interop0_cache;

        @ExplodeLoop
        private boolean execute(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if (state_0 != 0 /* is SpecializationActive[SLToBooleanNode.doBoolean(boolean)] || SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLToBooleanNode.doBoolean(boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    return SLToBooleanNode.doBoolean(child0Value__);
                }
                if ((state_0 & 0b1110) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */) {
                    if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */) {
                        Interop0Data s1_ = this.interop0_cache;
                        while (s1_ != null) {
                            if ((s1_.lib_.accepts(child0Value_)) && (s1_.lib_.isBoolean(child0Value_))) {
                                Node node__ = (s1_);
                                return SLToBooleanNode.doInterop(child0Value_, node__, s1_.lib_);
                            }
                            s1_ = s1_.next_;
                        }
                    }
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary lib__ = (INTEROP_LIBRARY_.getUncached());
                                if ((lib__.isBoolean(child0Value_))) {
                                    return this.interop1Boundary1(state_0, child0Value_, $bytecode, $bc, $bci, $sp);
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */) {
                        {
                            Node node__1 = (this);
                            if (fallbackGuard_(state_0, child0Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLToBooleanNode.doFallback(child0Value_, node__1);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, $bytecode, $bc, $bci, $sp);
        }

        private boolean executeBoolean(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLToBooleanNode.doBoolean(child0Value_);
        }

        private boolean executeBoolean$unboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            boolean child0Value_;
            try {
                child0Value_ = FRAMES.expectBoolean(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            return SLToBooleanNode.doBoolean(child0Value_);
        }

        @ExplodeLoop
        private boolean executeunboxed(VirtualFrame frameValue, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            Object child0Value_;
            try {
                child0Value_ = FRAMES.expectObject(frameValue, $sp - 1);
            } catch (UnexpectedResultException ex) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                return executeAndSpecialize(ex.getResult(), $bytecode, $bc, $bci, $sp);
            }
            if (state_0 != 0 /* is SpecializationActive[SLToBooleanNode.doBoolean(boolean)] || SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */) {
                if ((state_0 & 0b1) != 0 /* is SpecializationActive[SLToBooleanNode.doBoolean(boolean)] */ && child0Value_ instanceof Boolean) {
                    boolean child0Value__ = (boolean) child0Value_;
                    return SLToBooleanNode.doBoolean(child0Value__);
                }
                if ((state_0 & 0b1110) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] || SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */) {
                    if ((state_0 & 0b10) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */) {
                        Interop0Data s1_ = this.interop0_cache;
                        while (s1_ != null) {
                            if ((s1_.lib_.accepts(child0Value_)) && (s1_.lib_.isBoolean(child0Value_))) {
                                Node node__ = (s1_);
                                return SLToBooleanNode.doInterop(child0Value_, node__, s1_.lib_);
                            }
                            s1_ = s1_.next_;
                        }
                    }
                    if ((state_0 & 0b100) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */) {
                        EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                        Node prev_ = encapsulating_.set(this);
                        try {
                            {
                                InteropLibrary lib__ = (INTEROP_LIBRARY_.getUncached());
                                if ((lib__.isBoolean(child0Value_))) {
                                    return this.interop1Boundary2(state_0, child0Value_, $bytecode, $bc, $bci, $sp);
                                }
                            }
                        } finally {
                            encapsulating_.set(prev_);
                        }
                    }
                    if ((state_0 & 0b1000) != 0 /* is SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */) {
                        {
                            Node node__1 = (this);
                            if (fallbackGuard_(state_0, child0Value_, $bytecode, $bc, $bci, $sp)) {
                                return SLToBooleanNode.doFallback(child0Value_, node__1);
                            }
                        }
                    }
                }
            }
            CompilerDirectives.transferToInterpreterAndInvalidate();
            return executeAndSpecialize(child0Value_, $bytecode, $bc, $bci, $sp);
        }

        @SuppressWarnings("static-method")
        private boolean fallbackGuard_(int state_0, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            if (!((state_0 & 0b1) != 0 /* is SpecializationActive[SLToBooleanNode.doBoolean(boolean)] */) && child0Value instanceof Boolean) {
                return false;
            }
            if (!((state_0 & 0b100) != 0 /* is SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */) && ((INTEROP_LIBRARY_.getUncached()).isBoolean(child0Value))) {
                return false;
            }
            return true;
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interop1Boundary(int state_0, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary lib__ = (INTEROP_LIBRARY_.getUncached());
                return SLToBooleanNode.doInterop(child0Value, node__, lib__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interop1Boundary0(int state_0, Object child0Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary lib__ = (INTEROP_LIBRARY_.getUncached());
                return SLToBooleanNode.doInterop(child0Value_, node__, lib__);
            }
        }

        @SuppressWarnings("unused")
        private boolean executeAndSpecialize(Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            int state_0 = this.state_0_;
            if (child0Value instanceof Boolean) {
                boolean child0Value_ = (boolean) child0Value;
                state_0 = state_0 | 0b1 /* add SpecializationActive[SLToBooleanNode.doBoolean(boolean)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLToBooleanNode.doBoolean(child0Value_);
            }
            {
                Node node__ = null;
                if (((state_0 & 0b100)) == 0 /* is-not SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */) {
                    while (true) {
                        int count1_ = 0;
                        Interop0Data s1_ = INTEROP0_CACHE_UPDATER.getVolatile(this);
                        Interop0Data s1_original = s1_;
                        while (s1_ != null) {
                            if ((s1_.lib_.accepts(child0Value)) && (s1_.lib_.isBoolean(child0Value))) {
                                node__ = (s1_);
                                break;
                            }
                            count1_++;
                            s1_ = s1_.next_;
                        }
                        if (s1_ == null) {
                            {
                                InteropLibrary lib__ = this.insert((INTEROP_LIBRARY_.create(child0Value)));
                                // assert (s1_.lib_.accepts(child0Value));
                                if ((lib__.isBoolean(child0Value)) && count1_ < (3)) {
                                    s1_ = this.insert(new Interop0Data(s1_original));
                                    node__ = (s1_);
                                    Objects.requireNonNull(s1_.insert(lib__), "A specialization cache returned a default value. The cache initializer must never return a default value for this cache. Use @Cached(neverDefault=false) to allow default values for this cached value or make sure the cache initializer never returns the default value.");
                                    s1_.lib_ = lib__;
                                    if (!INTEROP0_CACHE_UPDATER.compareAndSet(this, s1_original, s1_)) {
                                        continue;
                                    }
                                    state_0 = state_0 | 0b10 /* add SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */;
                                    this.state_0_ = state_0;
                                    quicken(state_0, $bc, $bci);
                                }
                            }
                        }
                        if (s1_ != null) {
                            return SLToBooleanNode.doInterop(child0Value, node__, s1_.lib_);
                        }
                        break;
                    }
                }
            }
            {
                InteropLibrary lib__ = null;
                Node node__ = null;
                {
                    EncapsulatingNodeReference encapsulating_ = EncapsulatingNodeReference.getCurrent();
                    Node prev_ = encapsulating_.set(this);
                    try {
                        {
                            lib__ = (INTEROP_LIBRARY_.getUncached());
                            if ((lib__.isBoolean(child0Value))) {
                                node__ = (this);
                                this.interop0_cache = null;
                                state_0 = state_0 & 0xfffffffd /* remove SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */;
                                state_0 = state_0 | 0b100 /* add SpecializationActive[SLToBooleanNode.doInterop(Object, Node, InteropLibrary)] */;
                                this.state_0_ = state_0;
                                quicken(state_0, $bc, $bci);
                                return SLToBooleanNode.doInterop(child0Value, node__, lib__);
                            }
                        }
                    } finally {
                        encapsulating_.set(prev_);
                    }
                }
            }
            {
                Node node__1 = null;
                node__1 = (this);
                state_0 = state_0 | 0b1000 /* add SpecializationActive[SLToBooleanNode.doFallback(Object, Node)] */;
                this.state_0_ = state_0;
                quicken(state_0, $bc, $bci);
                return SLToBooleanNode.doFallback(child0Value, node__1);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interop1Boundary1(int state_0, Object child0Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary lib__ = (INTEROP_LIBRARY_.getUncached());
                return SLToBooleanNode.doInterop(child0Value_, node__, lib__);
            }
        }

        @SuppressWarnings("static-method")
        @TruffleBoundary
        private boolean interop1Boundary2(int state_0, Object child0Value_, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
            {
                Node node__ = (this);
                InteropLibrary lib__ = (INTEROP_LIBRARY_.getUncached());
                return SLToBooleanNode.doInterop(child0Value_, node__, lib__);
            }
        }

        private static void quicken(int state_0, byte[] $bc, int $bci) {
            short newInstruction;
            int oldOperandIndex0 = BYTES.getIntUnaligned($bc, $bci + 6 /* imm child0 */);
            short oldOperand0;
            if (oldOperandIndex0 != -1) {
                oldOperand0 = BYTES.getShort($bc, oldOperandIndex0);
            } else {
                oldOperand0 = -1;
            }
            short newOperand0;
            if ((state_0 & 0b1110) == 0 /* only-active SpecializationActive[SLToBooleanNode.doBoolean(boolean)] */
               && (newOperand0 = applyQuickeningBoolean(oldOperand0)) != -1) {
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_TO_BOOLEAN$BOOLEAN$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_TO_BOOLEAN$BOOLEAN_;
                }
            } else {
                newOperand0 = undoQuickening(oldOperand0);
                if (isQuickeningBoolean(BYTES.getShort($bc, $bci))) {
                    newInstruction = Instructions.SL_TO_BOOLEAN$UNBOXED_;
                } else {
                    newInstruction = Instructions.SL_TO_BOOLEAN_;
                }
            }
            if (newOperand0 != -1) {
                BYTES.putShort($bc, oldOperandIndex0, newOperand0);
            }
            BYTES.putShort($bc, $bci, newInstruction);
        }

        @DenyReplace
        private static final class Interop0Data extends Node implements SpecializationDataNode {

            @Child Interop0Data next_;
            /**
             * Source Info: <pre>
             *   Specialization: {@link SLToBooleanNode#doInterop}
             *   Parameter: {@link InteropLibrary} lib</pre> */
            @Child InteropLibrary lib_;

            Interop0Data(Interop0Data next_) {
                this.next_ = next_;
            }

        }
        @DenyReplace
        private static final class Uncached extends Node implements UnadoptableNode {

            public boolean executeUncached(VirtualFrame frameValue, Object child0Value, AbstractBytecodeNode $bytecode, byte[] $bc, int $bci, int $sp) {
                CompilerDirectives.transferToInterpreterAndInvalidate();
                if (child0Value instanceof Boolean) {
                    boolean child0Value_ = (boolean) child0Value;
                    return SLToBooleanNode.doBoolean(child0Value_);
                }
                if (((INTEROP_LIBRARY_.getUncached(child0Value)).isBoolean(child0Value))) {
                    return SLToBooleanNode.doInterop(child0Value, ($bytecode), (INTEROP_LIBRARY_.getUncached(child0Value)));
                }
                return SLToBooleanNode.doFallback(child0Value, ($bytecode));
            }

        }
    }
}
